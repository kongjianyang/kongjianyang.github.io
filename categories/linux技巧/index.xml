<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux技巧 on KJY</title><link>https://kongjianyang.github.io/categories/linux%E6%8A%80%E5%B7%A7/</link><description>Recent content in Linux技巧 on KJY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 02 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://kongjianyang.github.io/categories/linux%E6%8A%80%E5%B7%A7/index.xml" rel="self" type="application/rss+xml"/><item><title>markdown格式进阶备忘</title><link>https://kongjianyang.github.io/cn/2018/12/02/md%E6%A0%BC%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%A4%87%E5%BF%98/</link><pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/02/md%E6%A0%BC%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%A4%87%E5%BF%98/</guid><description>HTML是英文Hyper Text Mark-up Language (超文本标记语言) 的缩写，则Markdown的意思可能是反标记，因为markup是标记。
1. 任务列表 - [ ] 任务一 未做任务 - [x] 任务二 已做任务 任务一 未做任务 任务二 已做任务 2. 删除线 &amp;amp; 分割线 ~~需要加删除线的内容~~ &amp;lt;del&amp;gt;需要加删除线的内容&amp;lt;/del&amp;gt; 效果：
需要加删除线的内容
需要加删除线的内容
*** ***** - - - 效果：
3. 简单公式 $$E=mc^2$$ 效果：
$$E=mc^2$$
4. 嵌套引用 &amp;gt; 这是外层的引用 &amp;gt; &amp;gt; 这是内层的引用 这是外层的引用
这是内层的引用
5. 表格 其中的一个例子
| Table | Col1 | Col2 | | ----- |:----:| ----:| | Row1 | 1-1 | 1-2 | | Row2 | 2-1 | 2-2 | | Row3 | 3-1 | 3-2 | Table Col1 Col2 Row1 1-1 1-2 Row2 2-1 2-2 Row3 3-1 3-2 齐总的点代表对齐方式，分别是默认（居右）、居中、居左。 还可以使表格居中</description></item><item><title>macOS下的一些快捷操作</title><link>https://kongjianyang.github.io/cn/2018/11/30/macos%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/30/macos%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</guid><description>以下快捷键按照对我的重要程度进行排序
1. 最强大快捷键 使用automator定制化自己的快捷键
打开automator 打开quick action， 选择service input = noinput以及any application都能打开 选择launch application，例如选择Google，运行run测试是不是可以工作，保存为launch Google 打开setting， 选择keyboard，选择shortcuts，选择services定制自己的快捷键 一般选择设置三个以上的键组会快捷键，我设置为shift-command-control-G为快捷键 2. chrome快捷键 快捷键 操作 command+T 增加窗口 command+N 增加打开 command+~ 切换浏览器窗口 ⌘-Option 和向右箭 切换到下一个标签页 ⌘-Option 和向左 切换到上一个标签页 command+W 关闭当前窗口 command+F 搜索 command+0 还原大小 command+option+c 拷贝网址 command+shift+T 重新打开刚刚不小心关闭的网页 ⌘-Option-B 打开书签管理器。 ⌘-Y 打开“历史记录”页面。 command+R 刷新 command+.</description></item><item><title>vim编辑常用命令</title><link>https://kongjianyang.github.io/cn/2018/11/29/vim%E7%BC%96%E8%BE%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/29/vim%E7%BC%96%E8%BE%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>一、插入文本 常用的，当然是i，但是如果只用i，那就太土鳖了，记住i、o、a即可， 当然大小写，一般区分前后的概念，这个是vim在设计各类指令的原则。
命令 执行的操作 i 在光标的左侧插入字符 I 在行首插入字符 a 在光标的右侧添加文本 A 在行尾添加文本 o 在当前行下面插入一空行 O 在当前行上面插入一空行 下面还有几个常用的设置：
命令 执行的操作 :set showmode 当vi处在输入模式下时显示提示信息 :set sm 即时显示配对的)或} :set ts=n 把制表符设置为n(默认为8) :set ai 下一行从前一行的缩进位置开始（这个在写代码时比较有用） 二. 查找 命令 执行的操作 /xxx(?</description></item><item><title>Mac下使用crontab进行定时任务</title><link>https://kongjianyang.github.io/cn/2018/11/25/mac%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E8%BF%9B%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/25/mac%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E8%BF%9B%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>1. 开启 crontab crontab意思是排程命令，查看 crontab 是否启动
sudo launchctl list | grep cron 检查需要的文件
ls -al /etc/crontab 如果 crontab 文件不存在则创建
sudo touch /etc/crontab 2. 添加定时任务 # 打开定时任务设定文件 crontab -e 举个例子, 每分钟输出当前时间到time.txt上.
*/1 * * * * /bin/date &amp;gt;&amp;gt; ~/Desktop/time.txt
查看任务列表
crontab -l 删除任务
# 打开定时任务设定文件 crontab -e 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。
删除crontab文件
crontab -r 可以加上邮件通知
# send email to me MAILTO=&amp;#34;your email stress&amp;#34; git push origin master 如果上步错误的话，可以用下面的命令
git remote set-url origin git@github.com:username/repo.git 3. 语法 格式：分 时 日 月 星期几 命令 # 每天12点1分执行[/example/laohou-cron.</description></item><item><title>-bash_profile和-bashrc的区别</title><link>https://kongjianyang.github.io/cn/2018/11/24/bash_profile%E5%92%8C-bashrc%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/bash_profile%E5%92%8C-bashrc%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>/etc/profile 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置。 /etc/bashrc 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。 ~/.bash_profile 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。 ~/.bashrc 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。 ~/.bash_logout 少见，但是意味着当每次退出系统(退出bash shell)时,执行该文件。
另外/etc/profile 中设定的变量(全局)的可以作用于任何用户, 而~/.bashrc 等中设定的变量(局部)只能继承 /etc/profile 中的变量,他们是&amp;quot;父子&amp;quot;关系。
profile用于登录式shell, 而bashrc用于每个交互式shell ~/.bash_profile 是交互式、login 方式进入 bash 运行的 ~/.bashrc 是交互式 non-login 方式进入 bash 运行的 通常二者设置大致相同，所以通常前者会调用后者。 所以一般优先把变量设置在.bashrc里面。比如在crontab里面执行一个命令，.bashrc 设置的环境变量会生效，而 .bash_profile 不会。
设置生效：可以重启生效，也可以使用命令：source
source /etc/profile</description></item><item><title>git取消链接并删除本地库</title><link>https://kongjianyang.github.io/cn/2018/11/24/git%E5%8F%96%E6%B6%88%E9%93%BE%E6%8E%A5%E5%B9%B6%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%BA%93/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/git%E5%8F%96%E6%B6%88%E9%93%BE%E6%8E%A5%E5%B9%B6%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%BA%93/</guid><description>有的时候我们需要删除从GitHub上克隆下来的库
从github上clone一个仓库：
git clone git@github.com:USERNAME/repo.git 在本地目录下关联远程repository
git remote add origin git@github.com:git_username/repository_name.git 取消本地目录下关联的远程库
git remote remove origin 删除本地库
Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ git branch #显示本地所有分支 * master Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ git init 1#初始化仓库 Reinitialized existing Git repository in D:/Program Files/Git/gitskills/gitskills/.git/ Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ ls -a 2#查看内部文件 ./ ../ .git/ README.md Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ rm -rf .git 3#强删.git Quincy_C@Quincy MINGW64 /gitskills/gitskills $ ls -a 4#查看内部文件 .</description></item><item><title>linux下ls的一些操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8Bls%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8Bls%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</guid><description>只显示隐藏文件夹
ls -d .* # -d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表； 按照文件大小排序
ls -lS #从大到小 ls -lSr #从小到大 寻找指定时间文件并移动
find ./ -mmin -60 | xargs -I {} cp {} ../</description></item><item><title>Linux下批量修改文件名</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</guid><description>方法一：Rename函数 Linux下修改文件名有mv和rename。其中mv命令只能对单个文件重命名，这是mv命令和rename命令的在重命名方面的根本区别。
linux的rename命令有两个版本，一个是c语言版本的，一个是perl语言版本的，判断方法： 输入man rename 看到第一行是： RENAME(1) Linux Programmer’s Manual RENAME(1) 这个就是C语言版本的 而如果出现： RENAME(1) Perl Programmers Reference Guide RENAME(1) 则是Perl版本的了
C语言版本格式：rename 原字符串 新字符串 文件名 Perl语言版本格式：rename &amp;rsquo;s/原字符串/新字符串/&amp;rsquo; 文件名
rename支持正则表达式
例子：
字母的替换rename &amp;quot;s/AA/aa/&amp;quot; * //把文件名中的AA替换成aa 修改文件的后缀rename &amp;quot;s//.html//.php/&amp;quot; * //把.html 后缀的改成 .php后缀 批量添加文件后缀rename &amp;quot;s/$//.txt/&amp;quot; * //把所有的文件名都以txt结尾 批量删除文件名rename &amp;quot;s//.txt//&amp;quot; * //把所有以.txt结尾的文件名的.txt删掉
方法二：mv函数 在文件夹shell下创建文件10个文件 touch tmp_{1..10}.txt 找到含有“_“”的文件夹。 find ./ -name &amp;#34;*_*&amp;#34; 读取id, 用mv改名，$为自己理解为赋值后的id，格式为while； do； done find ./ -name &amp;#34;*_*&amp;#34; | while read id; do mv $id ${id/_/-}; done</description></item><item><title>Linux下递归查找某文件并移动</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E6%9F%90%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E6%9F%90%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8/</guid><description>Linux下递归查找某类型文件可以使用find命令，例如我想查找所有的.sh文件，可以使用一下命令
find . -name &amp;#34;*.sh&amp;#34; 而如果我们希望移动所有这类型的文件到指定文件夹，在zsh下可以使用
cp **/*.sh sh_file</description></item><item><title>macOS系统下各文件夹详解</title><link>https://kongjianyang.github.io/cn/2018/11/24/macos%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/macos%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/</guid><description>macOS是一个基于UNIX核心的系统，增强了系统的稳定性、性能以及响应能力。下图就介绍了macOS，Windows和Linux系统之间的区别
1. 符合unix传统的目录 /bin 传统unix命令的存放目录，如ls，rm，mv等。 /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 /usr 第三方程序安装目录。 /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）. /etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 /dev 设备文件存放目录，如何代表硬盘的/dev/disk0。 /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 2. OS X系统特有的目录。 /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里； /Library 系统资源库，系统的数据文件、帮助文件、文档等等； 比如字体、ColorSync 配置、偏好设置以及插件都应该安装在 Library 目录下适当的子目录中。 Application Support包含了应用相关的数据以及支持文件，比如第三方的插件，帮助应用，模板以及应用使用到但是并不需要用来支持运行的额外资源文件。按照惯例，所有这些内容都会被存储在以应用名称命名的子目录当中。 Assistants包含了帮助用户进行配置或者其它任务的程序。 Documentation包含了供计算机用户和管理员参考的文档文件和 Apple 帮助包。(Apple 帮助包在Help 子目录当中。) 在本地域中，这个目录包含了 Apple 公司发布的帮助包(不包括开发者文档)。 Extensions包含了设备驱动和其它内核扩展。(只存在于系统域当中。) Favorites包含了指向经常访问的文件夹、文件或者网站的别名。(仅仅存在于用户域当中。)
/Network 网络节点存放目录； /System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 /System/Library/Extensions其实这裡就是用作存放硬件驱动的地方,苹果不称驱动程序为driver, 而是称为Extension. /System/Library/HelpViewer一切和Mac OS Help有关的档案及文件都存放于此 System/Library/CoreServices/Finder.app这个比较特别, 因为这是一个应用而非一个档桉夹, Finder.app可说是负责掌控整个OS上的一切资源. /System/Library/CoreServices/Menu ExtrasStatus bar上面所有系统自带工具的原文件，双击打开可以直接在status bar上添加相应文件 /System/Library/CoreServices/Software Update这裡就是负责Software update的地方 /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 /Volumes 文件系统挂载点存放目录。 /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。</description></item><item><title>shell编程-bash-shell中的特殊变量</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/</guid><description>1.介绍 shell有很多以$开头的特殊变量，以下是对于这些变量的说明：
变量 意义 $$ Shell本身的PID（ProcessID） $! Shell最后运行的后台Process的PID $? 最后运行的命令的结束代码（返回值） $- 使用Set命令设定的Flag一览 $* 所有参数列表。如&amp;quot;$*&amp;ldquo;用「&amp;quot;」括起来的情况、以&amp;rdquo;$1 $2 … $n&amp;quot;的形式输出所有参数。 $@ 所有参数列表。如&amp;quot;$@&amp;ldquo;用「&amp;quot;」括起来的情况、以&amp;rdquo;$1&amp;quot; &amp;ldquo;$2&amp;rdquo; … &amp;ldquo;$n&amp;rdquo; 的形式输出所有参数。 $# 添加到Shell的参数个数 $0 Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数… 2.例子 下面通过一个例子解释怎么使用这些特殊变量 命令一个variable.sh的简单脚本，其内容如下
#!/bin/bash echo &amp;#34;number:$#&amp;#34; # $# 是传给脚本的参数个数 echo &amp;#34;scname:$0&amp;#34; # $0 是脚本本身的名字 echo &amp;#34;first :$1&amp;#34; # $1是传递给该shell脚本的第一个参数 echo &amp;#34;second:$2&amp;#34; # $2是传递给该shell脚本的第二个参数 echo &amp;#34;argume:$@&amp;#34; # $@ 是传给脚本的所有参数的列表 echo &amp;#34;all argume:$*&amp;#34; # $* 所有参数列表 echo &amp;#34;finish code:$?</description></item><item><title>shell编程-bash-shell的字符串操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid><description>1.字符串属性 字符有可能是数字、字母、空格、其他特殊字符，而字符串有可能是它们中的一种或者多种的组合，在组合之后还可能形成具有特定意义的字符串，诸如邮件地址，URL地址等。
数字或者数字组合
$ i=5;j=9423483247234; $ echo $i | grep &amp;#34;^[0-9]$&amp;#34; 5 $ echo $j | grep &amp;#34;^[0-9]\+$&amp;#34; 9423483247234 字符组合
$ c=&amp;#34;A&amp;#34;; d=&amp;#34;fwefewjuew&amp;#34;; e=&amp;#34;fewfEFWefwefe&amp;#34; $ echo $c | grep &amp;#34;^[A-Z]$&amp;#34; A $ echo $d | grep &amp;#34;^[a-z]\+&amp;#34; fwefewjuew $ echo $e | grep &amp;#34;^[a-zA-Z]\+$&amp;#34; fewfEFWefwefe 字母和数字的组合
$ ic=&amp;#34;432fwfwefeFWEwefwef&amp;#34; $ echo $ic | grep &amp;#34;^[0-9a-zA-Z]\+$&amp;#34; 432fwfwefeFWEwefwef 匹配邮件地址
$ echo &amp;#34;test2007@lzu.cn&amp;#34; | grep &amp;#34;[0-9a-zA-Z\.]*@[0-9a-zA-Z\.]*&amp;#34; test2007@lzu.cn 匹配 URL 地址
$ echo &amp;#34;http://news.lzu.edu.cn/article.jsp?newsid=10135&amp;#34; | grep &amp;#34;^http://[0-9a-zA-Z\.</description></item><item><title>shell编程-bash-shell的布尔运算</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</guid><description>在 Bash 里有这样的常量(实际上是两个内置命令，在这里我们姑且这么认为，后面将介绍)，即 true 和 false，一个表示真，一个表示假。对它们可以进行与、或、非运算等常规的逻辑运算。
1. 与或非运算 $ if true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi YES $ if false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO 与运算用&amp;amp;&amp;amp;表示
$ if true &amp;amp;&amp;amp; true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi YES $ if true &amp;amp;&amp;amp; false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO $ if false &amp;amp;&amp;amp; false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO $ if false &amp;amp;&amp;amp; true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO 或运算用||表示</description></item><item><title>shell编程-bash-shell的数值计算</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</guid><description>1. 数据计算基础 使用man 或者info查看shell bash的判断命令test，Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。
man test info test 可以使用type查看一个命令是否是shell内置的函数，例如
$ type type type is a shell builti $ type awk awk is /usr/bin/awk 从结果可知： let 是 Shell 内置命令，awk是外部命令，在 /usr/bin 目录下
expr命令是一个手工命令行计数器，用于在UNIX/LINUX下求表达式变量的值，一般用于整数值，也可用于字符串。
$ expr 5 % 2 1 bc 命令是任意精度计算器语言，通常在linux下当计算器用。它类似基本的计算器, 使用这个计算器可以做基本的数学运算。
$ bc bc 1.06 Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc. This is free software with ABSOLUTELY NO WARRANTY. For details type `warranty&amp;#39;. 3^2 9 let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</description></item><item><title>shell编程-bash-shell的文件操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid><description>1. 基本操作 ls 命令显示文件基本属性，d 表示目录，- 表示普通文件（或者硬链接），l 表示符号链接，p 表示管道文件，b 和 c 分别表示块设备和字符设备。除此之外还可以使用stat命令，stat以文字的格式来显示inode的内容。
$ stat bin/ 16777220 8608385535 drwxr-xr-x 37 root wheel 0 1184 &amp;#34;Nov 23 09:06:38 2018&amp;#34; &amp;#34;Nov 10 01:38:56 2018&amp;#34; &amp;#34;Nov 10 01:38:56 2018&amp;#34; &amp;#34;Sep 21 00:17:17 2018&amp;#34; 4096 0 0x88000 bin/ file命令也可以给出文件的基本信息
$ file bin bin: directory 可以使用chmod给文件添加权限
chmod 777 regular_file 可以使用passwd命令给用户修改自己的密码
passwd #普通用户通过执行该命令，修改自己的密码 可以使用tree显示目录树
$ tree #当前目录 2. 压缩与解压缩文件 #tar $ tar -cf file.tar file #压缩 $ tar -xf file.</description></item><item><title>shell编程-shell编程基础</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>1.什么是shell shell是介于用户和操作系统之间的一个接口，用来接收用户的键盘输入，并分析和执行输入字符串中的命令，然后给用户返回执行结果，于GUI相比，shell因为使用命令行，所以使用起来可能比较复杂，但是使用的资源会比较少，而且拥有批处理的功能。
一图看shell在操作系统中的位置 使用命令查看当前shell
echo $SHELL #/bin/zsh ls -l /bin/zsh #-rwxr-xr-x 1 root wheel 610224 Sep 21 00:17 /bin/zsh 如果你发现当前 Shell 不是 Bash，请用下面的方法替换它：
$ bash $ echo $SHELL # 确认一下 /bin/bash ##2.简单的shell脚本 假设我们设计一个test.sh的脚本，内容如下
#!/bin/bash # test.sh echo &amp;#34;Hello, World&amp;#34; 重点是该文件的第一行，当我们直接运行该脚本文件时，该行告诉操作系统使用用#! 符号之后面的解释器以及相应的参数来解释该脚本文件，通过分析第一行，我们发现对应的解释器是 /bin/bash。
3.shell的执行原理 Shell 接收用户输入的脚本名，并进行分析。如果文件被标记为可执行，但不是被编译过的程序，Shell 就认为它是一个 Shell 脚本。 Shell 将读取其中的内容，并加以解释执行。所以，从用户的观点看，执行 Shell 脚本的方式与执行一般的可执行文件的方式相似。
因此，用户开发的 Shell 脚本可以驻留在命令搜索路径的目录之下（通常是 /bin、/usr/bin等），像普通命令一样使用。这样，也就开发出自己的新命令。如果打算反复使用编好的 Shell 脚本，那么采用这种方式就比较方便。</description></item><item><title>tmux-指南</title><link>https://kongjianyang.github.io/cn/2018/11/24/tmux-%E6%8C%87%E5%8D%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/tmux-%E6%8C%87%E5%8D%97/</guid><description>我的tmux配置 https://wdxtub.com/2016/03/30/tmux-guide/</description></item><item><title>xargs命令与管道的区别</title><link>https://kongjianyang.github.io/cn/2018/11/24/xargs%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/xargs%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>xargs是一条Unix 和类Unix 操作系统 的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。
下面两个例子解释xargs命令与管道之间的区别
echo &amp;#39;main&amp;#39; | cat # main 这条命令中cat会从其标准输入中读取内容并处理，也就是会输出 &amp;lsquo;main&amp;rsquo; 字符串。echo命令将其标准输出的内容 &amp;lsquo;main&amp;rsquo; 通过管道定向到 cat 的标准输入中
echo &amp;#39;--help&amp;#39; | xargs cat #cat: illegal option -- - #usage: cat [-benstuv] [file ...] 上述的命令类似
cat --help 可以看到 echo &amp;lsquo;&amp;ndash;help&amp;rsquo; | cat 该命令输出的是echo的内容，也就是说将echo的内容当作cat处理的文件内容了，实际上就是echo命令的输出通过管道定向到cat的输入了。然后cat从其标准输入中读取待处理的文本内容。这等价于在test.txt文件中有一行字符 &amp;lsquo;&amp;ndash;help&amp;rsquo; 然后运行 cat test.txt 的效果。
而 echo &amp;lsquo;&amp;ndash;help&amp;rsquo; | xargs cat 等价于 cat &amp;ndash;help 什么意思呢，就是xargs将其接受的字符串 &amp;ndash;help 做成cat的一个命令参数来运行cat命令，同样 echo &amp;rsquo;test.c test.cpp&amp;rsquo; | xargs cat 等价于 cat test.c test.cpp 此时会将test.c和test.cpp的内容都显示出来。</description></item><item><title>我的vim个性配置</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%88%91%E7%9A%84vim%E4%B8%AA%E6%80%A7%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%88%91%E7%9A%84vim%E4%B8%AA%E6%80%A7%E9%85%8D%E7%BD%AE/</guid><description>mac下安装vim
brew install vim 我的一些vim配置信息
&amp;#34; 显示行号 set number &amp;#34; 启用鼠标 set mouse=a &amp;#34; 显示标尺 set ruler &amp;#34; 历史纪录 set history=1000 &amp;#34; 输入的命令显示出来，看的清楚些 set showcmd &amp;#34; 状态行显示的内容 set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&amp;#34;%d/%m/%y\ -\ %H:%M\&amp;#34;)} &amp;#34; 启动显示状态行1，总是显示状态行2 set laststatus=2 &amp;#34; 语法高亮显示 syntax on set fileencodings=utf-8,gb2312,gbk,cp936,latin-1 set fileencoding=utf-8 set termencoding=utf-8 set fileformat=unix set encoding=utf-8 &amp;#34; 配色方案 colorscheme desert &amp;#34; 指定配色方案是256色 set t_Co=256 set wildmenu &amp;#34; 去掉有关vi一致性模式，避免以前版本的一些bug和局限，解决backspace不能使用的问题 set nocompatible set backspace=indent,eol,start set backspace=2 &amp;#34; 启用自动对齐功能，把上一行的对齐格式应用到下一行 set autoindent &amp;#34; 依据上面的格式，智能的选择对齐方式，对于类似C语言编写很有用处 set smartindent &amp;#34; vim禁用自动备份 set nobackup set nowritebackup set noswapfile &amp;#34; 用空格代替tab set expandtab &amp;#34; 设置显示制表符的空格字符个数,改进tab缩进值，默认为8，现改为4 set tabstop=4 &amp;#34; 统一缩进为4，方便在开启了et后使用退格(backspace)键，每次退格将删除X个空格 set softtabstop=4 &amp;#34; 设定自动缩进为4个字符，程序中自动缩进所使用的空白长度 set shiftwidth=4 &amp;#34; 设置帮助文件为中文(需要安装vimcdoc文档set helplang=cn &amp;#34; 显示匹配的括号 set showmatch &amp;#34; 文件缩进及tab个数 au FileType html,python,vim,javascript setl shiftwidth=4 au FileType html,python,vim,javascript setl tabstop=4 au FileType java,php setl shiftwidth=4 au FileType java,php setl tabstop=4 &amp;#34; 高亮搜索的字符串 set hlsearch &amp;#34; 检测文件的类型 filetype on filetype plugin on filetype indent on &amp;#34; C风格缩进 set cindent set completeopt=longest,menu &amp;#34; 功能设置 &amp;#34; 去掉输入错误提示声音 set noeb &amp;#34; 自动保存 set autowrite &amp;#34; 突出显示当前行 set cursorline &amp;#34; 突出显示当前列 set cursorcolumn &amp;#34;设置光标样式为竖线vertical bar &amp;#34; Change cursor shape between insert and normal mode in iTerm2.</description></item><item><title>避免服务器上的老文件被系统删除</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E9%81%BF%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%80%81%E6%96%87%E4%BB%B6%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E9%81%BF%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%80%81%E6%96%87%E4%BB%B6%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4/</guid><description>学校规定服务器上的文件大于60天没有修改或者接触就会被系统删除，之前吃过这个亏，最近又收到系统提醒，所以写个小脚本避免文件被删除
#! /bin/bash purgelist | tail -n +9 &amp;gt; purgelist.txt # purgelist用来寻找系统内大于60天没有被修改或者接触的文件，前9行是一些无关信息，将要移除的文件存到purgelist.txt中 #读取purgelist.txt文件，对每个文件读head，达到更改最后接触时间的目的 cat purgelist.txt | while read LINE do head $LINE done 最后在系统运行bash avoid_purge.sh即可。</description></item></channel></rss>
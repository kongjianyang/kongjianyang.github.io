<a name=top></a><!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>KJY</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/vega@5.17.0></script>
<script src=https://cdn.jsdelivr.net/npm/vega-lite@4.17.0></script>
<script src=https://cdn.jsdelivr.net/npm/vega-embed@6.12.2></script>
<script>hljs.initHighlightingOnLoad()</script></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo><img src=/media/%3cnil%3e width height alt></a><ul class=nav-links><li><a href=/cn/about/>关于</a></li><li><a href=/cn/posts/>日志</a></li><li><a href=/cn/newsletter/>周刊</a></li><li><a href=/>English</a></li></ul></nav></header><main class=content role=main><div style=text-align:center><h1>R语言data.table学习</h1><p>KJY
/ 2020-05-05</p><hr></div><span class=article-toolbar><a href=https://github.com/kongjianyang/kongjianyang.github.io/edit/master/content/cn/posts/2020-05-05-R%e8%af%ad%e8%a8%80data.table%e5%ad%a6%e4%b9%a0.md style=font-size:24px;color:#000 target=_blank><i class="fa fa-edit" aria-hidden=true title=编辑本页></i></a></span><aside class=toc>Table of Contents:<nav id=TableOfContents><ol><li><a href=#介绍>介绍</a></li><li><a href=#使用datatable包操作数据>使用data.table包操作数据</a><ol><li><a href=#使用键获取值>使用键获取值</a></li><li><a href=#对数据进行分组汇总>对数据进行分组汇总</a></li><li><a href=#重塑datatable>重塑data.table</a></li><li><a href=#使用原地设置函数>使用原地设置函数</a></li><li><a href=#datatable的动态作用域>data.table的动态作用域</a></li></ol></li></ol></nav></aside><div class="body-text list-text"><h2 id=介绍>介绍<a href=#介绍 class=header-anchor arialabel=Anchor> #</a></h2><p><code>data.frame</code>是R内置的、默认的数据框类型（即一个具有行和列的数据表）。从外部导入的数据一般都以<code>data.frame</code>数据框格式在R里面进行处理和分析。</p><p><code>data.table</code>作为一种高级数据类型，首先继承了<code>data.frame</code>基础数据类型，其<a href="https://link.zhihu.com/?target=https%3A//cran.r-project.org/web/packages/data.table/data.table.pdf" target=_blank rel="noreferrer noopener">官方文档</a>
已经明确说明“<code>data.table</code>是<code>data.frame</code>的扩展（extension）”。</p><p><code>data.table</code>具备很多独特而出色的性质，与其他数据类型（如<code>data.frame</code>、<code>tibble</code>/<code>tbl_df</code>）相比具有很多优势。</p><ul><li><strong>高效：轻松、快速处理GB级别的大数据，并且融合了SQL数据库的语法风格</strong></li><li><strong>极简：只需很短的代码就能完成数据的行、列、分组、合并、重塑等相关操作</strong></li><li><strong>丰富：数据类型自带筛选、计算、分组、合并等多种方法，无需借助其他函数</strong></li></ul><p>此外，一部分R用户需要在数据框里面“嵌套表”，由于<code>data.frame</code>无法实现而十分推崇<code>tibble</code>（<code>tbl_df</code>）。其实，这一点不仅<code>tibble</code>能实现，<code>data.table</code>也完全能实现。</p><p>Jan Gorecki 曾对比过不同开源软件及程序包在数据处理方面的性能，结果发现，<code>data.table</code>在数据处理效率上秒杀一大批工具包，甚至轻松超越Python的<code>pandas</code>包和R语言的<code>dplyr</code>包（结果如下图，测试数据规模为5 GB）。而当数据规模达到50 GB，<code>pandas</code>和<code>dplyr</code>都已经hold不住了（报错或内存溢出），但<code>data.table</code>依然稳居榜首（详见：<a href="https://link.zhihu.com/?target=https%3A//h2oai.github.io/db-benchmark/" target=_blank rel="noreferrer noopener">数据处理工具性能大比拼</a>
）。</p><p>使用<code>data.table</code>包并不意味着排斥或弃用其他R包——相反，<code>data.table</code>包是能够和<code>tidyverse</code>、<code>dplyr</code>等著名R包<strong>兼容并存、相辅相成</strong>的。</p><p>这里需要明确几个事实：</p><ul><li><code>tidyverse</code>本身只是一系列常用包的集合（包括<code>dplyr</code>、<code>ggplot2</code>、<code>lubridate</code>、<code>stringr</code>、<code>tibble</code>、<code>tidyr</code>等），并且载入时会为用户默认载入某些常用包，但它本身并没有什么实质性的函数（不信可以查看它的帮助文档）。</li><li>管道操作符（<code>%>%</code>）非常好用，也与<code>data.table</code>完全兼容，但它本身既不是<code>tidyverse</code>包里的，也不是<code>dplyr</code>包里的，而是<code>magrittr</code>包里的。</li><li><code>dplyr</code>包的各种数据操作或处理函数，完全适用于<code>data.frame</code>、<code>tibble</code>/<code>tbl_df</code>、<code>data.table</code>等数据类型，因此<code>data.table</code>与<code>dplyr</code>并不冲突（比如，我个人也喜欢用<code>dplyr::left_join()</code>函数对<code>data.table</code>数据进行匹配拼接处理）。</li></ul><p>总之：</p><ul><li><code>tidyverse</code>是建议安装的一个综合性R包（并不必然与<code>tibble</code>相联系）</li><li><code>dplyr</code>是建议掌握的一个数据处理R包（并不必然与<code>tibble</code>相联系）</li><li><code>data.table</code>是强烈建议掌握的一个兼具数据类型和数据处理功能的R包</li><li>这三者是可以兼容并包、组合使用的</li></ul><h2 id=使用datatable包操作数据>使用data.table包操作数据<a href=#使用datatable包操作数据 class=header-anchor arialabel=Anchor> #</a></h2><p><strong>data.table包提供了一个加强版的data.frame，它运行效率极高，而且能够处理适合内存的大数据集，它使用[]实现了一种自然地数据操作语法</strong>。使用下面命令进行安装：</p><pre tabindex=0><code>install.packages(&#34;data.table&#34;)
</code></pre><p>载入包：</p><pre tabindex=0><code>library(data.table)
#&gt; 
#&gt; 载入程辑包：&#39;data.table&#39;
#&gt; The following objects are masked from &#39;package:reshape2&#39;:
#&gt; 
#&gt;     dcast, melt
</code></pre><p>注意，<code>data.table</code>包提供了加强版的<code>dcast()</code>和<code>melt()</code>，它们的功能更强大、性能更高，内存使用也更高效。</p><p>创建<code>data.table</code>与创建<code>data.frame</code>类似：</p><pre tabindex=0><code>dt = data.table(x = 1:3, y = rnorm(3), z = letters[1:3])
dt
#&gt;    x      y z
#&gt; 1: 1  0.906 a
#&gt; 2: 2 -0.154 b
#&gt; 3: 3  0.608 c
</code></pre><p>检查它的结构：</p><pre tabindex=0><code>str(dt)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   3 obs. of  3 variables:
#&gt;  $ x: int  1 2 3
#&gt;  $ y: num  0.906 -0.154 0.608
#&gt;  $ z: chr  &#34;a&#34; &#34;b&#34; &#34;c&#34;
#&gt;  - attr(*, &#34;.internal.selfref&#34;)=&lt;externalptr&gt;
</code></pre><p>可以看到，<code>dt</code>的类是<code>data.table</code>和<code>data.frame</code>，也就是说<code>data.table</code>继承了<code>data.frame</code>的一些行为，但增强了其他部分。</p><p>**<code>data.table</code>的基本语法是<code>dt[i, j, by]，简单说就是使用</code>i<code>选择行，用</code>by<code>分组，然后计算</code>j<code>**。接下来我们看看</code>data.table`继承了什么，增强了什么。</p><p>首先，我们仍然载入之前用到的产品数据，不过这里我们使用<code>data.table</code>包提供的<code>fread()</code>函数，它非常高效和智能，默认返回<code>data.table</code>。</p><pre tabindex=0><code>product_info = fread(&#34;../../R/dataset/product-info.csv&#34;)
product_stats = fread(&#34;../../R/dataset/product-stats.csv&#34;)
product_tests = fread(&#34;../../R/dataset/product-tests.csv&#34;)
toy_tests = fread(&#34;../../R/dataset/product-toy-tests.csv&#34;)
</code></pre><p>如果查看表格信息，你会发现它和<code>data.frame</code>没什么两样：</p><pre tabindex=0><code>product_info
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle      yes
#&gt; 2: T02  SupPlane   toy vehicle       no
#&gt; 3: M01     JeepX model vehicle      yes
#&gt; 4: M02 AircraftX model vehicle      yes
#&gt; 5: M03    Runner model  people      yes
#&gt; 6: M04    Dancer model  people       no
</code></pre><p>再看结构：</p><pre tabindex=0><code>str(product_info)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   6 obs. of  5 variables:
#&gt;  $ id      : chr  &#34;T01&#34; &#34;T02&#34; &#34;M01&#34; &#34;M02&#34; ...
#&gt;  $ name    : chr  &#34;SupCar&#34; &#34;SupPlane&#34; &#34;JeepX&#34; &#34;AircraftX&#34; ...
#&gt;  $ type    : chr  &#34;toy&#34; &#34;toy&#34; &#34;model&#34; &#34;model&#34; ...
#&gt;  $ class   : chr  &#34;vehicle&#34; &#34;vehicle&#34; &#34;vehicle&#34; &#34;vehicle&#34; ...
#&gt;  $ released: chr  &#34;yes&#34; &#34;no&#34; &#34;yes&#34; &#34;yes&#34; ...
#&gt;  - attr(*, &#34;.internal.selfref&#34;)=&lt;externalptr&gt;
</code></pre><p>与<code>data.frame</code>不同，如果只提供一个参数用来构建子集，<code>data.table</code>是选择行而不是列：</p><pre tabindex=0><code>product_info[1]
#&gt;     id   name type   class released
#&gt; 1: T01 SupCar  toy vehicle      yes

product_info[1:3]
#&gt;     id     name  type   class released
#&gt; 1: T01   SupCar   toy vehicle      yes
#&gt; 2: T02 SupPlane   toy vehicle       no
#&gt; 3: M01    JeepX model vehicle      yes
</code></pre><p>如果提供的是负数，那么将删除指定的行：</p><pre tabindex=0><code>product_info[-1]
#&gt;     id      name  type   class released
#&gt; 1: T02  SupPlane   toy vehicle       no
#&gt; 2: M01     JeepX model vehicle      yes
#&gt; 3: M02 AircraftX model vehicle      yes
#&gt; 4: M03    Runner model  people      yes
#&gt; 5: M04    Dancer model  people       no
</code></pre><p><strong>data.table提供了许多特殊符号，它们是data.table的重要组成</strong>。<code>.N</code>是最常用的符号之一，它表示当前分组中，对象的数目（就不用调用<code>nrow</code>函数啦）。在<code>[]</code>使用它指提取最后一行。</p><pre tabindex=0><code>product_info[.N]
#&gt;     id   name  type  class released
#&gt; 1: M04 Dancer model people       no
product_info[c(1, .N)]
#&gt;     id   name  type   class released
#&gt; 1: T01 SupCar   toy vehicle      yes
#&gt; 2: M04 Dancer model  people       no
</code></pre><p>在对<code>data.table</code>构建子集时，能够自动根据语义计算表达式，因此可以直接使用列名，像<code>with()</code>和<code>subset()</code>那样。</p><p>比如：</p><pre tabindex=0><code>product_info[released == &#34;yes&#34;]
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle      yes
#&gt; 2: M01     JeepX model vehicle      yes
#&gt; 3: M02 AircraftX model vehicle      yes
#&gt; 4: M03    Runner model  people      yes
</code></pre><p>方括号内的第1个参数是行筛选器，第2个则对筛选后的数据进行适当的计算。</p><p>例如提取列：</p><pre tabindex=0><code>product_info[released == &#34;yes&#34;, id]
#&gt; [1] &#34;T01&#34; &#34;M01&#34; &#34;M02&#34; &#34;M03&#34;
</code></pre><p>在这里使用<code>"id"</code>结果不同，返回的必然是个data.table。</p><pre tabindex=0><code>product_info[released == &#34;yes&#34;, &#34;id&#34;]
#&gt;     id
#&gt; 1: T01
#&gt; 2: M01
#&gt; 3: M02
#&gt; 4: M03
</code></pre><p>第二个参数可以是表达式，例如生成一张表，反应每种<code>type</code>和<code>class</code>组合中<code>released</code>取<code>yes</code>的数量：</p><pre tabindex=0><code>product_info[released == &#34;yes&#34;, table(type, class)]
#&gt;        class
#&gt; type    people vehicle
#&gt;   model      1       2
#&gt;   toy        0       1
</code></pre><p><strong>要注意，给第2个参数提供list()，结果仍然转换为data.table</strong>：</p><pre tabindex=0><code>product_info[released == &#34;yes&#34;, list(id, name)]
#&gt;     id      name
#&gt; 1: T01    SupCar
#&gt; 2: M01     JeepX
#&gt; 3: M02 AircraftX
#&gt; 4: M03    Runner
</code></pre><p>我们可以替换原有列，生成新的data.table：</p><pre tabindex=0><code>product_info[, list(id, name, released = released == &#34;yes&#34;)]
#&gt;     id      name released
#&gt; 1: T01    SupCar     TRUE
#&gt; 2: T02  SupPlane    FALSE
#&gt; 3: M01     JeepX     TRUE
#&gt; 4: M02 AircraftX     TRUE
#&gt; 5: M03    Runner     TRUE
#&gt; 6: M04    Dancer    FALSE
</code></pre><p>还可以创建新列：</p><pre tabindex=0><code>product_stats[, list(id, material, size, weight, density = size/weight)]
#&gt;     id material size weight density
#&gt; 1: T01    Metal  120   10.0   12.00
#&gt; 2: T02    Metal  350   45.0    7.78
#&gt; 3: M01 Plastics   50     NA      NA
#&gt; 4: M02 Plastics   85    3.0   28.33
#&gt; 5: M03     Wood   15     NA      NA
#&gt; 6: M04     Wood   16    0.6   26.67
</code></pre><p><strong>为了简化，data.table使用.()作为list()的缩写，这两者等价</strong>：</p><pre tabindex=0><code>product_info[, .(id, name, type, class)]
#&gt;     id      name  type   class
#&gt; 1: T01    SupCar   toy vehicle
#&gt; 2: T02  SupPlane   toy vehicle
#&gt; 3: M01     JeepX model vehicle
#&gt; 4: M02 AircraftX model vehicle
#&gt; 5: M03    Runner model  people
#&gt; 6: M04    Dancer model  people

product_info[released == &#34;yes&#34;, .(id, name)]
#&gt;     id      name
#&gt; 1: T01    SupCar
#&gt; 2: M01     JeepX
#&gt; 3: M02 AircraftX
#&gt; 4: M03    Runner
</code></pre><p>提供排序索引可以对记录排序：</p><pre tabindex=0><code>product_stats[order(size, decreasing = TRUE)]
#&gt;     id material size weight
#&gt; 1: T02    Metal  350   45.0
#&gt; 2: T01    Metal  120   10.0
#&gt; 3: M02 Plastics   85    3.0
#&gt; 4: M01 Plastics   50     NA
#&gt; 5: M04     Wood   16    0.6
#&gt; 6: M03     Wood   15     NA
</code></pre><p><strong>前面都是在构建子集后，又创建新的data.table</strong>。这样挺麻烦的，因此<code>data.table</code>包提供了对列进行原地赋值的符号<code>:=</code>，例如<code>product_stats</code>开始是这样的：</p><pre tabindex=0><code>product_stats
#&gt;     id material size weight
#&gt; 1: T01    Metal  120   10.0
#&gt; 2: T02    Metal  350   45.0
#&gt; 3: M01 Plastics   50     NA
#&gt; 4: M02 Plastics   85    3.0
#&gt; 5: M03     Wood   15     NA
#&gt; 6: M04     Wood   16    0.6
</code></pre><p>使用<code>:=</code>直接在上面数据框创建新列：</p><pre tabindex=0><code>product_stats[, density := size / weight]
</code></pre><p>虽然没有任何返回，但数据已经被修改了：</p><pre tabindex=0><code>product_stats
#&gt;     id material size weight density
#&gt; 1: T01    Metal  120   10.0   12.00
#&gt; 2: T02    Metal  350   45.0    7.78
#&gt; 3: M01 Plastics   50     NA      NA
#&gt; 4: M02 Plastics   85    3.0   28.33
#&gt; 5: M03     Wood   15     NA      NA
#&gt; 6: M04     Wood   16    0.6   26.67
</code></pre><p>使用<code>:=</code>替换已有的列：</p><pre tabindex=0><code>product_info[, released := released == &#34;yes&#34;]
product_info
#&gt;     id      name  type   class released
#&gt; 1: T01    SupCar   toy vehicle     TRUE
#&gt; 2: T02  SupPlane   toy vehicle    FALSE
#&gt; 3: M01     JeepX model vehicle     TRUE
#&gt; 4: M02 AircraftX model vehicle     TRUE
#&gt; 5: M03    Runner model  people     TRUE
#&gt; 6: M04    Dancer model  people    FALSE
</code></pre><h3 id=使用键获取值>使用键获取值<a href=#使用键获取值 class=header-anchor arialabel=Anchor> #</a></h3><p><strong>索引支持</strong>是data.table另一个独特功能，即我们可以创建键（key），使用键获取记录及其高效。</p><p>例如，使用<code>setkey()</code>将<code>id</code>设置为<code>product_info</code>中的一个键：</p><p>同样的，函数无任何返回，但我们已经为原始数据设置了键，而且原来的数据看起来也没变化：</p><pre tabindex=0><code>product_info
#&gt;     id      name  type   class released
#&gt; 1: M01     JeepX model vehicle     TRUE
#&gt; 2: M02 AircraftX model vehicle     TRUE
#&gt; 3: M03    Runner model  people     TRUE
#&gt; 4: M04    Dancer model  people    FALSE
#&gt; 5: T01    SupCar   toy vehicle     TRUE
#&gt; 6: T02  SupPlane   toy vehicle    FALSE
</code></pre><p>但键已生成：</p><pre tabindex=0><code>key(product_info)
#&gt; [1] &#34;id&#34;
</code></pre><p>现在我们可以用它来获取数据了，比如提供一个id值：</p><pre tabindex=0><code>product_info[&#34;M01&#34;]
#&gt;     id  name  type   class released
#&gt; 1: M01 JeepX model vehicle     TRUE
</code></pre><p>也可以使用<code>setkeyv()</code>来设置键，但它只接受字符向量：</p><pre tabindex=0><code>setkeyv(product_stats, &#34;id&#34;)
</code></pre><p><strong>当key是一个动态变化的向量时，这个函数会非常好用</strong>。</p><pre tabindex=0><code>product_stats[&#34;M02&#34;]
#&gt;     id material size weight density
#&gt; 1: M02 Plastics   85      3    28.3
</code></pre><p>如果两个表格有相同的键，我们可以轻松把他们连接到一起：</p><pre tabindex=0><code>product_info[product_stats]
#&gt;     id      name  type   class released material size weight density
#&gt; 1: M01     JeepX model vehicle     TRUE Plastics   50     NA      NA
#&gt; 2: M02 AircraftX model vehicle     TRUE Plastics   85    3.0   28.33
#&gt; 3: M03    Runner model  people     TRUE     Wood   15     NA      NA
#&gt; 4: M04    Dancer model  people    FALSE     Wood   16    0.6   26.67
#&gt; 5: T01    SupCar   toy vehicle     TRUE    Metal  120   10.0   12.00
#&gt; 6: T02  SupPlane   toy vehicle    FALSE    Metal  350   45.0    7.78
</code></pre><p><strong>data.table的键可以不止一个</strong>。例如使用<code>id</code>和<code>date</code>定位<code>toy_tests</code>中的记录：</p><pre tabindex=0><code>setkey(toy_tests, id, date)
</code></pre><p>现在提供key中的两个元素就可以获取记录了</p><pre tabindex=0><code>toy_tests[.(&#34;T01&#34;, 20160201)]
#&gt;     id     date sample quality durability
#&gt; 1: T01 20160201    100       9          9
</code></pre><p>如果提供第一个元素，会返回匹配的多个值：</p><pre tabindex=0><code>toy_tests[&#34;T01&#34;]
#&gt;     id     date sample quality durability
#&gt; 1: T01 20160201    100       9          9
#&gt; 2: T01 20160302    150      10          9
#&gt; 3: T01 20160405    180       9         10
#&gt; 4: T01 20160502    140       9          9
</code></pre><p>key不能错序，因此不能单独提供第2个元素以及反序排列。</p><pre tabindex=0><code>toy_tests[20160201]
#&gt;      id date sample quality durability
#&gt; 1: &lt;NA&gt;   NA     NA      NA         NA

toy_tests[.(20160202,&#34;T01&#34;)]
#&gt; Error in bmerge(i, x, leftcols, rightcols, io, xo, roll, rollends, nomatch, : x.&#39;id&#39; is a character column being joined to i.&#39;V1&#39; which is type &#39;double&#39;. Character columns must join to factor or character columns.
</code></pre><h3 id=对数据进行分组汇总>对数据进行分组汇总<a href=#对数据进行分组汇总 class=header-anchor arialabel=Anchor> #</a></h3><p><code>by</code>是data.table中另一个重要参数（即方括号内的第3个参数），它可以将数据按照<code>by</code>值进行分组，并对分组计算第2个参数。</p><p>接下来，我们学习如何通过by以简便的方式实现数据的分组汇总。</p><p>最简单的用法是计算每组的记录条数：</p><pre tabindex=0><code>product_info[, .N, by = released]
#&gt;    released N
#&gt; 1:     TRUE 4
#&gt; 2:    FALSE 2
</code></pre><p>分组的变量可以不止一个，例如由<code>type</code>和<code>class</code>确定一个分组：</p><pre tabindex=0><code>product_info[, .N, by = .(type, class)]
#&gt;     type   class N
#&gt; 1: model vehicle 2
#&gt; 2: model  people 2
#&gt; 3:   toy vehicle 2
</code></pre><p>可以对每个分组进行统计计算，这里计算防水和非防水产品的质量得分均值：</p><pre tabindex=0><code>product_tests[, mean(quality, na.rm = TRUE), by = .(waterproof)]
#&gt;    waterproof    V1
#&gt; 1:         no 10.00
#&gt; 2:        yes  5.75
</code></pre><p>可以看到结果存储在V1列中，我们可以手动指定列名：</p><pre tabindex=0><code>product_tests[, .(mean_quality = mean(quality, na.rm = TRUE)), by = .(waterproof)]
#&gt;    waterproof mean_quality
#&gt; 1:         no        10.00
#&gt; 2:        yes         5.75
</code></pre><p>注意操作需要�放在<code>list</code>中进行（<code>.()</code>）。</p><p>我们可以将多个[]按顺序连接起来，形成工作流（类似管道<code>%>%</code>）。</p><p>下面的例子中，首先使用通用键id将product_info和product_tests连接起来，然后筛选已发布的产品，再按type和class进行分组，最后计算每组的quality和durability的均值。</p><pre tabindex=0><code>type_class_test0 = product_info[product_tests][released == TRUE,
                                               .(mean_quality = mean(quality, na.rm=TRUE),
                                                 mean_durability = mean(durability, na.rm=TRUE)),
                                               by = .(type, class)]

type_class_test0
#&gt;     type   class mean_quality mean_durability
#&gt; 1:   toy vehicle          NaN            10.0
#&gt; 2: model vehicle            6             4.5
#&gt; 3: model  people            5             NaN
</code></pre><p>在返回的data.table中，by所对应的组合中的值是唯一的，虽然实现了目标，但结果中没有设置键：</p><pre tabindex=0><code>key(type_class_test0)
#&gt; NULL
</code></pre><p><strong>这种情况下，我们可以使用keyby来确保结果的data.table自动将keyby对应的分组向量设置为键</strong>。一般data.table会保持原来的顺序返回，有时候我们想要设定排序，keyby也可以实现，所以是一举两得：</p><pre tabindex=0><code>type_class_test = product_info[product_tests][released == TRUE, 
                                              .(mean_quality = mean(quality, na.rm = TRUE),
                                                mean_durability = mean(durability, na.rm = TRUE)),
                                              keyby = .(type, class)]
type_class_test
#&gt;     type   class mean_quality mean_durability
#&gt; 1: model  people            5             NaN
#&gt; 2: model vehicle            6             4.5
#&gt; 3:   toy vehicle          NaN            10.0
key(type_class_test)
#&gt; [1] &#34;type&#34;  &#34;class&#34;
</code></pre><p>下面可以直接用键来获取值：</p><pre tabindex=0><code>type_class_test[.(&#34;model&#34;, &#34;vehicle&#34;), mean_quality]
#&gt; [1] 6
</code></pre><p><strong>对大数据集使用键进行搜索，能够比迭代使用逻辑比较快得多，因为键搜索利用了二进制搜索，而迭代在不必要的计算上浪费了时间</strong>。</p><p>下面举例说明，首先创建有1000万行的数据，其中一列是索引列id，其他两列是随机数：</p><pre tabindex=0><code>n = 10000000
test1 = data.frame(id = 1:n, x = rnorm(n), y = rnorm(n))
</code></pre><p>现在查找id为876543的行，看要花多少时间：</p><pre tabindex=0><code>system.time(row &lt;- test1[test1$id == 876543, ])
#&gt;  用户  系统  流逝 
#&gt; 0.132 0.018 0.150
</code></pre><p>作为对比，我们使用<code>data.table</code>来完成这个任务，使用<code>setDT()</code>将数据框转换为<code>data.table</code>，该函数可以原地转换，不需要复制，并可以设定键。</p><pre tabindex=0><code>setDT(test1, key = &#34;id&#34;)
class(test1)
#&gt; [1] &#34;data.table&#34; &#34;data.frame&#34;
</code></pre><p>现在我们搜索相同的元素：</p><pre tabindex=0><code>system.time(row &lt;- test1[.(876543)])
#&gt;  用户  系统  流逝 
#&gt; 0.001 0.000 0.000
</code></pre><p>结果一致，但data.table用的时间要少得多。</p><h3 id=重塑datatable>重塑data.table<a href=#重塑datatable class=header-anchor arialabel=Anchor> #</a></h3><p>data.table扩展包为data.table对象提供了更强更快得<code>dcast()</code>和<code>melt()</code>函数。</p><p>例如将toy_tests的每个产品质量得分按照年和月进行对齐</p><pre tabindex=0><code>toy_tests[, ym := substr(date, 1, 6)]
toy_quality = dcast(toy_tests, ym ~ id, value.var = &#34;quality&#34;)
toy_quality
#&gt;        ym T01 T02
#&gt; 1: 201602   9   7
#&gt; 2: 201603  10   8
#&gt; 3: 201604   9   9
#&gt; 4: 201605   9  10
</code></pre><p><code>data.table::dcast()</code>提供了更强大的多变量支持：</p><pre tabindex=0><code>toy_tests2 = data.table::dcast(toy_tests, ym ~ id, value.var = c(&#34;quality&#34;, &#34;durability&#34;))
toy_tests2
#&gt;        ym quality_T01 quality_T02 durability_T01 durability_T02
#&gt; 1: 201602           9           7              9              9
#&gt; 2: 201603          10           8              9              8
#&gt; 3: 201604           9           9             10              8
#&gt; 4: 201605           9          10              9              9
</code></pre><p>看到没，data.table可以自动将id值与质量分类连接起来。</p><p>此时<code>ym</code>是键：</p><pre tabindex=0><code>key(toy_tests2)
#&gt; [1] &#34;ym&#34;
</code></pre><p>我们可以利用它提取数据：</p><pre tabindex=0><code>toy_tests2[&#34;201602&#34;]
#&gt;        ym quality_T01 quality_T02 durability_T01 durability_T02
#&gt; 1: 201602           9           7              9              9
</code></pre><h3 id=使用原地设置函数>使用原地设置函数<a href=#使用原地设置函数 class=header-anchor arialabel=Anchor> #</a></h3><p>我们知道R存在复制修改机制，这在进行大数据计算时开销很大，<code>data.table</code>提供了一系列支持语义的<code>set</code>函数，它们可以原地修改data.table，因此避免不必要的复制。</p><p>仍以<code>product_stats</code>为例，我们可以使用<code>setDF()</code>函数不要任何复制就可以将data.table变成data.frame。</p><pre tabindex=0><code>product_stats
#&gt;     id material size weight density
#&gt; 1: M01 Plastics   50     NA      NA
#&gt; 2: M02 Plastics   85    3.0   28.33
#&gt; 3: M03     Wood   15     NA      NA
#&gt; 4: M04     Wood   16    0.6   26.67
#&gt; 5: T01    Metal  120   10.0   12.00
#&gt; 6: T02    Metal  350   45.0    7.78

setDF(product_stats)

class(product_stats)
#&gt; [1] &#34;data.frame&#34;
</code></pre><p><code>setDT()</code>可以将任意的data.frame转换为data.table，并设置键。</p><pre tabindex=0><code>setDT(product_stats, key = &#34;id&#34;)
class(product_stats)
#&gt; [1] &#34;data.table&#34; &#34;data.frame&#34;
</code></pre><p>使用<code>setnames()</code>可以对列重命名：</p><pre tabindex=0><code>setnames(product_stats, &#34;size&#34;, &#34;volume&#34;)

product_stats
#&gt;     id material volume weight density
#&gt; 1: M01 Plastics     50     NA      NA
#&gt; 2: M02 Plastics     85    3.0   28.33
#&gt; 3: M03     Wood     15     NA      NA
#&gt; 4: M04     Wood     16    0.6   26.67
#&gt; 5: T01    Metal    120   10.0   12.00
#&gt; 6: T02    Metal    350   45.0    7.78
</code></pre><p>如果给行添加索引，使用：</p><pre tabindex=0><code>product_stats[, i := .I]
product_stats
#&gt;     id material volume weight density i
#&gt; 1: M01 Plastics     50     NA      NA 1
#&gt; 2: M02 Plastics     85    3.0   28.33 2
#&gt; 3: M03     Wood     15     NA      NA 3
#&gt; 4: M04     Wood     16    0.6   26.67 4
#&gt; 5: T01    Metal    120   10.0   12.00 5
#&gt; 6: T02    Metal    350   45.0    7.78 6
</code></pre><p>为方便，索引一般在第1列，所以我们要修改列的顺序：</p><pre tabindex=0><code>setcolorder(product_stats, c(&#34;i&#34;, &#34;id&#34;, &#34;material&#34;, &#34;weight&#34;, &#34;volume&#34;, &#34;density&#34;))
product_stats
#&gt;    i  id material weight volume density
#&gt; 1: 1 M01 Plastics     NA     50      NA
#&gt; 2: 2 M02 Plastics    3.0     85   28.33
#&gt; 3: 3 M03     Wood     NA     15      NA
#&gt; 4: 4 M04     Wood    0.6     16   26.67
#&gt; 5: 5 T01    Metal   10.0    120   12.00
#&gt; 6: 6 T02    Metal   45.0    350    7.78
</code></pre><h3 id=datatable的动态作用域>data.table的动态作用域<a href=#datatable的动态作用域 class=header-anchor arialabel=Anchor> #</a></h3><p>我们不仅可以直接使用列，也可以提前定义注入<code>.N</code>、<code>.I</code>和<code>.SD</code>来指代数据中的重要部分。</p><p>为演示，我们先创建新的data.table，命名为<code>market_data</code>，其中date列是连续的。</p><pre tabindex=0><code>market_data = data.table(date = as.Date(&#34;2015-05-01&#34;) + 0:299)
head(market_data)
#&gt;          date
#&gt; 1: 2015-05-01
#&gt; 2: 2015-05-02
#&gt; 3: 2015-05-03
#&gt; 4: 2015-05-04
#&gt; 5: 2015-05-05
#&gt; 6: 2015-05-06
</code></pre><p>向调用函数一样，我们给data.table添加数据列：</p><pre tabindex=0><code>set.seed(123)

market_data[, `:=`(
    price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
    volume = rbinom(300, 5000, 0.8)
)]
</code></pre><p>注意这里的price和volumn都是服从正态分布的随机数：</p><pre tabindex=0><code>head(market_data)
#&gt;          date price volume
#&gt; 1: 2015-05-01  29.2   4021
#&gt; 2: 2015-05-02  28.9   4000
#&gt; 3: 2015-05-03  31.2   4033
#&gt; 4: 2015-05-04  31.3   4036
#&gt; 5: 2015-05-05  31.5   3995
#&gt; 6: 2015-05-06  34.3   3955
</code></pre><p>我们以图形的方式展示数据：</p><pre tabindex=0><code>plot(price ~ date, data = market_data,
     type = &#34;l&#34;,
     main = &#34;Market data&#34;)
</code></pre><p>数据准备好后，我们看看动态作用域如何让事情变得简单。</p><p>看下时间范围：</p><pre tabindex=0><code>market_data[, range(date)]
#&gt; [1] &#34;2015-05-01&#34; &#34;2016-02-24&#34;
</code></pre><p>将数据整合缩减为月度数据：</p><pre tabindex=0><code>monthly = market_data[,
                      .(open = price[[1]], high = max(price),
                        low = min(price), close = price[[.N]]),
                      keyby = .(year = year(date), month = month(date))]

head(monthly)
#&gt;    year month open high  low close
#&gt; 1: 2015     5 29.2 37.7 26.1  28.4
#&gt; 2: 2015     6 28.1 37.6 28.1  37.2
#&gt; 3: 2015     7 36.3 41.0 32.1  41.0
#&gt; 4: 2015     8 41.5 50.0 30.9  30.9
#&gt; 5: 2015     9 30.5 34.5 22.9  27.0
#&gt; 6: 2015    10 25.7 33.2 24.6  29.3
</code></pre><p>计算过程为：<strong>先根据by表达式将原始数据分割，分割后的每个部分都是原始数据的一个子集，并且原始数据和子集都是data.table。然后在每个子集data.table的语义中计算j表达式</strong>。</p><p>下面代码没有按组聚合数据，而是画了每年的价格图：</p><pre tabindex=0><code>oldpar = par(mfrow = c(1, 2))
market_data[, {
    plot(price ~ date, type = &#34;l&#34;,
         main = sprintf(&#34;Market data (%d)&#34;, year))
}, by = .(year = year(date))]
par(oldpar)
</code></pre><p>这里我们没有为<code>plot()</code>设定data参数，图像也成功绘制，这是因为该操作是在data.table的语义中进行的。</p><p>此外,j表达式还可以用于构建模型的代码，下面是一个批量拟合线性模型的例子。这里使用<code>diamonds</code>数据集。</p><pre tabindex=0><code>data(&#34;diamonds&#34;, package = &#34;ggplot2&#34;)

setDT(diamonds)
head(diamonds)
#&gt;    carat       cut color clarity depth table price    x    y    z
#&gt; 1:  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
#&gt; 2:  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
#&gt; 3:  0.23      Good     E     VS1  56.9    65   327 4.05 4.07 2.31
#&gt; 4:  0.29   Premium     I     VS2  62.4    58   334 4.20 4.23 2.63
#&gt; 5:  0.31      Good     J     SI2  63.3    58   335 4.34 4.35 2.75
#&gt; 6:  0.24 Very Good     J    VVS2  62.8    57   336 3.94 3.96 2.48
</code></pre><p>该数据集包含超过5万条钻石信息的记录，每条记录了钻石的10个属性，现在我们队cut列中的每种切割类型都你拟合一个线性回归模型，由此观察每种切割类型中carat与depth是如何反映log(price)的信息。</p><pre tabindex=0><code>diamonds[, {
    m = lm(log(price) ~ carat + depth)
    as.list(coef(m))
}, keyby = .(cut)]
#&gt;          cut (Intercept) carat    depth
#&gt; 1:      Fair        7.73  1.26 -0.01498
#&gt; 2:      Good        7.08  1.97 -0.01460
#&gt; 3: Very Good        6.29  2.09 -0.00289
#&gt; 4:   Premium        5.93  1.85  0.00594
#&gt; 5:     Ideal        8.50  2.13 -0.03808
</code></pre><p><strong>动态作用域允许我们组合使用data.table内部或外部预定义的符号</strong>。举例，我们定义一个函数，计算market_data中由用户定义的列的年度均值：</p><pre tabindex=0><code>average = function(column){
    market_data[, .(average = mean(.SD[[column]])),
                by = .(year = year(date))]
}
</code></pre><p>这里我们使用<code>.SD[[x]]</code>提取x列的值，这跟通过名字从列表中提取成分或元素相同。</p><p>下面计算每年的平均价格：</p><pre tabindex=0><code>average(&#34;price&#34;)
#&gt;    year average
#&gt; 1: 2015    32.3
#&gt; 2: 2016    32.4
</code></pre><p>每年平均数量：</p><pre tabindex=0><code>average(&#34;volume&#34;)
#&gt;    year average
#&gt; 1: 2015    4000
#&gt; 2: 2016    4003
</code></pre><p>我们可以利用此包专门的语法创造一个列数动态变化的组合，并且组合中的列是由动态变化的名称决定的。</p><p>这里我们假设添加额外的3列数据，每一列都是原始价格加了随机噪声生成的。不用重复调用<code>market_date[, price1 := ...]</code>，而是使用<code>market_data[, (columns) := list(...)]</code>来动态设定列，其中<code>columns</code>是一个包含列名的字符向量，<code>list(...)</code>是每个列对应的值：</p><pre tabindex=0><code>price_cols = paste0(&#34;price&#34;, 1:3)
market_data[, (price_cols) := lapply(1:3,
                                     function(i) round(price + rnorm(.N, 0, 5), 2))]
head(market_data)
#&gt;          date price volume price1 price2 price3
#&gt; 1: 2015-05-01  29.2   4021   30.6   27.4   33.2
#&gt; 2: 2015-05-02  28.9   4000   29.7   20.4   36.0
#&gt; 3: 2015-05-03  31.2   4033   34.3   26.9   27.2
#&gt; 4: 2015-05-04  31.3   4036   29.3   29.0   28.0
#&gt; 5: 2015-05-05  31.5   3995   36.0   32.1   34.8
#&gt; 6: 2015-05-06  34.3   3955   30.1   31.0   35.2
</code></pre><p>另一方面，如果表格有很多列，并且需要对它们的子集进行一些计算，也可以用类似的语法来解决。</p><p>举例，我们现在需要对每个价格列调用<code>na.locf()</code>以去掉缺失值，先获取所有的价格列：</p><pre tabindex=0><code>cols = colnames(market_data)

price_cols = cols[grep(&#34;^price&#34;, cols)]

price_cols
#&gt; [1] &#34;price&#34;  &#34;price1&#34; &#34;price2&#34; &#34;price3&#34;
</code></pre><p>然后我们用类似的语法，并添加一个参数<code>.SDcols = price_cols</code>，这是为了让<code>.SD</code>中的列只是我们想要的那些价格列。</p><pre tabindex=0><code>market_data[, (price_cols) := lapply(.SD, zoo::na.locf), .SDcols =  price_cols]

head(market_data)
#&gt;          date price volume price1 price2 price3
#&gt; 1: 2015-05-01  29.2   4021   30.6   27.4   33.2
#&gt; 2: 2015-05-02  28.9   4000   29.7   20.4   36.0
#&gt; 3: 2015-05-03  31.2   4033   34.3   26.9   27.2
#&gt; 4: 2015-05-04  31.3   4036   29.3   29.0   28.0
#&gt; 5: 2015-05-05  31.5   3995   36.0   32.1   34.8
#&gt; 6: 2015-05-06  34.3   3955   30.1   31.0   35.2
</code></pre><p style=color:#777>最后一次修改于 2020-05-05</p></div><a href=#top><i class="fa fa-chevron-up" style=font-size:30px;color:#000></i></a></main><footer class=footer><script src=https://utteranc.es/client.js repo=kongjianyang/kongjianyang.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><script type=text/javascript src=/js/math-code.js></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type=text/javascript src=/js/center-img.js></script><ul class=footer-links><li><a href=/cn/posts/index.xml type=application/rss+xml title="RSS feed">订阅</a></li><li><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank>版权
<i class="fa fa-cc" aria-hidden=true title="Attribution-NonCommercial-ShareAlike 4.0 International"></i></a></li></ul><div class=copyright-text>©
KJY
2018-2021</div></footer>
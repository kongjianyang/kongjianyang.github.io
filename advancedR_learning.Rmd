---
output: 
  html_document:
    self_contained: false
---


```{r}
library(tidyverse)
```

A functional is a function that takes a function as an input and returns a vector as output. 


```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
```

passed mean function to the randomise functipn, which equal

```{r}
mean(runif(1e3))
```


```{r}
library(purrr)

triple <- function(x) x * 3
map(1:3, triple) # map the list to triple function
```

map() defines a mapping from one vector to another. (“Map” also has the nice property of being short, which is useful for such a fundamental building block.)

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

```{r}
# vector produces a vector of the given length and mode.

vector("list", 3) # creat three list
```


```{r}
seq_along(1:3)
```


```{r}
simple_map(1:3, triple)
```

each column in mtcars is a list, so can pass value into map function

```{r}
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique) 
```


```{r}
pair <- function(x) c(x, x)
map_dbl(1:2, pair)
```
map function each call to .f must return a single value. If it does not, you’ll get an error:

to fix it:

```{r}
pair <- function(x) (x+x) 
map_dbl(1:2, pair)
```


besides, we also albe to switch back to map(), because map() can accept any type of output. 

```{r}
pair <- function(x) c(x, x)
map(1:2, pair)
```


Anonymous functions and shortcuts

```{r}
map_dbl(mtcars, function(x) length(unique(x)))

# equal to the shortcuts
map_dbl(mtcars, ~ length(unique(.x)))
```



```{r}
as_mapper(~ length(unique(.x)))
```

```{r}
x <- map(1:3, ~ runif(2))
str(x)
```



```{r}
as_mapper(~ runif(2))
```


```{r}
x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

x

# Select by name
map_dbl(x, "x")

# Or by both
map_dbl(x, list("y", 1))
```


```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```




```{r}
boostrap_summary <- function(x, f) {
  f(sample(x, replace = TRUE))
}

simple_map(mtcars, boostrap_summary, f = mean)
```




simple_map() has arguments x and f so you’ll have problems whenever the function you are calling has arguments x or f:



```{r}
simple_map <- function(.x, .f, ...) {
  out <- vector("list", length(.x))
  for (i in seq_along(.x)) {
    out[[i]] <- .f(.x[[i]], ...)
  }
  out
}
```




```{r}
boostrap_summary <- function(x, f) {
  f(sample(x, replace = TRUE))
}

simple_map(mtcars, boostrap_summary, f = mean)
```


```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)
```

```{r}
map_dbl(trims, ~ mean(x, trim = .x))

map_dbl(trims, function(trim) mean(x, trim = trim))

# trim: the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed. Values of trim outside that range are taken as the nearest endpoint.
```

```{r}
mean(x, trim = 0.1)

mean(0.1, x = x)
```

```{r}
by_cyl <- split(mtcars, mtcars$cyl)
by_cyl
```

```{r}
class(by_cyl)

by_cyl$`4`
```

modify(), which always returns the same type of output as the input:

```{r}
df <- data.frame(
  x = 1:3,
  y = 6:4
)

map(df, ~ .x * 2)

modify(df, ~ .x *2)
```


```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

```{r}
xs; ws
```

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```


```{r}
x <- map(1:6, ~ sample(1000, 10))
x

imap_chr(x, ~ paste0("The highest value of ", .y, " is ", max(.x)))
```


```{r}
params <- tibble::tribble(
  ~ n, ~ min, ~ max,
   1L,     0,     1,
   2L,    10,   100,
   3L,   100,  1000
)

params
```



```{r}
pmap(params, runif)
```


```{r}
runif(3, 100, 1000)
```


```{r}
x <- c(4, 3, 10)
reduce(x, `+`)

accumulate(x, `+`)
```



```{r}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```


```{r}
f1(1)
```



```{r}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```


```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

(i02(x = 1, y = 2, z = 3))
```


```{r}
j04 <- function() invisible(1)

j04()
```



```{r}
j04 <- function() 1

j04()
```



```{r}
(a <- 2)
```


```{r}
a <- b <- c <- d <- 2

a; b; c; d
```


```{r}
j05 <- function() {

  stop("I'm an error")

  return(10)

}

j05()
```


```{r}
j05 <- function() {

  return(10)

}

j05()
```

Replacement functions
Replacement functions act like they modify their arguments in place, and have the special name xxx<-.


```{r}
`second<-` <- function(x, value) {

  x[2] <- value

  x

}

```



```{r}
x <- 1:10

second(x) <- 5L

x
```


```{r}
second(x, 5)
```

```{r}
`modify<-` <- function(x, position, value) {

  x[position] <- value

  x

}

modify(x, 1) <- 10

x

modify(x, 2) <- 10

x
```


```{r}
x <- c(a = 1, b = 2, c = 3)

x

names(x)
```


```{r}
library(rlang) # Functions for Base Types and Core R and 'Tidyverse' Features
# A toolbox for working with base types, core R features like the condition system, and core 'Tidyverse' features like tidy evaluation.
```

The job of an environment is to associate, or bind, a set of names to a set of values.


```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)
```


```{r}
e1
```


```{r}
e1$d <- e1
e1
```

```{r}
env_print(e1)
```

```{r}
env_names(e1)
```



To compare environments, you need to use identical() and not ==. This is because == is a vectorised operator, and environments are not vectors.

```{r}
identical(global_env(), current_env())
```


```{r}
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)
```


```{r}
env_parent(e2b)

env_parent(e2a)
```

```{r}
env_parents(e2b, last = empty_env())
```


```{r}
x <- 0
f <- function() {
  x <<- 1
}
f()
x
```


```{r}
x <- 0
f <- function() {
  x <<- 1
}
# f() if not run this, x will still 0
x
```

can get and set elements of an environment with $ and [[ in the same way as a list:


```{r}
e3 <- env(x = 1, y = 2)
e3$x
```



```{r}
env_get(e3, "x")
```


env_poke()42 takes a name (as string) and a value:

env_bind() allows you to bind multiple values:

```{r}
env_poke(e3, "a", 100)
e3$a

env_bind(e3, a = 10, b = 20)
env_names(e3)

env_unbind(e3, "a")

env_has(e3, "a")
```






























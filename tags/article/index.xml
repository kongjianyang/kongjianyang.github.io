<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>article on KJY</title><link>https://kongjianyang.github.io/tags/article/</link><description>Recent content in article on KJY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 29 Mar 2022 14:32:27 -0500</lastBuildDate><atom:link href="https://kongjianyang.github.io/tags/article/index.xml" rel="self" type="application/rss+xml"/><item><title>R语言基于S3的面向对象编程</title><link>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</link><pubDate>Tue, 29 Mar 2022 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</guid><description>参考这篇文章：
R语言面向对象编程 (dataxujing.github.io) S3对象的介绍 在R语言中，基于S3对象的面向对象编程，是一种基于泛型函数的实现方式。泛型函数是一种特殊的函数，根据传入对象的类型决定调用那个具体的方法。基于S3对象实现面向对象编程，不同其他语言的面型对象编程，是一种动态函数调用的模拟实现。S3对象被广泛应用于R的早期的开发包中。
R的S3系统有三个组成部分:属性(attribute)(尤其是class属性)、泛型函数(genericfunction)和方法(method)
创建S3对象 注意：本文会用到pryr,为了方便我们检查对象的类型，引入pryr包作为辅助工具。
library(pryr) #通过变量创建S3对象 x &amp;lt;- 1 attr(x,&amp;#39;class&amp;#39;) &amp;lt;- &amp;#39;foo&amp;#39; x ## [1] 1 ## attr(,&amp;#34;class&amp;#34;) ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; #用pryr包的otype函数,检查x的类型 otype(x) ## [1] &amp;#34;S3&amp;#34; 通过structure()函数创建S3对象
y &amp;lt;- structure(2,class=&amp;#34;foo&amp;#34;) y ## [1] 2 ## attr(,&amp;#34;class&amp;#34;) ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;S3&amp;#34; 创建一个多类型的S3对象，S3独享没有明确结构关系，一个S3对象可以有多个类型，S3对象的class属性可以是一个向量，包括多种类型
x &amp;lt;- 1 attr(x,&amp;#34;class&amp;#34;) &amp;lt;- c(&amp;#34;foo&amp;#34;,&amp;#34;bar&amp;#34;) # 给了x对象两个class属性 class(x) ## [1] &amp;#34;foo&amp;#34; &amp;#34;bar&amp;#34; ## [1] &amp;#34;S3&amp;#34; 如果分配至少一个class属性，就是S3对象，如果没有class属性，就是base对象。</description></item><item><title>ChIPseeker使用介绍</title><link>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</link><pubDate>Sat, 26 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</guid><description>主要参考这篇文章：
190-学习一遍ChIPseeker使用 | BIOINFOPLANET (jieandze1314.com) 1 ChIP-seq简介 ChIP是指染色质免疫沉淀，它通特异结合抗体将DNA结合蛋白免疫沉淀，可以用于捕获蛋白质（如转录因子，组蛋白修饰）的DNA靶点。之前结合芯片就有ChIP-on-chip，后来二代测序加持诞生了ChIP-seq。优点是：不再需要设计探针（探针往往存在着一定的偏向性）
2007年来自三个不同的实验室，几乎是同时间出来（最长差不了3个月），分别发CNS，一起定义了这个ChIPseq技术
Johnson DS, Mortazavi A et al. (2007) Genome-wide mapping of in vivo protein–DNA interactions. Science 316: 1497–1502 Robertson G et al.(2007) Genome-wide profiles of STAT1 DNA association using chromatin immunoprecipitation and massively parallel sequencing. Nature Methods 4: 651–657 Schmid et al. (2007) ChIP-Seq Data reveal nucleosome architecture of human promoters. Cell 131: 831–832 主要有4步：Cross-linking、Sonication、IP、Sequencing
简而言之是：DNA和蛋白质交联(cross-linking)、超声(sonication)将染色体随机切割、利用抗原抗体的特异性识别(IP)、把目标蛋白相结合的DNA片段沉淀下来，反交联释放DNA片段，最后是测序(sequencing)
分析流程示例图1： 分析流程示例图2： 原始数据=》质控=》比对=》拿到DNA片段在染色体上的位置信息=》peak calling （去除背景噪音）=》拿到peaks（protein binding site）=》下游分析（可视化、找相关基因、motif分析等等）</description></item><item><title>tmux多窗口管理</title><link>https://kongjianyang.github.io/cn/2022/03/25/tmux/</link><pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/tmux/</guid><description>[TOC]
主要参考这篇文章：还在为 iTerm 多窗口操作烦恼？tmux 这款神器轻松帮你解决_Java极客技术-程序员信息网 - 程序员信息网 (i4k.xyz) Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com) 安装tmux
brew install tmux 会话管理 新建 session
使用 tmux 之前我们首先需要新建一个 Session，命令如下：
# 新建 session，使用 -s 自定义 session 名字 tmux new -s &amp;lt;session-name&amp;gt; 保存会话
进入会话之后，进行相关操作，比如使用 SSH 连上远端服务器。这时如果想退出去的时候，可以保存当前会话信息。下次可以直接重新进入这个会话，不用重新再次使用 SSH 连接了。
# 保存当前会话 tmux detach 接入会话
tmux attach 可以接入上次保存的会话。
# 可以使用 -t 指定会话名字。 tmux attach -t &amp;lt;session-name&amp;gt; 查看会话
如果之前同时保存了多个会话，我们可以使用 tmux ls 查看当前所有会话。
# 查看会话 tmux ls 杀死会话
使用 tmux kill-session 我们可以杀死某个会话。</description></item><item><title>个人周刊第一期</title><link>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</link><pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</guid><description>R语言 R语言面向对象编程 (dataxujing.github.io) S4对象系统具有明显的结构化特征，更适合面向对象的程序设计。Bioconductor社区以S4对象作为基础框架，只接受S4定义的R包。
生活 Honey - 自动帮你找 Coupons 的购物神器【08/02 更新：支持 PayPal 提现了】 - 北美羊毛快报 (usdailyrewards.com) Honey还能让您轻松获得产品的降价信息。在Amazon、Overstock、Target、Walmart、J.Crew、Saks Fifth Avenue、QVC、 Loft、 Kohl&amp;rsquo;s、Best Buy、 速卖通（AliExpress）网站购物时，您可以添加商品到您的Honey列表，并选择最佳心理价位和跟踪时长。当商品价格低于设定值时，您会收到降价提醒。</description></item><item><title>MACS2使用</title><link>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</link><pubDate>Fri, 25 Mar 2022 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</guid><description>参考资料：
这可能是最棒的MACS2使用说明 (360doc.com) 使用MACS2进行差异peak分析_生信修炼手册的博客-CSDN博客 MACS2作为使用最广泛的peak calling软件，在v2版本中添加了差异peak分析的功能，所有的子命令功能描述如下
通过bdgdiff子命令来进行差异peak分析， 该命令不需要基于已有的peak calling结果，只需要输入每个样本对应的bedGraph格式的文件。需要注意的是，该命令只针对两个样本间的差异peak进行设计，适用于没有生物学重复的情况。
对于使用macs2来进行差异peak的完整流程，官方给出了详细的说明文档，链接如下
https://github.com/taoliu/MACS/wiki/Call-differential-binding-events
可以分为以下3步
1. 预测插入片段长度 通过predictd子命令可以预测样本的fragment size，命令如下
macs2 predictd -i input.bam #!/bin/bash module load bioinfo module load biocontainers/default module load macs2/2.2.7.1-py39 for i in `ls [A-H][1-9][A-H][1-9][A-H][1-9].bam`; do msg=&amp;#34;macs2 predictd -i $i&amp;#34;; echo $msg; macs2 predictd -i $i; 2. peak calling 在peak calling时，需要添加-B参数，这样才可以输出样本对应的bedgraph文件，同时需要保证peak calling时采用一致的--extsize的值，就是第一步预测出来的数值，取多个样本的均值即可。官方也给出了推荐值，对于大多数的转录因子chip_seq数据，推荐值为200， 对于大部分组蛋白修饰的chip_seq数据，推荐值为147，命令如下
# condition1 macs2 callpeak -B -t cond1_ChIP.bam -c cond1_Control.bam -n cond1 --nomodel --extsize 147 # condition2 # broad peak calling: macs2 callpeak -B -t cond1_ChIP.</description></item><item><title>创建自己的newsletter信息</title><link>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</link><pubDate>Wed, 23 Mar 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</guid><description>记录使用GitHub创建自己的newsletter信息：
结构参考这篇仓库：ShixiangWang/weekly: 生信爱好者周刊（每周日发布） (github.com) [TOC]
1. 克隆并更新到自己的仓库 克隆别人的仓库到本地 git clone git@github.com:ShixiangWang/weekly.git 并在自己的github创建自己的仓库
删除原来git版本控制 进入project的根目录 中，右击鼠标打开Git Bash 输入 find . -name &amp;quot;.git&amp;quot; | xargs rm -Rf
初始化自己的仓库 $ touch README.md $ git init $ git add * $ git commit -m &amp;#34;此处可添加提交代码相关的注释&amp;#34; $ git remote add origin https://github.com/yourUserName/repositoryName.git $ git push -u origin master 123456 origin 是代码仓库地址的别称 git详细教程 .gitignore文件编写
该文件内容是不想提交到仓库的文件或文件夹。 忽略某个文件夹下面所有内容要带星号* pyqt5/build/* pyqt5/dist/* time_format/build/* time_format/dist/* time_format/img/*</description></item><item><title>使用GitHub page建立站点</title><link>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</link><pubDate>Sun, 20 Mar 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</guid><description>记录第一次使用GitHub page建立站点的步骤:
主要参考这篇文章：郝鸿涛：Hongtao Hao [TOC]
1. 安装Hugo 在 Terminal 中输入
brew install hugo 完成后，在 Terminal 中输入 hugo version, 如果显示 Hugo Static Site Generator... 证明安装成功。
2. 新建一个 Hugo 网站 Hugo 博客就是一个文件夹。首先你要确定把这个文件夹放在哪里。到达自己需要的地址之后使用以下命令
hugo new site liang.github.io **# quickstart 可以换成任何你想用的名称** cd quickstart/themes git clone https://github.com/hongtaoh/hugo-ht mkdir hugo-ht-new cp -r hugo-ht/* hugo-ht-new rm -rf hugo-ht mv hugo-ht-new hugo-ht cd .. cp -r themes/hugo-ht/exampleSite/* . 这是使用一个Hugo-ht为主题的网站，之后可以折腾其他主题。但是这样会你目前 Hugo 网站中的 Content 文件夹和 config.toml 替换为 Hugo-ht 自带的内容。如果你当前 Hugo 网站中的 Content 文件夹及config.</description></item><item><title>Markdown 试水</title><link>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</link><pubDate>Thu, 07 Jan 2021 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</guid><description>如果好奇以下的内容是如何实现的，请参考本页源代码 。
第一级标题 第二级标题 第三级标题 第四级标题 第五级标题 第六级标题 列表 Water Water Water Water Water Water Water Water Water Water Water Water 表格 Water Water Water Water Water Water Water Water1 Water Water Water Water 引语 知之为知之，不知为不知，是知也2。 — 孔子
数学公式 最简单的如，$1 + 1 = 3$</description></item><item><title>Markdown Testing</title><link>https://kongjianyang.github.io/en/2021/01/07/second-post/</link><pubDate>Thu, 07 Jan 2021 13:37:57 -0500</pubDate><guid>https://kongjianyang.github.io/en/2021/01/07/second-post/</guid><description>See the source code of this page if you are interested.
H1 H2 H3 H4 H5 H6 List Water Water Water Water Water Water Water Water Water Water Water Water Table Water Water Water Water Water Water Water Water1 Water Water Water Water Quotes What I cannot create, I do not understand2.</description></item><item><title>R中处理错误</title><link>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</link><pubDate>Fri, 07 Jun 2019 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</guid><description>方案一：使用try语句 使用方法
在R语言中，try语句的用法如下所示: try(expr, silent = FALSE, outFile = getOption(&amp;#34;try.outFile&amp;#34;, default = stderr())) 可以看到，try语句共有三个参数，常用的是前两个参数。第一个参数expr为我们所要使用的表达式，第二个参数silent表示当错误出现时是否需要报告错误信息，其输入值应为逻辑变量，默认为FALSE，即选择不保持“沉默”，当错误出现时会立即报告错误信息。
如果参数expr所代表的表达式可以正确运行，则try语句的输出即为该表达式的运行结果，如果表达式无法正确运行，则try语句会输出一个“try-error”类的不可见对象，因此可以通过if语句对try语句的输出结果进行判断从而进行下一步的处理。
如果大段代码中有错误，想忽略错误，可以采用try()，但大段代码需放在**{ }**中：
你可以捕获**try()的输出，如果程序运行成功，返回计算结果；如果程序运行不成功，则可以通过class()**函数返回，错误类型 &amp;rsquo;try-error&amp;rsquo;。
使用示例 A = list(a=1,b=&amp;#39;abc&amp;#39;,c=-2,d=3) # 运行log(&amp;#39;abc&amp;#39;)会报错，运行log(-2)会出现警告 B = list() for (nm in names(A)) { x &amp;lt;- A[[nm]] temp &amp;lt;- try(log(x),silent=FALSE) if(&amp;#39;try-error&amp;#39; %in% class(temp)) # 判断当前循环的try语句中的表达式是否运行正确 { temp &amp;lt;- NA # 此处可以对运行错误的情况进行处理应对 } B[[nm]] &amp;lt;- temp } 方案二：使用tryCatch语句 使用方法
相较于try语句，tryCatch语句更为全面，能够处理和应对更为复杂的问题。其不仅能够处理表达式出现错误error的情形，还能够处理出现警告warning的情况。主要用法如下所示： tryCatch( { expr }, warning = function(w) { warning-handler-code }, error = function(e) { error-handler-code }, finally = { cleanup-code } ) 可以看到，tryCatch语句的内部可以被划分为四个不同的部分。</description></item><item><title>vscode使用技巧</title><link>https://kongjianyang.github.io/cn/2019/03/14/vscode/</link><pubDate>Thu, 14 Mar 2019 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/03/14/vscode/</guid><description>VS code 的层级树太浅怎么解决，子目录的缩进不够深
通过修改workbench&amp;gt;Tree: indent的结构
一些详细介绍：
一、User Guide（用户指南）🔗 参考官方文档：Basic Editing in Visual Studio Code 更改显示语言🔗 通过安装插件 Chinese (Simplified) Language Pack for Visual Studio Code 来启用中文（需要重启）
默认情况下，Visual Studio Code 附带英语作为显示语言，而其他语言则依赖于 Marketplace 提供的语言包扩展。
VS Code 检测到操作系统的 UI 语言，并会提示您安装适当的语言包（如果在 Marketplace 上可用）。
保存/自动保存🔗 默认情况下，VS 代码需要一个明确的行动，将更改保存到磁盘，按Ctrl + S。
您也可以使用文件 &amp;gt; 自动保存从顶级菜单切换自动保存。
要进一步控制自动保存，请打开配置文件settings.json，然后找到相关的设置（如果没有则直接添加）：
它可以具有以下值：
off -禁用自动保存。
afterDelay - 在配置的延迟（默认 1000 毫秒）后保存文件。
onFocusChange - 当焦点移出脏文件的编辑器时保存文件。
onWindowChange - 当焦点移出 VS Code 窗口时保存文件。</description></item></channel></rss>
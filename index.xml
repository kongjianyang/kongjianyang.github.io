<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on KJY</title><link>https://kongjianyang.github.io/</link><description>Recent content in Home on KJY</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 Feb 2023 14:42:27 -0500</lastBuildDate><atom:link href="https://kongjianyang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>R语言编程补充</title><link>https://kongjianyang.github.io/cn/2023/02/07/advanced_r/</link><pubDate>Tue, 07 Feb 2023 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2023/02/07/advanced_r/</guid><description>R编程补充 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>Python机器学习</title><link>https://kongjianyang.github.io/cn/2022/12/23/python-ml/</link><pubDate>Fri, 23 Dec 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/12/23/python-ml/</guid><description>参考教程：
系列教程 (showmeai.tech) argparse模块在jupyter notebook中传参 在python代码文件中，通常需要传参，传参就需要经常使用argparse。使用argparse模块在py文件中是正常的，但是jupyter notebook就会报错。</description></item><item><title>MySQL简单学习</title><link>https://kongjianyang.github.io/cn/2022/12/13/mysql/</link><pubDate>Tue, 13 Dec 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/12/13/mysql/</guid><description/></item><item><title>在Docker内打开Jupiter-notebook</title><link>https://kongjianyang.github.io/cn/2022/12/06/%E5%9C%A8docker%E5%86%85%E6%89%93%E5%BC%80jupiter-notebook/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2022/12/06/%E5%9C%A8docker%E5%86%85%E6%89%93%E5%BC%80jupiter-notebook/</guid><description>参考教程：https://medium.com/codex/how-to-setup-jupyter-notebook-on-mac-b0c2e3c66e60
范例 There are many Jupyter images, depending on the variety of Python libraries installed and the additional setup of R and/or PySpark
use scipy-notebook, which contains most of the basic data science libraries that I need. It contains dask , pandas , numexpr , matplotlib , scipy , seaborn , scikit-learn , scikit-image , sympy , cython , patsy , statsmodel , cloudpickle , dill , numba , bokeh , sqlalchemy , hdf5 , vincent , beautifulsoup , protobuf , xlrd , bottleneck , and pytables packages.</description></item><item><title>R整洁代码</title><link>https://kongjianyang.github.io/cn/2022/12/05/rtidy/</link><pubDate>Mon, 05 Dec 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/12/05/rtidy/</guid><description>R整洁代码 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>利用Python进行文件重命名</title><link>https://kongjianyang.github.io/cn/2022/09/24/python/</link><pubDate>Sat, 24 Sep 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/09/24/python/</guid><description># !#/usr/bin/python3 import os import re import datetime dir = os.getcwd() files = os.listdir(&amp;#34;./&amp;#34;) # 判断字符串 oldStr = r&amp;#34;(\d{4}-\d{1,2}-\d{1,2}-)&amp;#34; newStr = &amp;#34;&amp;#34; #判断生成时间 now = datetime.datetime.now() deltaH = datetime.timedelta(days=360) d = os.walk(dir) for path,dirList,fileList in d: for fileName in fileList: oldFile = os.path.join(path, fileName) if re.findall(oldStr, fileName): f = datetime.datetime.fromtimestamp(os.path.getmtime(oldFile)) if f &amp;gt; (now-deltaH): print(oldFile) newName = re.sub(oldStr, newStr, fileName) newFile = os.</description></item><item><title>GSEA和GSVA分析</title><link>https://kongjianyang.github.io/cn/2022/06/28/gsea/</link><pubDate>Tue, 28 Jun 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/06/28/gsea/</guid><description>GSEA全称Gene Set Enrichment Analysis，GSVA全称Gene Set Variation Analysis，它们都是基于基因集开展的分析，因此我们先要了解基因集的定义。基因集顾名思义就是一些基因的集合，任何一些基因放在一起都可以叫做基因集，但是我们用来分析的基因集要求有一定的生物学意义。
MSigDB（Molecular Signatures Database）数据库中定义了已知的基因集合：http://software.broadinstitute.org/gsea/msigdb 包括H和C1-C7八个系列（Collection），每个系列分别是：
H:hallmark gene sets （癌症）特征基因集合，共50组，最常用； C1: positional gene sets 位置基因集合，根据染色体位置，共326个，用的很少； C2: curated gene sets：（专家）校验基因集合，基于通路、文献等： C3: motif gene sets：模式基因集合，主要包括microRNA和转录因子靶基因两部分 C4: computational gene sets：计算基因集合，通过挖掘癌症相关芯片数据定义的基因集合； C5: GO gene sets：Gene Ontology 基因本体论，包括BP（生物学过程biological process，细胞原件cellular component和分子功能molecular function三部分） C6: oncogenic signatures：癌症特征基因集合，大部分来源于NCBI GEO 发表芯片数据 C7: immunologic signatures: 免疫相关基因集合。
常规GO/KEGG富集分析需要设定阈值过滤差异基因，阈值太宽富集的结果太多，阈值太严又可能会遗漏一些关键结果。GO/KEGG富集的结果通常还很宽泛，并不能很好地解释生物学现象。有鉴于此，Broad研究所开发了基因集富集分析(GSEA)方法。GSEA使用无监督算法，不用过滤任何基因，配合MSigDB数据库使用，更容易找到解释生物学现象的基因集.
GSEA分析要先将样本做组间对比分析, 对比分析之后要按结果将基因排序，以差异倍数方法为例，把所有基因按差异倍数(FC)的值降序排列以供后续分析。
上图小人脚下的小方块代表排序好的差异基因列表，蓝色之外的其他色块代表属于某个基因集的基因，如黄色属于基因集A，绿色属于基因集B。最下面高低不等的竖条代表与基因列表对应的FC值，红色上调、蓝色下调、黄色没有变化。基因集的富集分析需要经历三步：
基因集A富集分析时，小人从基因列表的左端走到右端，每经过一个蓝色基因扣分，每遇到一个黄色基因加分，扣分时与FC无关，加分时考虑FC的权重。基因集A最终的富集分数(ES)是小人曾经得过的最高/低分，实际公式比这复杂，但基本理念如此。
采用置换检验(Permutation testing)计算基因集A的显著性，即p值。
基因集A富集分析完成后，按上述同样的方法完成基因集B、C直至所有输入基因集的分析。所有需要富集分析的基因集都计算ES和p值之后，将ES转换为标准富集分数(NES)，并计算校正后p值。
(1)背景基因排序：将全部基因按照某种指标（差异分析p值，表型相关性，表达量等）进行排序，比如log2FC排序。
(2)目标基因富集：将某个特定类型的基因在排序表中标出，目标基因可以是某个通路或GO terms的基因等。
(3)计算富集分数：使用加权法，计算ES值变化。对位于中部（与性状相关性低）的部分采用较小的权值，所以越集中在两端，与表型的相关性越高。ES曲线最大值为富集分数（Enrichment Score）。
(4)Permutation test：对基因集的ES值进行显著性检验及多重假设检验，从而计算出显著富集的基因集。
enrichmentScore：富集得分。ES 反映基因集中的基因（S）在排序列表基因（L）的两端富集的程度。计算方式是，从基因集 L 的第一个基因开始，计算一个累计统计值。当遇到一个落在 D 里面的基因，则增加统计值。遇到一个不在 S 里面的基因，则降低统计值。每一步统计值增加或减少的幅度与基因的表达变化程度（更严格的是与基因和表型的关联度，可能是 fold-change，也可能是 pearson corelation 值）是相关的（可以是线性相关，也可以是指数相关）。富集得分 ES 最后定义为最大的峰值。正值 ES 表示基因集在列表的顶部富集，负值 ES 表示基因集在列表的底部富集。</description></item><item><title>single cell RNA-seq分析入门</title><link>https://kongjianyang.github.io/cn/2022/06/03/single-cell-rna-seq%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</link><pubDate>Fri, 03 Jun 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/06/03/single-cell-rna-seq%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</guid><description>scRNA toturial
// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc :first-child");
var i, h, a;
for (i = 0; i 0) h.removeAttribute(a[0].name);
}
});
/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict"</description></item><item><title>One sample proportion test (单比率检验)</title><link>https://kongjianyang.github.io/cn/2022/05/28/one_sample_proportion/</link><pubDate>Sat, 28 May 2022 16:03:40 -0600</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/28/one_sample_proportion/</guid><description>One sample proportion test (单比率检验) // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document"</description></item><item><title>Single_cell_sequencing入门</title><link>https://kongjianyang.github.io/cn/2022/05/23/scrna/</link><pubDate>Mon, 23 May 2022 16:03:40 -0600</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/23/scrna/</guid><description>Reference:
https://broadinstitute.github.io/KrumlovSingleCellWorkshop2020/index.html https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#finding-differentially-expressed-features-cluster-biomarkers- https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html Background 单细胞RNA-seq能够独立地提供每个细胞的RNA表达谱，并鉴定异质细胞群中的稀有细胞。尽管肿瘤异质性可归因于累积突变，但即使是遗传上相同的细胞在相同环境下也可能表现出基因和蛋白表达水平的差异，从而导致耐药性的产生。单细胞RNA-seq就能够发现这些稀有个体。
单细胞RNA-seq的流程
当然，单细胞RNA-seq的开展绝非易事，需要用到一系列尖端技术。大家首先要高效分离单细胞，然后进行RNA提取、逆转录、文库制备和测序，最后再通过生物信息学软件进行数据分析。其中，第一步 – 单细胞分离就相当棘手。
单细胞分离 从异质性的细胞群体中分离单细胞，目前的选择有不少，新方法也在不断面世。选择分离方法时，您可能需要考虑它是高通量还是低通量，以及是盲选还是有偏向的选择（基于某个参数）。
一些高通量的技术，比如最常用的荧光激活细胞分选（FACS）和磁性激活细胞分选（MACS），可根据细胞的大小/形状或细胞表面标志物的表达进行有偏向的选择，而基于微流体和液滴的技术可实现细胞的无偏向分离。不过，需要注意的是，组织/细胞的解离过程可能会改变RNA的表达谱。
RNA-Seq方案 标准的文库制备方案适用于10-100 ng的DNA起始材料。然而，单个细胞平均只含有10 pg的总RNA。因此，RNA提取和文库制备的流程必须经过调整和优化，才能用于单细胞材料。
首先，需要裂解分离出的单细胞，以获得RNA。这个步骤可通过自动化设备完成。当然，细胞裂解和RNA纯化的操作可同时进行。
然后，大多数方案是通过polyA选择来富集mRNA，并利用经过修饰的oligo dT引物来进行逆转录。在逆转录的过程中，有些方案利用独特分子标识符（UMI）对单分子进行标记，这些是随机的六核苷酸，可以更精确地定量单细胞中mRNA分子的初始量。之后，通过体外转录或PCR扩增cDNA，然后将扩增好的cDNA文库用于文库制备和高通量测序。
PCR方法的优点在于能够产生全长cDNA。不过，对于不同片段（如GC含量较高），PCR的效率可能不同，导致文库的覆盖度不均匀。另一方面，体外转录产生的文库能够避免PCR的序列偏向，但有些序列的转录效率低，导致序列drop-out或不完整。
数据分析 由于每个单细胞都是独特的，不可能开展重复实验并评估噪音。因此，必须采取一些质量控制手段，以确保数据的可靠性。专家建议，向每个细胞裂解液中加入已知序列和数量的合成mRNA，如外源RNA对照联盟（ERCC）开发的加标RNA。这些RNA的读数将提供样本间差异的信息。
总的来说，单细胞水平的转录组分析可以揭示细胞群体中的细胞异质性，强调了个别细胞的与众不同。此外，同时分析多种分子（如DNA、RNA和蛋白质）的方法也不断被开发出来。这种更全面的单细胞组图有望进一步加深我们对生物学过程的了解，对未来的科研及临床研究大有裨益。
Data analysis In contrast to bulk RNA-seq, scRNA-seq provides quantitative measurements of the expression of every gene in a single cell.</description></item><item><title>Single_cell_sequencing入门</title><link>https://kongjianyang.github.io/cn/2022/05/23/scrna/</link><pubDate>Mon, 23 May 2022 16:03:40 -0600</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/23/scrna/</guid><description>Single_cell_sequencing入门 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>Linux下删除特定前缀名文件的快捷方式</title><link>https://kongjianyang.github.io/cn/2022/05/22/find_remove/</link><pubDate>Sun, 22 May 2022 10:43:55 -0600</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/22/find_remove/</guid><description>有时候folder下会有奇怪前缀名的文件，如下
./~$Varian_Intern3.pptx ./~$Varian_Interview_With_Director.pptx ./~$Varian_Intern2.pptx 通过正常rm是没有办法删除的，这时候可以使用find的功能进行删除
find . -name ~$\* -delete 这样就可以找到并且删除文件了</description></item><item><title>Python绘制地图热图</title><link>https://kongjianyang.github.io/cn/2022/05/21/map_heatmap/</link><pubDate>Sat, 21 May 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/21/map_heatmap/</guid><description>2022-05-21-Python绘制地图热图 pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight .hll { background-color: var(--jp-cell-editor-active-background) } .highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) } .highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */ .</description></item><item><title>为Mac系统添加QuickLook插件</title><link>https://kongjianyang.github.io/cn/2022/05/18/html/</link><pubDate>Wed, 18 May 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/18/html/</guid><description>安装命令：brew cask install 卸载命令：brew cask uninstall 软件包被安装的路径： /Users/用户名称/Library/QuickLook
QuickLook（快速预览）是 Mac OS X 中一项很好的功能。用户选择文件后，按下空格键即可快速预览。因为不用点击打开，还能使用方向键切换，从而节省了大量的时间。但对于开发者来说，系统内置的功能还不能完全满足需求。
需要拓展安装一些插件
最方便的方式是通过brew进行
查找所有插件
brew search quicklook ==&amp;gt; Formulae quickjs ==&amp;gt; Casks caskroom/cask/epubquicklook ipynb-quicklook caskroom/cask/gltfquicklook osirix-quicklook caskroom/cask/ipynb-quicklook quicklook-csv caskroom/cask/osirix-quicklook quicklook-json ✔ caskroom/cask/quicklook-csv quicklook-pat caskroom/cask/quicklook-json ✔ quicklook-pfm caskroom/cask/quicklook-pat quicklookapk caskroom/cask/quicklook-pfm quicklookase ✔ caskroom/cask/quicklookapk receiptquicklook caskroom/cask/quicklookase ✔ ttscoff-mmd-quicklook caskroom/cask/receiptquicklook webpquicklook ✔ caskroom/cask/ttscoff-mmd-quicklook quickbooks caskroom/cask/webpquicklook ✔ quickboot epubquicklook quickjson gltfquicklook quicknfo 安装一些插件
brew install --cask qlimagesize qlvideo qlmarkdown brew install --cask qlcolorcode quicklook-json qlstephen suspicious-package provisionql quicklook-csv brew install highlight luarocks # 相关的依赖包</description></item><item><title>Linux上的定时任务</title><link>https://kongjianyang.github.io/cn/2022/05/17/crontab/</link><pubDate>Tue, 17 May 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/17/crontab/</guid><description>介绍 我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表
我们常用的命令如下：
crontab [-u username]　//省略用户表表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作) 我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。
Each line of a crontab file represents a job, and looks like this:
# ┌───────────── minute (0 - 59) # │ ┌───────────── hour (0 - 23) # │ │ ┌───────────── day of the month (1 - 31) # │ │ │ ┌───────────── month (1 - 12) # │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday; # │ │ │ │ │ 7 is also Sunday on some systems) # │ │ │ │ │ # │ │ │ │ │ # * * * * * The syntax of each line expects a cron expression made of five fields which represent the time to execute the command, followed by a shell command to execute.</description></item><item><title>macOS上的神器</title><link>https://kongjianyang.github.io/cn/2022/05/17/good_tools/</link><pubDate>Tue, 17 May 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/17/good_tools/</guid><description>Alfred 有时候对于某一特定的App，你想要查看最近利用这个App打开的文档，比如想查看上一次用Preview浏览的文件，用QuickTime最近观看的视频等等。在Alfred中可以很方便的查询App最近的浏览文件。在Alfred输入框中输入某个App的名字，然后按下Right键打开关于这个App的操作列表，排在列表的第一个选项就是关于这个App最近的浏览记录“Recent Documents”，按下Enter键选择这个选项，就会在Alfred中呈现这个App最近打开的文件记录列表，你可以在其中选择想要的文件再次利用这个App打开。举个例子，比如我想要查看利用Preview最近的浏览记录，就可以在Alfred中输入“Preview”，然后按下Right键就能打开Preview的操作列表，选择排在第一位的Recent Documents选项，按下Enter键就能打开Preview最近的历史列表，可以选择需要的文档在Preview中打开，非常方便。
Right其实是control键
alfred搜索到文件后打开所在目录
按住 |Command| 键，再按回车 |Return| ，打开的就不是文件，而是其所在文件夹。</description></item><item><title>R语言purrr包详细介绍</title><link>https://kongjianyang.github.io/cn/2022/05/17/purrr/</link><pubDate>Tue, 17 May 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/17/purrr/</guid><description>R语言purrr包详细介绍 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言ggblanket美化ggplot的图</title><link>https://kongjianyang.github.io/cn/2022/05/15/ggblanket/</link><pubDate>Sun, 15 May 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/15/ggblanket/</guid><description>R语言ggblanket美化ggplot图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>其他源产生的html文件兼容hug</title><link>https://kongjianyang.github.io/cn/2022/05/07/html/</link><pubDate>Sat, 07 May 2022 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/07/html/</guid><description>迁移博客系统之后之前一些产生的html文件不能在hugo系统中显示了，例如从rmd或者jupyter生产的html文件，尝试之后发现问题是生产的html文件没有frontmatter，加上之后就能解决问题。
参考：[SOLVED] Using HTML for content pages instead of Markdown - support - HUGO (gohugo.io) 所以在html文件上加下如下内容就能使之显示。
+++ title = &amp;#34;R语言元编程&amp;#34; date = &amp;#34;2020-04-17T12:15:02-00:00&amp;#34; categories = &amp;#34;R&amp;#34; tags = &amp;#34;R&amp;#34; +++ &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：
--- title: Hello World date: 2013/7/13 20:46:25 --- 补充知识 仅仅使用 markdown 格式写完文章是不够的，还需要在 .md 文档前面声明文档的信息，告诉 Hugo 这篇文章的标题、写作时间，这个时候就需要用到 Hugo Front Matter Formats 元数据格式。
Front Matter一般放在文章的最顶部，Hugo支持三种书写格式，
TOML使用+++来包裹内容 YAML使用---来包裹内容 JSON使用{和}来包裹内容 可配置的内容见Hugo官方文档: front-matter 。
在使用hugo new来创建文章时，会查找archetypes下的内容并填充到文章内容，查找archetypes原型内容的顺序如下:</description></item><item><title>R语言stringr学习</title><link>https://kongjianyang.github.io/cn/2022/05/05/strigr/</link><pubDate>Thu, 05 May 2022 23:57:39 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/05/strigr/</guid><description>stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。
对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。
R语言中处理字符串主要有stringi和stringr两种，更加推荐使用stringr,因为stringi命令太多太复杂了&amp;hellip;
来自Hadley Wickham的评价
stringi provides tools to do anything we could ever want to do with strings, where stringr provides tools to do the most common 95% of operations. This allows stringr to be much simpler, and the cost of some flexibility. Additionally stringi is implemented in C using the ICU string library, so it&amp;rsquo;s very fast and very correct (it deals with unicode better than base R).</description></item><item><title>R语言必须掌握的包</title><link>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</link><pubDate>Wed, 04 May 2022 22:21:53 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</guid><description>这是网络上收集的内容，具有一些参考价值
qinwf/awesome-R: A curated list of awesome R packages, frameworks and software. (github.com) 但是对于我的日常来讲，会有以下一些包进行日常使用，可以常用常新
1. 数据导入 【精】readr：实现表格数据的快速导入。https://readr.tidyverse.org readxl：读取Microsoft Excel电子表格数据
dplyr：提供了一个访问常见数据库的接口
data.table：data.table包的fread()函数可以快速读取大数据集
rio：一站式导入/导出几乎所有格式数据（使用import()/export()函数）
2. 数据整理 【精】tidyr：用于整理表格数据的布局
【精】dplyr：用于将多个数据表连接成一个整齐的数据集
purrr：函数式编程工具，在做数据整理时非常有用。
3. 数据可视化 【精】ggplot2及其扩展：ggplot2包提供了一个强大的绘图系统，并实现了以下扩展
ggthemes：提供扩展的图形风格主题
【精】ggpubr: 生成杂志期刊等出版物的图形的包，是ggplot的一个补充。
ggrepel：用于避免图形标签重叠,美化ggplot；
cowplot：ggplot2拓展工具箱（多图合并、图层叠加、添加标签等）
【精】see：ggplot2拓展工具箱（更丰富更美观的主题配色方案）Model Visualisation Toolbox for easystats and ggplot2 • see 4. 数据转换 【精】dplyr：一个用于高效数据清理的R包。视频学习课程
magrittr：一个高效的管道操作工具包。
【精】pipeR: 比magrittr更好用的管道操作工具包 Introduction | pipeR Tutorial (renkun-ken.github.io) tibble：高效的显示表格数据的结构
【精】stringr：一个字符串处理工具集
data.table：用于快速处理大数据集
stringi：一个快速字符串处理工具</description></item><item><title>R语言必须掌握的包</title><link>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</link><pubDate>Wed, 04 May 2022 22:21:53 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</guid><description>这是网络上收集的内容，具有一些参考价值
qinwf/awesome-R: A curated list of awesome R packages, frameworks and software. (github.com) 但是对于我的日常来讲，会有以下一些包进行日常使用，可以常用常新
1. 数据导入 【精】readr：实现表格数据的快速导入。https://readr.tidyverse.org readxl：读取Microsoft Excel电子表格数据
dplyr：提供了一个访问常见数据库的接口
data.table：data.table包的fread()函数可以快速读取大数据集
rio：一站式导入/导出几乎所有格式数据（使用import()/export()函数）
2. 数据整理 【精】tidyr：用于整理表格数据的布局
【精】dplyr：用于将多个数据表连接成一个整齐的数据集
purrr：函数式编程工具，在做数据整理时非常有用。
3. 数据可视化 【精】ggplot2及其扩展：ggplot2包提供了一个强大的绘图系统，并实现了以下扩展
ggthemes：提供扩展的图形风格主题
【精】ggpubr: 生成杂志期刊等出版物的图形的包，是ggplot的一个补充。
ggrepel：用于避免图形标签重叠,美化ggplot；
cowplot：ggplot2拓展工具箱（多图合并、图层叠加、添加标签等）
【精】see：ggplot2拓展工具箱（更丰富更美观的主题配色方案）Model Visualisation Toolbox for easystats and ggplot2 • see 4. 数据转换 【精】dplyr：一个用于高效数据清理的R包。视频学习课程
magrittr：一个高效的管道操作工具包。
【精】pipeR: 比magrittr更好用的管道操作工具包 Introduction | pipeR Tutorial (renkun-ken.github.io) tibble：高效的显示表格数据的结构
【精】stringr：一个字符串处理工具集
data.table：用于快速处理大数据集
stringi：一个快速字符串处理工具</description></item><item><title>R语言查看函数源码并修改</title><link>https://kongjianyang.github.io/cn/2022/05/04/r_raw_code/</link><pubDate>Wed, 04 May 2022 21:25:49 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2022/05/04/r_raw_code/</guid><description>在R语言中可以检查各种包内的函数，如果有必要的话可以进行修改已满足自己的需要，接下来介绍几个方法查看函数源码。
直接键入函数(不加括号)，大部分函数源代码就可以直接显现出来。
用函数page()，不过，结果在另一个窗口显示,选择电脑上的程序打开
用函数edit(), 这个函数允许我们来修改函数，修改的函数可以直接用。函数edit()不仅可以修改包中的函数作为急用，也可以用来修改自己正在写的函数。并且这个命令查看的源码会有高亮显示，比较方便
对于计算方法不同的函数，要用methods()来定义具体的查看对象
methods()得出的类函数中带星号标注的源代码，用函数getAnywhere()
直接上CRAN 下载源代码包</description></item><item><title>Linux下打印带有空格的目录</title><link>https://kongjianyang.github.io/cn/2022/04/25/dirt_space/</link><pubDate>Mon, 25 Apr 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/04/25/dirt_space/</guid><description>有时候在macos下会有很多空格的目录文件需要处理，很麻烦，可以使用下面的命令自动处理带有空格的文件
alias cwd=&amp;#39;printf &amp;#34;%q\n&amp;#34; &amp;#34;$(pwd)&amp;#34; | tee &amp;gt;(pbcopy)&amp;#39; printf命令 printf 命令模仿 C 程序库（library）里的 printf() 程序。
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。
printf 命令的语法：
printf format-string [arguments...] 参数说明：
format-string: 为格式控制字符串 arguments: 为参数列表。 #!/bin/bash # author:菜鸟教程 # url:www.runoob.com printf &amp;#34;%-10s %-8s %-4s\n&amp;#34; 姓名 性别 体重kg printf &amp;#34;%-10s %-8s %-4.2f\n&amp;#34; 郭靖 男 66.1234 printf &amp;#34;%-10s %-8s %-4.2f\n&amp;#34; 杨过 男 48.6543 printf &amp;#34;%-10s %-8s %-4.</description></item><item><title>YAML语言介绍</title><link>https://kongjianyang.github.io/cn/2022/04/25/yaml/</link><pubDate>Mon, 25 Apr 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/04/25/yaml/</guid><description>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。
YAML 是一种数据序列化语言，通常用于编写配置文件。业界对 YAML 有不同的看法，有人会说 YAML 不过代表了另一种标记语言，另外一些人认为*&amp;ldquo;YAML ain’t markup language&amp;rdquo;（ &amp;ldquo;YAML 不是标记语言&amp;rdquo;）*，&amp;ldquo;YAML&amp;rdquo; 正是这句话的递归缩写，强调了 YAML 是用于数据而不是文档。
YAML 是一种流行的编程语言，因为它是人类可读的语言，易于理解。它还可以与其他编程语言结合使用。
YAML支持3种数据结构：
键值表，键值对的集合，包括映射，哈希，字典。 序列，为一组排列的值，包括数组，列表。 常量，为单个的不可再分隔的值，包括字符串，布尔值，整数，浮点数，Null，时间，日期 由于YAML是JSON的自然超集，所以我们每个YAML语法段，都可以用JSON进行表示。
YAML的基本语法规则如下。
大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。
YAML 支持的数据结构有三种。
对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 以下分别介绍这三种数据结构。
对象的一组键值对，使用冒号结构表示。
animal: pets 转为 JavaScript 如下。
{ animal: &amp;#39;pets&amp;#39; } Yaml 也允许另一种写法，将所有键值对写成一个行内对象。
hash: { name: Steve, foo: bar } 转为 JavaScript 如下。</description></item><item><title>R语言基于S4的面向对象编程</title><link>https://kongjianyang.github.io/cn/2022/03/31/s4/</link><pubDate>Thu, 31 Mar 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/31/s4/</guid><description>参考资料：
R 学习笔记: S4 编程基础 - 知乎 (zhihu.com) 不同的语言进行面向对象编程中, 有许多东西是共同的. 就像浩巍说的, 编程就是一通百通. 如果了解 Python 的面向对象编程, 里面的很多思想也能使用在 R 语言面向对象编程中.
类 (class) 是面向对象编程的基础. 类就像是一个包装的盒子, 把对象的所有的属性都包含在其中. 可以形象地说, 类有点像一个有多种口味可供选择的冰激凌机器. 变量 (variable) 是描述对象的具体特征的数据, 是类的属性, 可以是数字或者字符等各种类型, 在 R 语言的 S4 类中被称为存储槽 (slot). 不同的变量, 就是冰激凌机器中的不同口味的冰激凌. 方法 (method) 是作用于类对象的各种操作, 也是类的属性, 具体实现就是各种方程. 方法也对应于冰激凌机器上产出不同口味冰激凌的不同的按钮. 对于不同的类可以有相似的方法, 例如对不同的类都可以有 print 函数来输出类的内容. 需要注意的是, 在 R 语言的 S4 类中, 类的方法本身不属于类本身, 而是独立的方程, 这点和 Python 等语言面向对象编程有差别. 但是, 在 R 语言的 RC 类 (Reference Class) 中方法本身则属于类. 面向对象编程有三个重要特点: 封装, 继承和多态性.</description></item><item><title>R语言数据导入rio包</title><link>https://kongjianyang.github.io/cn/2022/03/30/rio/</link><pubDate>Wed, 30 Mar 2022 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/30/rio/</guid><description>rio: A Swiss-Army Knife for Data I/O
CRAN - Package rio (r-project.org) 笔记说明 在读《Modern R with the tidyverse》 一书时发现了这个非常好用的R包，做此笔记记录。本笔记记录rio包的数据导入功能。导出功能说明见：用rio包进行数据导出 数据导入 Hadley Wickham在《R for Data Science》中总结的探索性数据分析的分析流程
数据导入是数据分析的第一步。实际工作中数据的来源和原始数据文件的格式多种多样。对应不同的原始文件来源或格式就有很多不同的读取数据的R包。学习、使用起来非常麻烦。在rio包之前，为了满足数据导入需要，大概需要学习的R包和其对应的数据文件类型如下：
readr包 - text files（如csv, tsv, fwf文件） haven包 - SPSS, Stata, and SAS files readxl包 - excel files DBI包 - databases jsonlite包 - json xml2包 - XML httr包 - Web APIs rvest包 - HTML (Web Scraping) rio包及其数据导入功能 rio包封装了很多数据导入和导出的包，并将不同包的数据导入导出操作统一到两个函数上：import()和export()，通过文件的后缀名来判断文件类型。这使得在R中进行数据的导入导出操作变得非常简单。有关rio包的更多信息可以参见：https://cran.r-project.org/web/packages/rio/vignettes/rio.html 下面对rio包的一些数据导入功能进行展示（基本参照《Modern R with the tidyverse》中对应的内容，所使用的数据可以在https://github.com/b-rodrigues/modern_R/tree/master/datasets 下载）：</description></item><item><title>R语言基于S3的面向对象编程</title><link>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</link><pubDate>Tue, 29 Mar 2022 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</guid><description>参考这篇文章：
R语言面向对象编程 (dataxujing.github.io) S3对象的介绍 在R语言中，基于S3对象的面向对象编程，是一种基于泛型函数的实现方式。泛型函数是一种特殊的函数，根据传入对象的类型决定调用那个具体的方法。基于S3对象实现面向对象编程，不同其他语言的面型对象编程，是一种动态函数调用的模拟实现。S3对象被广泛应用于R的早期的开发包中。
R的S3系统有三个组成部分:属性(attribute)(尤其是class属性)、泛型函数(genericfunction)和方法(method)
创建S3对象 注意：本文会用到pryr,为了方便我们检查对象的类型，引入pryr包作为辅助工具。
library(pryr) #通过变量创建S3对象 x &amp;lt;- 1 attr(x,&amp;#39;class&amp;#39;) &amp;lt;- &amp;#39;foo&amp;#39; x ## [1] 1 ## attr(,&amp;#34;class&amp;#34;) ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; #用pryr包的otype函数,检查x的类型 otype(x) ## [1] &amp;#34;S3&amp;#34; 通过structure()函数创建S3对象
y &amp;lt;- structure(2,class=&amp;#34;foo&amp;#34;) y ## [1] 2 ## attr(,&amp;#34;class&amp;#34;) ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;foo&amp;#34; ## [1] &amp;#34;S3&amp;#34; 创建一个多类型的S3对象，S3独享没有明确结构关系，一个S3对象可以有多个类型，S3对象的class属性可以是一个向量，包括多种类型
x &amp;lt;- 1 attr(x,&amp;#34;class&amp;#34;) &amp;lt;- c(&amp;#34;foo&amp;#34;,&amp;#34;bar&amp;#34;) # 给了x对象两个class属性 class(x) ## [1] &amp;#34;foo&amp;#34; &amp;#34;bar&amp;#34; ## [1] &amp;#34;S3&amp;#34; 如果分配至少一个class属性，就是S3对象，如果没有class属性，就是base对象。</description></item><item><title>ChIPseeker使用介绍</title><link>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</link><pubDate>Sat, 26 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</guid><description>主要参考这篇文章：
190-学习一遍ChIPseeker使用 | BIOINFOPLANET (jieandze1314.com) 1 ChIP-seq简介 ChIP是指染色质免疫沉淀，它通特异结合抗体将DNA结合蛋白免疫沉淀，可以用于捕获蛋白质（如转录因子，组蛋白修饰）的DNA靶点。之前结合芯片就有ChIP-on-chip，后来二代测序加持诞生了ChIP-seq。优点是：不再需要设计探针（探针往往存在着一定的偏向性）
2007年来自三个不同的实验室，几乎是同时间出来（最长差不了3个月），分别发CNS，一起定义了这个ChIPseq技术
Johnson DS, Mortazavi A et al. (2007) Genome-wide mapping of in vivo protein–DNA interactions. Science 316: 1497–1502 Robertson G et al.(2007) Genome-wide profiles of STAT1 DNA association using chromatin immunoprecipitation and massively parallel sequencing. Nature Methods 4: 651–657 Schmid et al. (2007) ChIP-Seq Data reveal nucleosome architecture of human promoters. Cell 131: 831–832 主要有4步：Cross-linking、Sonication、IP、Sequencing
简而言之是：DNA和蛋白质交联(cross-linking)、超声(sonication)将染色体随机切割、利用抗原抗体的特异性识别(IP)、把目标蛋白相结合的DNA片段沉淀下来，反交联释放DNA片段，最后是测序(sequencing)
分析流程示例图1： 分析流程示例图2： 原始数据=》质控=》比对=》拿到DNA片段在染色体上的位置信息=》peak calling （去除背景噪音）=》拿到peaks（protein binding site）=》下游分析（可视化、找相关基因、motif分析等等）</description></item><item><title>tmux多窗口管理</title><link>https://kongjianyang.github.io/cn/2022/03/25/tmux/</link><pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/tmux/</guid><description>[TOC]
主要参考这篇文章：还在为 iTerm 多窗口操作烦恼？tmux 这款神器轻松帮你解决_Java极客技术-程序员信息网 - 程序员信息网 (i4k.xyz) Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com) 安装tmux
brew install tmux 会话管理 新建 session
使用 tmux 之前我们首先需要新建一个 Session，命令如下：
# 新建 session，使用 -s 自定义 session 名字 tmux new -s &amp;lt;session-name&amp;gt; 保存会话
进入会话之后，进行相关操作，比如使用 SSH 连上远端服务器。这时如果想退出去的时候，可以保存当前会话信息。下次可以直接重新进入这个会话，不用重新再次使用 SSH 连接了。
# 保存当前会话 tmux detach 接入会话
tmux attach 可以接入上次保存的会话。
# 可以使用 -t 指定会话名字。 tmux attach -t &amp;lt;session-name&amp;gt; 查看会话
如果之前同时保存了多个会话，我们可以使用 tmux ls 查看当前所有会话。
# 查看会话 tmux ls 杀死会话
使用 tmux kill-session 我们可以杀死某个会话。</description></item><item><title>个人周刊第一期</title><link>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</link><pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</guid><description>R语言面向对象编程 (dataxujing.github.io) S4对象系统具有明显的结构化特征，更适合面向对象的程序设计。Bioconductor社区以S4对象作为基础框架，只接受S4定义的R包。
Modern R with the tidyverse (b-rodrigues.github.io) This book is the result of years of using and teaching R at university and then at my jobs. During my university time, I wrote some notes to help me teach R and which I shared with my students. These are still the basis of Chapter 2. Then, once I had left university, and continued using R at my first “real” job, I wrote another book that dealt mostly with package development and functional programming.</description></item><item><title>MACS2使用</title><link>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</link><pubDate>Fri, 25 Mar 2022 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</guid><description>参考资料：
这可能是最棒的MACS2使用说明 (360doc.com) 使用MACS2进行差异peak分析_生信修炼手册的博客-CSDN博客 MACS2：Model-based analysis of ChiP-Seq. 最初的设计是用来鉴定转录因子的结合位点，但是它也可以用于其他类型的富集方式测序。
MACS2作为使用最广泛的peak calling软件，在v2版本中添加了差异peak分析的功能，所有的子命令功能描述如下
通过bdgdiff子命令来进行差异peak分析， 该命令不需要基于已有的peak calling结果，只需要输入每个样本对应的bedGraph格式的文件。需要注意的是，该命令只针对两个样本间的差异peak进行设计，适用于没有生物学重复的情况。
对于使用macs2来进行差异peak的完整流程，官方给出了详细的说明文档，链接如下
https://github.com/taoliu/MACS/wiki/Call-differential-binding-events 可以分为以下3步
1. 预测插入片段长度 通过predictd子命令可以预测样本的fragment size，命令如下
macs2 predictd -i input.bam #!/bin/bash module load bioinfo module load biocontainers/default module load macs2/2.2.7.1-py39 for i in `ls [A-H][1-9][A-H][1-9][A-H][1-9].bam`; do msg=&amp;#34;macs2 predictd -i $i&amp;#34;; echo $msg; macs2 predictd -i $i; 2. peak calling 在peak calling时，需要添加-B参数，这样才可以输出样本对应的bedgraph文件，同时需要保证peak calling时采用一致的--extsize的值，就是第一步预测出来的数值，取多个样本的均值即可。官方也给出了推荐值，对于大多数的转录因子chip_seq数据，推荐值为200， 对于大部分组蛋白修饰的chip_seq数据，推荐值为147，命令如下
# condition1 macs2 callpeak -B -t cond1_ChIP.bam -c cond1_Control.bam -n cond1 --nomodel --extsize 147 # condition2 # broad peak calling: macs2 callpeak -B -t cond1_ChIP.</description></item><item><title>创建自己的newsletter信息</title><link>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</link><pubDate>Wed, 23 Mar 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</guid><description>记录使用GitHub创建自己的newsletter信息：
结构参考这篇仓库：ShixiangWang/weekly: 生信爱好者周刊（每周日发布） (github.com) [TOC]
1. 克隆并更新到自己的仓库 克隆别人的仓库到本地 git clone git@github.com:ShixiangWang/weekly.git 并在自己的github创建自己的仓库
删除原来git版本控制 进入project的根目录 中，右击鼠标打开Git Bash 输入 find . -name &amp;quot;.git&amp;quot; | xargs rm -Rf
初始化自己的仓库 $ touch README.md $ git init $ git add * $ git commit -m &amp;#34;此处可添加提交代码相关的注释&amp;#34; $ git remote add origin https://github.com/yourUserName/repositoryName.git $ git push -u origin master 123456 origin 是代码仓库地址的别称 git详细教程 .gitignore文件编写
该文件内容是不想提交到仓库的文件或文件夹。 忽略某个文件夹下面所有内容要带星号* pyqt5/build/* pyqt5/dist/* time_format/build/* time_format/dist/* time_format/img/*</description></item><item><title>使用GitHub page建立站点</title><link>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</link><pubDate>Sun, 20 Mar 2022 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</guid><description>记录第一次使用GitHub page建立站点的步骤:
主要参考这篇文章：郝鸿涛：Hongtao Hao [TOC]
1. 安装Hugo 在 Terminal 中输入
brew install hugo 完成后，在 Terminal 中输入 hugo version, 如果显示 Hugo Static Site Generator... 证明安装成功。
2. 新建一个 Hugo 网站 Hugo 博客就是一个文件夹。首先你要确定把这个文件夹放在哪里。到达自己需要的地址之后使用以下命令
hugo new site liang.github.io **# quickstart 可以换成任何你想用的名称** cd quickstart/themes git clone https://github.com/hongtaoh/hugo-ht mkdir hugo-ht-new cp -r hugo-ht/* hugo-ht-new rm -rf hugo-ht mv hugo-ht-new hugo-ht cd .. cp -r themes/hugo-ht/exampleSite/* . 这是使用一个Hugo-ht为主题的网站，之后可以折腾其他主题。但是这样会你目前 Hugo 网站中的 Content 文件夹和 config.toml 替换为 Hugo-ht 自带的内容。如果你当前 Hugo 网站中的 Content 文件夹及config.</description></item><item><title>GSEA富集分析</title><link>https://kongjianyang.github.io/cn/2021/08/13/gsea/</link><pubDate>Fri, 13 Aug 2021 16:03:40 -0600</pubDate><guid>https://kongjianyang.github.io/cn/2021/08/13/gsea/</guid><description>GSEA富集分析 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言中的多元方差分析【MANOVA】</title><link>https://kongjianyang.github.io/cn/2021/06/17/manova/</link><pubDate>Thu, 17 Jun 2021 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/06/17/manova/</guid><description>R语言中的多元方差分析【MANOVA】 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言anova进阶</title><link>https://kongjianyang.github.io/cn/2021/05/17/anova_advance/</link><pubDate>Mon, 17 May 2021 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/05/17/anova_advance/</guid><description>R语言anova进阶 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言glue包介绍</title><link>https://kongjianyang.github.io/cn/2021/04/22/glue/</link><pubDate>Thu, 22 Apr 2021 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/04/22/glue/</guid><description>glue 提供了轻巧、快速和无依赖的可解释字符串，glue 通过将 R 表达式嵌入到花括号中，然后对其求值并将其插入字符串中。
glue包可用于自定义变量，然后通过传参的方式，对字符串部分内容进行自适应修改。
例如：可将日期赋值为：date = as.Date(&amp;ldquo;2019-12-05&amp;rdquo;)，然后通过字符串拼接的形式，实现文件名称自动更新，glue(&amp;ldquo;The day is {date}.&amp;quot;。
安装 install.packages(&amp;#34;glue&amp;#34;) # or install.packages(&amp;#34;glue&amp;#34;) # install.packages(&amp;#34;devtools&amp;#34;) devtools::install_github(&amp;#34;tidyverse/glue&amp;#34;) 使用 1. 导入 2. 简单使用 将变量直接传递到字符串中
&amp;gt; name &amp;lt;- &amp;#34;Fred&amp;#34; &amp;gt; glue(&amp;#39;My name is {name}.&amp;#39;) My name is Fred. 通过将变量名放置在一对花括号之间，glue 会将变量名替换为相应的值
字符串可以写成多行的形式，最后会自动将这些行连接起来
&amp;gt; name &amp;lt;- &amp;#34;Fred&amp;#34; &amp;gt; age &amp;lt;- 50 &amp;gt; anniversary &amp;lt;- as.Date(&amp;#34;1991-10-12&amp;#34;) &amp;gt; glue(&amp;#39;My name is {name},&amp;#39;, + &amp;#39; my age next year is {age + 1},&amp;#39;, + &amp;#39; my anniversary is {format(anniversary, &amp;#34;%A, %B %d, %Y&amp;#34;)}.</description></item><item><title>R语言str_replace多匹配</title><link>https://kongjianyang.github.io/cn/2021/03/26/str_replace/</link><pubDate>Fri, 26 Mar 2021 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/03/26/str_replace/</guid><description>主要参考这个回答：r - stringr str_replace on multiple patterns and replacements? - Stack Overflow library(stringr) library(purrr) reduce2(c(&amp;#39;b&amp;#39;, &amp;#39;d&amp;#39;), c(&amp;#39;B&amp;#39;, &amp;#39;D&amp;#39;), .init = &amp;#39;abcdef&amp;#39;, str_replace) #[1] &amp;#34;aBcDef&amp;#34; 这种方法在大批量替换rowname的时候很有用，所以解析一下。
在purrr包中
map表示映射，可以在一个或多个列表/向量的每个位置上应用相同函数进行计算。map函数的映射对象只有一个。
map(.x, .f, …) .x: 列表或向量； .f: 映射函数； ...: 映射函数的其他参数
map2函数是map函数的变形，映射对象有两个，需要注意两个列表/向量的长度必须相同。
map2(.x,.y, .f, …) .x: 列表或向量； .y: 列表或向量,与.x等长； .f: 映射函数； ...: 映射函数的其他参数
pmap函数是map函数的变形，映射对象为多个，需要注意多个列表/向量的长度必须相同。
pmap(.l, .f, …) .l: 列表向量/列表； .f: 映射函数； ...: 映射函数的其他参数
reduce函数表示规约，计算向量中相邻的两个元素，结果再与第三个元素计算，…，最后计算出一个值。 reduce(.x, .f, …) .x: 列表向量/列表； .</description></item><item><title>Markdown 试水</title><link>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</link><pubDate>Thu, 07 Jan 2021 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</guid><description>第一级标题 第二级标题 第三级标题 第四级标题 第五级标题 第六级标题 列表 Water Water Water Water Water Water Water Water Water Water Water Water 表格 Water Water Water Water Water Water Water Water[^1] Water Water Water Water 引语 知之为知之，不知为不知，是知也[^2]。 — 孔子
数学公式 最简单的如，$1 + 1 = 3$
你可以加入索引:</description></item><item><title>Markdown 试水</title><link>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</link><pubDate>Thu, 07 Jan 2021 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</guid><description/></item><item><title>Markdown Testing</title><link>https://kongjianyang.github.io/en/2021/01/07/second-post/</link><pubDate>Thu, 07 Jan 2021 13:37:57 -0500</pubDate><guid>https://kongjianyang.github.io/en/2021/01/07/second-post/</guid><description>See the source code of this page if you are interested.
H1 H2 H3 H4 H5 H6 List Water Water Water Water Water Water Water Water Water Water Water Water Table Water Water Water Water Water Water Water Water1 Water Water Water Water Quotes What I cannot create, I do not understand2.</description></item><item><title>R语言使用dplyr编程【练习】</title><link>https://kongjianyang.github.io/cn/2020/12/14/dplyr/</link><pubDate>Mon, 14 Dec 2020 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2020/12/14/dplyr/</guid><description>R语言使用dplyr编程【练习】 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>Python给包含数字的字符串排序</title><link>https://kongjianyang.github.io/cn/2020/09/12/python%E7%BB%99%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 12 Sep 2020 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2020/09/12/python%E7%BB%99%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</guid><description>2020-09-12-Python给包含数字的字符串排序 pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight .hll { background-color: var(--jp-cell-editor-active-background) } .highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) } .highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */ .</description></item><item><title>R语言data.table学习</title><link>https://kongjianyang.github.io/cn/2020/05/05/data.table/</link><pubDate>Tue, 05 May 2020 23:57:39 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2020/05/05/data.table/</guid><description>关于data.table和pandas之间的比较：A data.table and pandas small stroll · Home (atrebas.github.io) 关于data.table和dplyr之间的比较：A data.table and dplyr tour · Home (atrebas.github.io) 介绍 data.frame是R内置的、默认的数据框类型（即一个具有行和列的数据表）。从外部导入的数据一般都以data.frame数据框格式在R里面进行处理和分析。
data.table作为一种高级数据类型，首先继承了data.frame基础数据类型，其官方文档 已经明确说明“data.table是data.frame的扩展（extension）”。
data.table具备很多独特而出色的性质，与其他数据类型（如data.frame、tibble/tbl_df）相比具有很多优势。
高效：轻松、快速处理GB级别的大数据，并且融合了SQL数据库的语法风格 极简：只需很短的代码就能完成数据的行、列、分组、合并、重塑等相关操作 丰富：数据类型自带筛选、计算、分组、合并等多种方法，无需借助其他函数 此外，一部分R用户需要在数据框里面“嵌套表”，由于data.frame无法实现而十分推崇tibble（tbl_df）。其实，这一点不仅tibble能实现，data.table也完全能实现。
Jan Gorecki 曾对比过不同开源软件及程序包在数据处理方面的性能，结果发现，data.table在数据处理效率上秒杀一大批工具包，甚至轻松超越Python的pandas包和R语言的dplyr包（结果如下图，测试数据规模为5 GB）。而当数据规模达到50 GB，pandas和dplyr都已经hold不住了（报错或内存溢出），但data.table依然稳居榜首（详见：数据处理工具性能大比拼 ）。
使用data.table包并不意味着排斥或弃用其他R包——相反，data.table包是能够和tidyverse、dplyr等著名R包兼容并存、相辅相成的。
这里需要明确几个事实：
tidyverse本身只是一系列常用包的集合（包括dplyr、ggplot2、lubridate、stringr、tibble、tidyr等），并且载入时会为用户默认载入某些常用包，但它本身并没有什么实质性的函数（不信可以查看它的帮助文档）。 管道操作符（%&amp;gt;%）非常好用，也与data.table完全兼容，但它本身既不是tidyverse包里的，也不是dplyr包里的，而是magrittr包里的。 dplyr包的各种数据操作或处理函数，完全适用于data.frame、tibble/tbl_df、data.table等数据类型，因此data.table与dplyr并不冲突（比如，我个人也喜欢用dplyr::left_join()函数对data.table数据进行匹配拼接处理）。 总之：
tidyverse是建议安装的一个综合性R包（并不必然与tibble相联系） dplyr是建议掌握的一个数据处理R包（并不必然与tibble相联系） data.table是强烈建议掌握的一个兼具数据类型和数据处理功能的R包 这三者是可以兼容并包、组合使用的 data.table包提供了一个非常简洁的通用格式：DT[i,j,by]，一句话概括：用 i 选择行，用 j 操作列，根据 by 分组。
其中，j 表达式非常强大和灵活，可以选择、修改、汇总、计算新列，甚至可以接受任意表达式。需要记住的最关键一点是：只要返回等长元素或长度为 1 元素的 list，每个 list 元素将转化为结果 data.table 的一列。
注意:
data.table之后，一些常规的data.frame的操作就失效了，譬如：
data[,-1]、data[,1]这样的操作就不是这么用的了。
使用data.table包操作数据 data.table包提供了一个加强版的data.frame，它运行效率极高，而且能够处理适合内存的大数据集，它使用[]实现了一种自然地数据操作语法。使用下面命令进行安装：
install.packages(&amp;#34;data.table&amp;#34;) 载入包：</description></item><item><title>R语言data.table实战</title><link>https://kongjianyang.github.io/cn/2020/05/05/data.table/</link><pubDate>Tue, 05 May 2020 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2020/05/05/data.table/</guid><description>R语言data.table实战 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言元编程</title><link>https://kongjianyang.github.io/cn/2020/04/17/r%E8%AF%AD%E8%A8%80%E5%85%83%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 17 Apr 2020 12:15:02 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2020/04/17/r%E8%AF%AD%E8%A8%80%E5%85%83%E7%BC%96%E7%A8%8B/</guid><description>R语言元编程 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.</description></item><item><title>R语言tidyverse风格简介</title><link>https://kongjianyang.github.io/cn/2020/02/13/tidy-verse_style/</link><pubDate>Thu, 13 Feb 2020 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2020/02/13/tidy-verse_style/</guid><description>tidyverse有两层基本含义：（1）基于Google 社区的R 代码风格（Google’s R style guide）衍生的一种使代码清晰可读的编程风格；（2）一系列基于前述风格而编写的数据处理R 包。tidyverse一词中的tidy意为整洁，verse意为诗篇、诗行，合起来意指代码或数据如诗行般整洁易读，即成为“整洁代码”（tidy code）或“整洁数据”（tidy data）。熟悉这一风格和相关R 包，可使数据处理和代码编写过程更为便捷高效，且易于与其他数据分析者交流沟通。
建立较为统一的代码书写风格，可方便不同用户之间的沟通与协作。这里基于tidyverse模式择要介绍目前R 编程中的主流风格，并根据中文用户的习惯做部分调整和说明。某些内容可能初学者并不一定很快遇到，但仍宜先行阅读，以建立良好的书写规范。详细的tidyverse风格说明参见如下链接：
http://style.tidyverse.org 三、命名规范
1.文件名
文件名应能体现文件的实质内容，只使用数字、英文字母、中划线-和下划线_。尽量避免文件名中的英文字母大小写混用，宜只使用小写，并建议使用_或-连接文件名中的不同英文，如nankai_psy_2017。
若多个文件存在特定顺序，应以数字作为前缀。如果有超过10个文件，对于个位数的前缀要在前面添补一个0。例如：
其中，.后的xx表示适当的文件后缀名，可能是csv、xlsx、pdf、png等。
超过100个文件则在最开始补充00，依此类推。
2.变量与函数名
变量和函数名应只使用小写字母、数字和下划线_。下划线（_）用于分隔较长命名中的不同单词，避免用.分隔。例如，变量名写成bmi_women，而不是bmi.women；函数名写成trim_gini，而不是trim.gini。变量名应是名词，而函数名应是动词，且应尽量简洁。
这里和base R可能有些区别
在标识符中不要使用下划线 ( _ ) 或连字符 ( - ). 标识符应根据如下惯例命名. 变量名应使用点 (.) 分隔所有的小写字母或单词; 函数名首字母大写, 不用点分隔 (所含单词首字母大写); 常数命名规则同函数, 但需使用一个 k 开头.
variable.name 正例: avg.clicks 反例: avg_Clicks , avgClicks FunctionName 正例: CalculateAvgClicks 反例: calculate_avg_clicks , calculateAvgClicks 函数命名应为动词或动词性短语. 例外: 当创建一个含类 (class) 属性的对象时, 函数名 (也是constructor) 和类名 (class) 应当匹配 (例如, lm).</description></item><item><title>R语言多重数据交集</title><link>https://kongjianyang.github.io/cn/2020/01/12/multiple_intersects/</link><pubDate>Sun, 12 Jan 2020 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2020/01/12/multiple_intersects/</guid><description>一个简单的例子讲解怎么做多重数据的交集
首先创造一个嵌套的list
l &amp;lt;- list(A=c(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;, &amp;#34;four&amp;#34;), B=c(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;), C=c(&amp;#34;two&amp;#34;, &amp;#34;four&amp;#34;, &amp;#34;five&amp;#34;, &amp;#34;six&amp;#34;), D=c(&amp;#34;six&amp;#34;, &amp;#34;seven&amp;#34;)) crossprod(table(stack(l))) l $A [1] &amp;#34;one&amp;#34; &amp;#34;two&amp;#34; &amp;#34;three&amp;#34; &amp;#34;four&amp;#34; $B [1] &amp;#34;one&amp;#34; &amp;#34;two&amp;#34; $C [1] &amp;#34;two&amp;#34; &amp;#34;four&amp;#34; &amp;#34;five&amp;#34; &amp;#34;six&amp;#34; $D [1] &amp;#34;six&amp;#34; &amp;#34;seven&amp;#34; crossprod(table(stack(l))) #的到结果 ind ind A B C D A 4 2 2 0 B 2 2 1 0 C 2 1 4 1 D 0 0 1 2 开始解释这些命令
首先是stack命令，将潜逃列表变平
&amp;gt; stack(l) values ind 1 one A 2 two A 3 three A 4 four A 5 one B 6 two B 7 two C 8 four C 9 five C 10 six C 11 six D 12 seven D Stacking vectors concatenates multiple vectors into a single vector along with a factor indicating where each observation originated.</description></item><item><title>Snippet工具使用介绍</title><link>https://kongjianyang.github.io/cn/2019/11/23/dash/</link><pubDate>Sat, 23 Nov 2019 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/11/23/dash/</guid><description>Dash 1. 功能简介 官方用一句话就概括了它的用途：Dash是一个API文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager）。你没看错，它就只有这两个功能，但确实是程序员（至少对于我来说）最为关心的特性，自己之前也用过了不少类似的工具，可以毫不夸张地说，Dash是它们之中做的最好的一个！
目前dash已经收费了
2. 下载 关于下载我还是推介官网下载吧(https://kapeli.com/dash )
3. 强悍的API文档浏览、搜索功能 想必这个功能是大家最常用的了吧，每天要反复查看、搜索那么多的API细节，没有一个好工具，单靠自己的双手如何应付得来？窗口不停的切来切去，很烦啊！Dash采用集成单一窗口的方式，很好的解决了这个问题。看下面的截图：
点击查看原始大小图片
上图便是Dash的API浏览器主界面：左侧边栏是各种编程语言以及框架（取决于你下载安装了多少文档集合）的导航大纲，点击某个节点，右边的内容区域就是文档的详细信息啦，非常直观。也可以在左上方的搜索框内通过输入关键字，查找相关的API文档，非常类似全文检索的实现方式，Dash的响应速度非常快！关键是可以同时查询不同的语言、框架内容，实在是太方便了。看到这里你也许要问了，这跟我们平常切换到特定的文档窗口（比如一个PDF或者一个CHM文件），再ctrl + f查找有什么区别，不是多此一举吗？其实你错了，Dash可以通过快捷键来显示、隐藏文档窗口，它提供了配置界面以便用户自行设置（我比较习惯alt+space，因为其他软件很少用到这个组合键）：
Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，全列出来很吓人的：
而且它的文档库采用了docset格式，高级用户基于网站提供的教程，很容易就能自行添加其他的扩充文档，其实Dash在最初发布的时候，只支持很少的几个文档浏览，好像只有Java、HTML、CSS这些，是后来通过用户不断贡献，以及作者及时的反馈（Rails API就是我通过Email与作者联系，请求添加的，作者非常nice），逐步壮大，才具备了如此广泛的语言、框架支持。要添加API文档，打开软件配置界面，切换到Docset选项卡即可看到所有内置的文档列表，按需要自行下载即可（如果是自己制作的docset，双击即可导入Dash）：
4. 牛逼、好用的代码片段管理功能 这也是我最喜欢的一个功能
不得不说这个简直就是程序员的神器,大大的提高的程序的开发效率。
前面说完了Dash的文档查询功能，下面再来看一看它带给我们的另一个惊喜：代码片段管理。说到这里，之前的版本其实有个很不好的地方，就是如果不仔细琢磨一下，或者去看官方的帮助文档的话，用户是很难一眼就知道怎么用这个功能，新手引导做得确实不怎么样，不过最新版已经改善了这个问题，在主界面的导航边栏明确地给出了分类提示，创建或者修改代码片段都方便了许多。来看下面这个例子：
利用Dash的代码片段管理功能，我们可以把日常使用频繁（也就是你经常需要复制粘贴）的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来帮你搞定啦。比如上面截图中的例子，就是ExtJS中发起Ajax请求的代码片段，哪怕是copy &amp;amp; paste，时间长了也会很烦的，我给它设置了一个缩写（ajax），以后在需要编写这段代码的时候，就只需要敲击这几个字母，它就会魔法般的出现在光标所在位置啦！很神奇吧？嘿嘿，其实这种扩展缩写的功能，还有很多软件都能做到，比如TextExpander（这个我也买了，半价14刀的时候，但是现在已经打入冷宫了，比较后悔），不过就用户体验和各种细节，诸如界面UI，特别是扩展占位符的处理上，目前还没有哪一个能比得过Dash的（Dash is the best!）。来看看使用代码片段的截图吧：
点击查看原始大小图片
Dash的缩写扩展功能很强大，比方说上面那个例子，在保存代码片段的时候，你可以使用双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换，根据需要输入实际的值，最后回车即可把片段粘贴到光标所在之处。除了占位符，它还支持下面这些变量符号：
@clipboard 自动插入当前剪贴板中的内容
@cursor 代码片段粘贴完毕之后，自动将光标定位到此处
@date 自动插入当前日期
@time 自动插入当前时间</description></item><item><title>Snippet工具使用介绍</title><link>https://kongjianyang.github.io/cn/2019/11/23/dash/</link><pubDate>Sat, 23 Nov 2019 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/11/23/dash/</guid><description>片段（Snippet）是一個編程用語，指的是原始碼、機器碼、文本中可重複使用的小區塊。通常它們是有正式定義的執行單位，以納入更大的編程模塊。也就是只需要输入少数的几个特定字符，编辑器便能帮我们自动补全为模板代码。目前几乎所有主流编辑器和 IDE 都支持这项功能，如 Eclipse, Sublime Text, Visual Studio Code 和 Atom。
市面上有很多的Snippet管理工具。
Alfred 参考这个文章：真正提升你的输入效率，从用好 Alfred 的这个功能开始：Alfred Snippets - 少数派 (sspai.com) 注：Snippets 为 Alfred 的付费功能，需购买 Powerpack 后才能使用。）
打开 Alfred 的设置菜单，找到 Features 里面的 Snippets，你可以看到下图这个设置面板：
设置
想要创建 Snippets，首先要建立一个 Collection（集合）。点击左侧 Collection 底部的 「+」号，输入集合的名字。
在设置中，你可以选择是否为这个 Collection 设置一个前缀或者后缀，这个功能的主要目的是为了方便区分，当你在使用时，通过输入前缀或者后缀可以快速显示某一个集合内的所有 Snippets。我们在这里给这个名为「Personal」的 Collection 添加一个「!」作为前缀。
添加 Collection 后，就可以来创建你的第一个 Snippets 了。点击右侧底部的「+」，输入 Snippets 的名字和关键词，然后在下方输入你希望拓展的内容。在这里以添加个人邮箱为例，在上面的 Keyword 里填入「GM」作为关键词，然后下方输入 myemail@gmail.com ，点击 Save 来保存，这样我们就创建了一条 Snippets。
如何使用 Snippets 接下来我们来看看如何使用刚刚创建的 Snippets。回到 Snippets 设置菜单，在右上角你可以找到 Automatically expand snippets by keyword，打开这个选项后你才能在 macOS 中直接输入关键词来进行拓展（第一次打开时需要在「系统设置 - 隐私 - 辅助功能」中开启服务），否则就需要每次手动进行粘贴。</description></item><item><title>R中的fuzzyjoin包介绍</title><link>https://kongjianyang.github.io/cn/2019/11/12/r_fuzzyjoin/</link><pubDate>Tue, 12 Nov 2019 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/11/12/r_fuzzyjoin/</guid><description>假设字符串x最少需要插入a次、删除b次、替换c次才能与字符串y相同，则x、y之间的 距离 即a、b、c的加权总和。比如将”kitten”转化为”sitting”，需要把“k”替换为“s”，把“e”替换为“i”，并在尾部插入“g”，所以共需1次插入、0次删除、2次替换，按照默认权重两者之间 距离 英该为3。
在R语言中，我们可以使用adist(x, y = NULL, costs = NULL, counts = FALSE, …)的形式，计算字符串之间的距离。其中：
costs即插入（insertions）、删除（deletions）、替换（substitutions）次数的权重 counts表示是否输出插入、删除、替换次数 partial表示是否只进行局部匹配 library(tidyverse) ## ── Attaching packages ─────────────────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.1 ✓ dplyr 1.0.5 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() drop(attr(adist(&amp;quot;kitten&amp;quot;, &amp;quot;sitting&amp;quot;, counts = TRUE), &amp;quot;counts&amp;quot;)) ## ins del sub ## 1 0 2 adist(&amp;quot;kitten&amp;quot;, &amp;quot;sitting&amp;quot;, counts = TRUE) %&amp;gt;% attr(.</description></item><item><title>snakemake教学</title><link>https://kongjianyang.github.io/cn/2019/10/17/snakemake/</link><pubDate>Thu, 17 Oct 2019 19:10:27 -0400</pubDate><guid>https://kongjianyang.github.io/cn/2019/10/17/snakemake/</guid><description>参考： https://qinqianshan.com/python/py_module/snakemake/ https://xizhihui.github.io/2018/10/28/%E6%B5%81%E7%A8%8B%E6%9E%84%E5%BB%BA-Snakemake%E4%BD%BF%E7%94%A8%E5%88%9D%E6%AD%A5/ 如果你编译过软件，那你应该见过和用过make, 但是你估计也没有仔细想过make是干嘛用的。Make是最常用的软件构建工具，诞生于1977年，主要用于C语言的项目，是为了处理编译时存在各种依赖关系，尤其是部分文件更新后，Make能够重新生成需要更新的文件以及其对应的文件。
Snakemake和Make功能一致，只不过用Python实现，增加了许多Python的特性，并且和Python一样非常容易阅读。
Snakemake是一个工作流程管理系统。它是基于Python的、用于创建可重现和可扩展的数据分析的工具（当然现在也可以直接将它当做Python的一个模块）。Snakemake所创建的流程还可以无缝扩展到服务器、集群和云环境等不同环境，当然前提是你需要提前将所需的软件和依赖配置好，一起打包封装在conda环境中。
安装软件
pip3 install snakemake 虽然snakemake广泛的应用于生物信息方面的流程编写，但是snakemake的应用并不局限于编写生物信息学的流程，这里以一个简单的合并文件的例子开始介绍snakemake的简单使用。
#首先我们建立两个文件 echo &amp;#34;Here is hello.&amp;#34; &amp;gt; hello.txt echo &amp;#34;Here is world.&amp;#34; &amp;gt; world.txt #接下来开始编写我们的Snakefile rule concat: # 这里的rule可视为snakemake定义的关键字，concat是我们自定义的这一步任务的名称 input: # input同样是snakemake的关键字，定义了在这个任务中的输入文件 expand(&amp;#34;{file}.txt&amp;#34;, file=[&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;]) #expand是一个snakemake定义的替换命令 output: # output也是snakemake的关键字，定义输出结果的保存文件 &amp;#34;merged.txt&amp;#34; shell: # 这里表示我们下面的命令将在命令行中执行 &amp;#34;cat {input} &amp;gt; {output}&amp;#34; #最后就可以在Snakefile的路径执行snakemake命令即可 snakemake cat merge.txt # Here is hello. # Here is world. 在上面的Snakefile脚本中，rule、input、output、shell、expand均为snakemake中的关键字或者命令。同时Snakefile中的每一个rule其实都可以看作是一个简单的shell脚本，通过Snakefile将多个rule组织在一起并按照我们定义的顺序来执行。另外，在output中的结果文件可以是未存在目录中的文件,这时会自动创建不存在的目录。
snakemake中的规则 rule是Snakefile中最主要的部分。如上面的例子所说，每一个rule定义了一系列pipe中的一步，每一个rule都可以当作一个shell脚本来处理，一般主要包括input、output、shell3个部分。同时还有许多上面没有列出来的用法：
wildcards。用来获取通配符匹配到的部分，例如对于通配符&amp;quot;{dataset}/file.{group}.txt&amp;quot;匹配到文件101/file.A.txt，则{wildcards.dataset}就是101，{wildcards.group}就是A。 threads。通过在rule里面指定threads参数来指定分配给程序的线程数，egthreads: 8。 resources。可用来指定程序运行的内存，eg. resources: mem_mb=800。 message。使用message参数可以指定每运行到一个rule时，在终端中给出提示信息，eg.</description></item><item><title>R语言绘制桑吉图</title><link>https://kongjianyang.github.io/cn/2019/10/11/sankey/</link><pubDate>Fri, 11 Oct 2019 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/10/11/sankey/</guid><description>R语言绘制桑吉图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>html基本入门</title><link>https://kongjianyang.github.io/cn/2019/08/27/html_intro/</link><pubDate>Tue, 27 Aug 2019 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/08/27/html_intro/</guid><description>HTML 不是一门编程语言，而是一种用于定义内容结构的_标记语言_。HTML 由一系列的**元素（elements）**组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 例如，键入下面一行内容：
键入下面一行内容：
我的猫咪脾气非常暴躁 可以将这行文字封装成一个段落（paragraph）元素来使其在单独一行呈现：
&amp;lt;p&amp;gt;我的猫咪脾气非常暴躁&amp;lt;/p&amp;gt; HTML元素的剖析 让我们进一步探讨该段落元素。
元素的主要部分如下：
开头标记：它由元素的名称（在本例中为p）组成，并包装在开始和关闭尖括号中。这说明了元素开始或开始生效的位置-在这种情况下，段落开始了。 **结束标记：**与开始标记相同，不同之处在于它在元素名称之前包含一个_正斜杠_。这说明了元素的结尾，在这种情况下，段落的结尾。未能添加结束标记是标准的初学者错误之一，并且可能导致奇怪的结果。 **内容：**这是元素的内容，在这种情况下，只是文本。 **元素：**开始标签，结束标签和内容共同组成元素。 元素也可以具有如下所示的属性：
属性包含有关您不想出现在实际内容中的元素的额外信息。在这里，class是属性_名称_ ，editor-note是属性_值_。通过该class属性，您可以为元素提供一个非唯一的标识符，该标识符可用于class样式信息和其他信息。
属性应始终具有以下内容：
它与元素名称（如果元素已经具有一个或多个属性，则为上一个属性）之间的空格。 属性名称后跟等号。 用引号引起来的属性值。 注意：不包含ASCII空格（或任何字符&amp;quot; ' ` = &amp;lt; &amp;gt;）的简单属性值可以不加引号，但是建议您对所有属性值加引号，因为这会使代码更一致和更易理解。
嵌套元素 您也可以将元素放入其他元素中-这称为嵌套。如果要说明“我们的猫脾气非常暴躁”，可以将“非常”一词包裹在一个&amp;lt;strong&amp;gt; 元素中，这意味着特别强调该词：
&amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常&amp;lt;/strong&amp;gt;暴躁:)&amp;lt;/p&amp;gt; 但是，要确保元素正确嵌套。在上面的示例中，我们&amp;lt;p&amp;gt; 首先打开了元素，然后打开了&amp;lt;strong&amp;gt;元素；因此，我们必须先关闭&amp;lt;strong&amp;gt;元素，然后再关闭&amp;lt;p&amp;gt;元素。以下是不正确的：
# right &amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常暴躁&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; # wong &amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常&amp;lt;/p&amp;gt;暴躁&amp;lt;/strong&amp;gt; 这些元素必须正确地打开和关闭，以使它们清楚地位于彼此内部或外部。如果它们如上所示重叠，则您的Web浏览器将尝试对您要说的内容做出最佳猜测，这可能会导致意外结果。
空元素 一些元素没有内容，被称为空元素。采取&amp;lt;img&amp;gt; 我们在HTML页面中已经拥有的元素：
&amp;lt;img src=&amp;#34;/img/earth.jpg&amp;#34; alt=&amp;#34;地球&amp;#34;&amp;gt; 它包含两个属性，但是没有结束&amp;lt;/img&amp;gt;标记，也没有内部内容。其目的是将图像嵌入HTML页面中。
HTML文档剖析 总结了各个HTML元素的基础知识。现在，我们将研究如何将单个元素组合以形成整个HTML页面。让我们重新看一下index.html示例中放入的代码：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;测试页面&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;#34;/img/earth.</description></item><item><title>R中处理错误</title><link>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</link><pubDate>Fri, 07 Jun 2019 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</guid><description>方案一：使用try语句 使用方法
在R语言中，try语句的用法如下所示: try(expr, silent = FALSE, outFile = getOption(&amp;#34;try.outFile&amp;#34;, default = stderr())) 可以看到，try语句共有三个参数，常用的是前两个参数。第一个参数expr为我们所要使用的表达式，第二个参数silent表示当错误出现时是否需要报告错误信息，其输入值应为逻辑变量，默认为FALSE，即选择不保持“沉默”，当错误出现时会立即报告错误信息。
如果参数expr所代表的表达式可以正确运行，则try语句的输出即为该表达式的运行结果，如果表达式无法正确运行，则try语句会输出一个“try-error”类的不可见对象，因此可以通过if语句对try语句的输出结果进行判断从而进行下一步的处理。
如果大段代码中有错误，想忽略错误，可以采用try()，但大段代码需放在**{ }**中：
你可以捕获**try()的输出，如果程序运行成功，返回计算结果；如果程序运行不成功，则可以通过class()**函数返回，错误类型 &amp;rsquo;try-error&amp;rsquo;。
使用示例 A = list(a=1,b=&amp;#39;abc&amp;#39;,c=-2,d=3) # 运行log(&amp;#39;abc&amp;#39;)会报错，运行log(-2)会出现警告 B = list() for (nm in names(A)) { x &amp;lt;- A[[nm]] temp &amp;lt;- try(log(x),silent=FALSE) if(&amp;#39;try-error&amp;#39; %in% class(temp)) # 判断当前循环的try语句中的表达式是否运行正确 { temp &amp;lt;- NA # 此处可以对运行错误的情况进行处理应对 } B[[nm]] &amp;lt;- temp } 方案二：使用tryCatch语句 使用方法
相较于try语句，tryCatch语句更为全面，能够处理和应对更为复杂的问题。其不仅能够处理表达式出现错误error的情形，还能够处理出现警告warning的情况。主要用法如下所示： tryCatch( { expr }, warning = function(w) { warning-handler-code }, error = function(e) { error-handler-code }, finally = { cleanup-code } ) 可以看到，tryCatch语句的内部可以被划分为四个不同的部分。</description></item><item><title>R语言管道操作Magritte</title><link>https://kongjianyang.github.io/cn/2019/04/27/magritte/</link><pubDate>Sat, 27 Apr 2019 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/04/27/magritte/</guid><description>主要参考文章：
R语言中管道操作符 %&amp;gt;%, %T&amp;gt;%, %$% 和 %&amp;lt;&amp;gt;% - 知乎 (zhihu.com) The Four Pipes of magrittr | R-bloggers magrittr包有两个主要目标:
第一是减少代码开发时间，提高代码的可读性和维护性
第二是让你的代码更短
lhs %&amp;gt;% rhs # pipe syntax for rhs(lhs)
lhs %&amp;gt;% rhs(a = 1) # pipe syntax for rhs(lhs, a = 1)
lhs %&amp;gt;% rhs(a = 1, b = .) # pipe syntax for rhs(a = 1, b = lhs)
lhs %&amp;lt;&amp;gt;% rhs # pipe syntax for lhs &amp;lt;- rhs(lhs)</description></item><item><title>vscode使用技巧</title><link>https://kongjianyang.github.io/cn/2019/03/14/vscode/</link><pubDate>Thu, 14 Mar 2019 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2019/03/14/vscode/</guid><description>VS code 的层级树太浅怎么解决，子目录的缩进不够深
通过修改workbench&amp;gt;Tree: indent的结构
一些详细介绍：
一、User Guide（用户指南）🔗 参考官方文档：Basic Editing in Visual Studio Code 更改显示语言🔗 通过安装插件 Chinese (Simplified) Language Pack for Visual Studio Code 来启用中文（需要重启）
默认情况下，Visual Studio Code 附带英语作为显示语言，而其他语言则依赖于 Marketplace 提供的语言包扩展。
VS Code 检测到操作系统的 UI 语言，并会提示您安装适当的语言包（如果在 Marketplace 上可用）。
保存/自动保存🔗 默认情况下，VS 代码需要一个明确的行动，将更改保存到磁盘，按Ctrl + S。
您也可以使用文件 &amp;gt; 自动保存从顶级菜单切换自动保存。
要进一步控制自动保存，请打开配置文件settings.json，然后找到相关的设置（如果没有则直接添加）：
它可以具有以下值：
off -禁用自动保存。
afterDelay - 在配置的延迟（默认 1000 毫秒）后保存文件。
onFocusChange - 当焦点移出脏文件的编辑器时保存文件。
onWindowChange - 当焦点移出 VS Code 窗口时保存文件。</description></item><item><title>NMF包绘制热图</title><link>https://kongjianyang.github.io/cn/2018/12/30/heatmap/</link><pubDate>Sun, 30 Dec 2018 14:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/30/heatmap/</guid><description>NMF包绘制热图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child"); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){"use strict";"object"==typeof module&amp;&amp;"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.</description></item><item><title>R语言文本处理</title><link>https://kongjianyang.github.io/cn/2018/12/27/r%E8%AF%AD%E8%A8%80%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</link><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/27/r%E8%AF%AD%E8%A8%80%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</guid><description>常见函数 trimws(x)删去字符型向量x的每个元素的开头和结尾的所有空格。加选项which=’left’可以仅删去开头的空格， 选项which=’right’可以仅删去结尾的空格。
trimws(c(&amp;quot; 李明&amp;quot;, &amp;quot;李明 &amp;quot;, &amp;quot; 李明 &amp;quot;, &amp;quot;李 明&amp;quot;)) ## [1] &amp;quot;李明&amp;quot; &amp;quot;李明&amp;quot; &amp;quot;李明&amp;quot; &amp;quot;李 明&amp;quot; sprintf是C语言中sprintf的向量化版本，可以把一个元素或一个向量的各个元素按照C语言输出格式转换为字符型向量。
sprintf(&amp;#39;tour%02d.jpg&amp;#39;, 1:10) ## [1] &amp;quot;tour01.jpg&amp;quot; &amp;quot;tour02.jpg&amp;quot; &amp;quot;tour03.jpg&amp;quot; &amp;quot;tour04.jpg&amp;quot; &amp;quot;tour05.jpg&amp;quot; ## [6] &amp;quot;tour06.jpg&amp;quot; &amp;quot;tour07.jpg&amp;quot; &amp;quot;tour08.jpg&amp;quot; &amp;quot;tour09.jpg&amp;quot; &amp;quot;tour10.jpg&amp;quot; substring函数求字符串字串， 用开始字符位置和结束字符位置设定字串位置。
substring(c(&amp;quot;123456789&amp;quot;, &amp;quot;abcdefg&amp;quot;), 3, 5) ## [1] &amp;quot;345&amp;quot; &amp;quot;cde&amp;quot; 用gsub(pattern, replacement, x, fixed=TRUE) 把字符型向量x中每个元素中出现的子串 pattern都替换为replacement。
gsub(&amp;#39;the&amp;#39;, &amp;#39;**&amp;#39;, c(&amp;#39;New theme&amp;#39;, &amp;#39;Old times&amp;#39;, &amp;#39;In the present theme&amp;#39;), fixed=TRUE) ## [1] &amp;quot;New **me&amp;quot; &amp;quot;Old times&amp;quot; &amp;quot;In ** present **me&amp;quot; strsplit(x,split,fixed=TRUE)可以把字符型向量x的每一个元素按分隔符split拆分为一个字符型向量， strsplit的结果为一个列表， 每个列表元素对应于x的每个元素。</description></item><item><title>使用Rmd写博客的一些流程</title><link>https://kongjianyang.github.io/cn/2018/12/25/rmd/</link><pubDate>Tue, 25 Dec 2018 14:32:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/25/rmd/</guid><description>首先将Rmd文件转换为md文件
library(rmarkdown) a &amp;lt;- list.files(&amp;#34;./&amp;#34;, pattern = &amp;#34;.Rmd&amp;#34;) map(a, render, md_document()) #会将当前文件下所有的Rmd文件转化为md文件 on the Mac you could use the following commands to open RStudio (respectively) in the &amp;lsquo;~/projects/foo&amp;rsquo; directory or the current working directory:
$ open -a RStudio ~/projects/foo $ open -a RStudio . 这里的open命令很有用
MacOS用户如果有用命令行的话，大多数人应该知道open .会打开Finder。事实上它能打开所有的目录，比如:
$ open ~/Library/Preferences $ open /etc $ open ../.. 你还能同时打开多个目录：
$ open ~/Documents ~/Desktop ~/Downloads $ open ~/D* 然后它还能打开各种文件，比如：
$ open document.</description></item><item><title>R语言中的调色板</title><link>https://kongjianyang.github.io/cn/2018/12/20/r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%B0%83%E8%89%B2%E6%9D%BF/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/20/r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%B0%83%E8%89%B2%E6%9D%BF/</guid><description>使用RColorBrewer包实现R图形的亚瑟个性化
library(RColorBrewer) display.brewer.all() 连续型调色板（第一个颜色列表），适用于从低到高（梯度）的有序数据。调色板名称是：Blues，BuGn，BuPu，GnBu，Greens，Grays，Oranges，OrRd，PuBu，PuBuGn，PuRd，Purples，RdPu，Reds，YlGn，YlGnBu YlOrBr，YlOrRd。
定性调色板（第二种颜色列表），最适合表示名义或分类数据。它们并不意味着群体之间的巨大差异。 调色板名称为：Accent，Dark2，Paired，Pastel1，Pastel2，Set1，Set2，Set3。
差异调色板（第三种颜色列表），强调数据范围两端颜色相反。分散的调色板是：BrBG，PiYG，PRGn，PuOr，RdBu，RdGy，RdYlBu，RdYlGn，Spectral
-仅显示色盲友好的调色板，要仅显示色盲友好的brewer调色板，请指定colorblindFriendly选项= TRUE，如下所示：
display.brewer.all(colorblindFriendly = TRUE) # 1. Visualize a single RColorBrewer palette # by specifying its name display.brewer.pal(n, name) # 2. Return the hexadecimal color code of the palette brewer.pal(n, name) 函数参数的描述：n：调色板中不同颜色的数量，最小值为3，最大值取决于调色板。 name：上面列表中的调色板名称。 例如name = RdBu。
以下R代码演示了如何显示一个单一的r颜色brewer调色板。
# View a single RColorBrewer palette by specifying its name display.brewer.pal(n = 8, name = &amp;#39;Dark2&amp;#39;) # Hexadecimal color specification brewer.</description></item><item><title>Rstudio的常用快捷键</title><link>https://kongjianyang.github.io/cn/2018/12/18/rstudio%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/18/rstudio%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>Rstudio IDE Cheat Sheet
0. 常用 Windows Mac 清空控制台 Ctrl+L Command+L 新建一个文件 Ctrl+Shift+N Command+Shift+N 打开文件 Ctrl+O Command+O 保存当前文件 Ctrl+S Command+S 关闭当前文件 Ctrl+W Command+W 关闭所有打开的文件 Ctrl+Shift+W Command+Shift+W 运行当前/被选中的代码 Ctrl+Enter Command+Enter 运行当前文件 Ctrl+Alt+R Command+Option+R 运行当前代码块 Ctrl+Alt+C Command+Option+C 运行下一个代码块 Ctrl+Alt+N Command+Option+N 执行一个外部文件中的代码 Ctrl+Shift+O Command+Shift+O 执行当前文件中的代码 Ctrl+Shift+S Command+Shift+S 折叠选中代码 Alt+L Command+Option+L 打开选中代码 Shift+Alt+L Command+Shift+Option+L 折叠所有代码 Alt+0 Command+Option+0 打开所有代码 Shift+Alt+0 Command+Shift+Option+0 切换到前一个tab Ctrl+Alt+Left Ctrl+Option+Left 切换到下一个tab Ctrl+Alt+Right Ctrl+Option+Right 切换到第一个tab Ctrl+Shift+Alt+Left Ctrl+Shift+Option+Left 切换到最后一个tab Ctrl+Shift+Alt+Right Ctrl+Shift+Option+Right 注释/取消注释当前行 Ctrl+Shift+C Command+Shift+C 1.</description></item><item><title>利用BinGO实现在cytoscape中的富集分析和网络可视化</title><link>https://kongjianyang.github.io/cn/2018/12/17/%E5%88%A9%E7%94%A8bingo%E5%AE%9E%E7%8E%B0%E5%9C%A8cytoscape%E4%B8%AD%E7%9A%84%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8F%AF%E8%A7%86%E5%8C%96/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/17/%E5%88%A9%E7%94%A8bingo%E5%AE%9E%E7%8E%B0%E5%9C%A8cytoscape%E4%B8%AD%E7%9A%84%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><description> 1. 安装 在主菜单找到Apps manager，再找到BinGO就可以实现安装
2. 使用 使用之前先下载物种最新的GO注释文件，以拟南芥为例：
http://geneontology.org/page/downloads
找到拟南芥，这个注释文件包含的两列对这里的分析是有用的，分别是Gene ID和GO 功能注释。但文件还包含了其他信息，如symbol，基因的物理坐标信息，UniProt ID等：
将刚刚下载的gene_association.tair导入到BiNGO中.
下载GO功能注释分类文件，下载地址：http://geneontology.org/page/downloads
相同界面，点选Ontology 在界面内，找到“go-basic.obo”并下载
“go-basic.obo”可以使用文本文件打开。里面记录了GO term 间的关系，依据这些关系，GO term最终将被化成网络图的形式。找到 select ontology file的窗口，选择custom，然后导入。
针对拟南芥，也可以使用cytoscape自带的注释和注释分类文件，不需要重新下载
3. 结果 GO富集结果：一个文件属于弹窗，另一个存储在输出文件夹中（内容相同）。第五列和第六列列出了这类功能基因在目标基因集合和全基因组基因中的比例。
另外GO分析网络图结果，颜色越深越富集，下面的表格为详细的富集信息：
上述步骤分析完后会直接在cytoscape 页面生成绘图结果</description></item><item><title>R从数据框中按组别移除离群值(outlier)</title><link>https://kongjianyang.github.io/cn/2018/12/14/r%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%A1%86%E4%B8%AD%E6%8C%89%E7%BB%84%E5%88%AB%E7%A7%BB%E9%99%A4%E7%A6%BB%E7%BE%A4%E5%80%BCoutlier/</link><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/14/r%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%A1%86%E4%B8%AD%E6%8C%89%E7%BB%84%E5%88%AB%E7%A7%BB%E9%99%A4%E7%A6%BB%E7%BE%A4%E5%80%BCoutlier/</guid><description>离群值(outlier)通常被定义为小于 QL - l.5 IQR 或者 大于 Qu + 1.5 IQR的值，QL称为下四分位数， Qu称为上四分位数，IQR称为四分位数间距，是Qu上四分位数和QL下四分位数之差，其间包括了全部观察值的一半。
1.方法一： 定义功能剔除离群值
remove_outliers &amp;lt;- function(x, na.rm = TRUE, ...) { qnt &amp;lt;- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...) H &amp;lt;- 1.5 * IQR(x, na.rm = na.rm) y &amp;lt;- x y[x &amp;lt;= (qnt[1] - H)] &amp;lt;- NA y[x &amp;gt;= (qnt[2] + H)] &amp;lt;- NA y } 制造数据框
element &amp;lt;- sample(letters[1:5], 1e4, replace=T) value &amp;lt;- rnorm(1e4) df &amp;lt;- data.</description></item><item><title>R语言的小提琴图</title><link>https://kongjianyang.github.io/cn/2018/12/14/r%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E6%8F%90%E7%90%B4%E5%9B%BE/</link><pubDate>Fri, 14 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/14/r%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E6%8F%90%E7%90%B4%E5%9B%BE/</guid><description/></item><item><title>利用FLARUM开发论坛</title><link>https://kongjianyang.github.io/cn/2018/12/13/%E5%88%A9%E7%94%A8flarum%E5%BC%80%E5%8F%91%E8%AE%BA%E5%9D%9B/</link><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/13/%E5%88%A9%E7%94%A8flarum%E5%BC%80%E5%8F%91%E8%AE%BA%E5%9D%9B/</guid><description>&lt;p>未完待续！&lt;/p>
&lt;p>&lt;a href="https://bbs.fatdoge.cn/" target="_blank" rel="noreferrer noopener">https://bbs.fatdoge.cn/&lt;/a>
&lt;/p>
&lt;p>&lt;a href="https://hero-x.cn/website" target="_blank" rel="noreferrer noopener">https://hero-x.cn/website&lt;/a>
&lt;/p>
&lt;p>&lt;a href="https://flarum.org.cn/" target="_blank" rel="noreferrer noopener">中文网址&lt;/a>
&lt;/p></description></item><item><title>R中的循环多图处理技巧</title><link>https://kongjianyang.github.io/cn/2018/12/12/r%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%A4%9A%E5%9B%BE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/12/r%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%A4%9A%E5%9B%BE%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</guid><description>1.制造一些图 制造一些图片，为后续的操作做准备
library(ggplot2) # This example uses the ChickWeight dataset, which comes with ggplot2 # First plot p1 &amp;lt;- ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet, group=Chick)) + geom_line() + ggtitle(&amp;quot;Growth curve for individual chicks&amp;quot;) # Second plot p2 &amp;lt;- ggplot(ChickWeight, aes(x=Time, y=weight, colour=Diet)) + geom_point(alpha=.3) + geom_smooth(alpha=.2, size=1) + ggtitle(&amp;quot;Fitted growth curve per diet&amp;quot;) # Third plot p3 &amp;lt;- ggplot(subset(ChickWeight, Time==21), aes(x=weight, colour=Diet)) + geom_density() + ggtitle(&amp;quot;Final weight, by diet&amp;quot;) # Fourth plot p4 &amp;lt;- ggplot(subset(ChickWeight, Time==21), aes(x=weight, fill=Diet)) + geom_histogram(colour=&amp;quot;black&amp;quot;, binwidth=50) + facet_grid(Diet ~ .</description></item><item><title>R中的箱线图进阶</title><link>https://kongjianyang.github.io/cn/2018/12/12/r%E4%B8%AD%E7%9A%84%E7%AE%B1%E7%BA%BF%E5%9B%BE%E8%BF%9B%E9%98%B6/</link><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/12/r%E4%B8%AD%E7%9A%84%E7%AE%B1%E7%BA%BF%E5%9B%BE%E8%BF%9B%E9%98%B6/</guid><description> 箱线图能够显示出离群点（outlier），离群点也叫做异常值，通过箱线图能够很容易识别出数据中的异常值。
geom_boxplot函数中有outlier开头的多个参数，用于修改离群点的属性：
outlier.colour：离群点的颜色 outlier.fill：离群点的填充色 outlier.shape：离群点的形状 outlier.size：离群点的大小 outlier.alpha：离群点的透明度 绘制散点图，并标记异常值：
ToothGrowth$dose &amp;lt;- as.factor(ToothGrowth$dose) ggplot(ToothGrowth, aes(x=dose, y=len,color=dose)) + geom_boxplot(outlier.colour=&amp;quot;red&amp;quot;, outlier.shape=7,outlier.size=4)+ scale_color_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;))+ theme_bw() + theme(legend.position=&amp;quot;right&amp;quot;)+ labs(title=&amp;quot;Plot of length per dose&amp;quot;,x=&amp;quot;Dose (mg)&amp;quot;, y = &amp;quot;Length&amp;quot;)+ geom_dotplot(binaxis=&amp;#39;y&amp;#39;, stackdir=&amp;#39;center&amp;#39;, stackratio=1.5, dotsize=1.2)</description></item><item><title>Notes From Advanced R Part Two</title><link>https://kongjianyang.github.io/en/2018/12/06/notes-from-advanced-r-part-two/</link><pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/12/06/notes-from-advanced-r-part-two/</guid><description>1. OO (Object-oriented) field guide R has four object oriented systems:
base type: are mostly manipulated using C code S3 type: S3 is a very casual system. It has no formal definition of classes. S4 type: S4 has formal class definitions and multiple dispatch RC (Reference Classes) type A class defines the behaviour of objects by describing their attributes and their relationship to other classes.
pryr provides tools to pry back the surface of R and dig into the details.</description></item><item><title>Mac原生词典的一些便捷操作</title><link>https://kongjianyang.github.io/cn/2018/12/05/mac%E5%8E%9F%E7%94%9F%E8%AF%8D%E5%85%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/05/mac%E5%8E%9F%E7%94%9F%E8%AF%8D%E5%85%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%BF%E6%8D%B7%E6%93%8D%E4%BD%9C/</guid><description>鼠标取词
在任何文字区域上按下 control+cmd+D 就可呼出取词窗口，词典会根据鼠标的位置自动取词，不需要启动词典程序
单词发音 在accessibility下面的speech下面选择开启speak selected text when the key is pressed，可以打开快捷键如 Option+Esc。在词典查询结果的窗口下按下快捷键会将窗口文本朗读一遍，当然，我们在乎只是英文单词的发音而已，再按一次停止。
https://kaihao.io/2018/mdict-to-macos-dictionary/</description></item><item><title>markdown格式进阶备忘</title><link>https://kongjianyang.github.io/cn/2018/12/02/md%E6%A0%BC%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%A4%87%E5%BF%98/</link><pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/12/02/md%E6%A0%BC%E5%BC%8F%E8%BF%9B%E9%98%B6%E5%A4%87%E5%BF%98/</guid><description>HTML是英文Hyper Text Mark-up Language (超文本标记语言) 的缩写，则Markdown的意思可能是反标记，因为markup是标记。
1. 任务列表 - [ ] 任务一 未做任务 - [x] 任务二 已做任务 任务一 未做任务 任务二 已做任务 2. 删除线 &amp;amp; 分割线 ~~需要加删除线的内容~~ &amp;lt;del&amp;gt;需要加删除线的内容&amp;lt;/del&amp;gt; 效果：
需要加删除线的内容
需要加删除线的内容
*** ***** - - - 效果：
3. 简单公式 $$E=mc^2$$ 效果：
$$E=mc^2$$
4. 嵌套引用 &amp;gt; 这是外层的引用 &amp;gt; &amp;gt; 这是内层的引用 这是外层的引用
这是内层的引用
5. 表格 其中的一个例子
| Table | Col1 | Col2 | | ----- |:----:| ----:| | Row1 | 1-1 | 1-2 | | Row2 | 2-1 | 2-2 | | Row3 | 3-1 | 3-2 | Table Col1 Col2 Row1 1-1 1-2 Row2 2-1 2-2 Row3 3-1 3-2 齐总的点代表对齐方式，分别是默认（居右）、居中、居左。 还可以使表格居中</description></item><item><title>Notes From Advanced R Part One</title><link>https://kongjianyang.github.io/en/2018/12/02/notes-from-advanced-r/</link><pubDate>Sun, 02 Dec 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/12/02/notes-from-advanced-r/</guid><description>1. Data structure The three properties of a vector are type, length, and attributes.
All objects can have arbitrary additional attributes
Attributes can be accessed individually with attr() or all at once (as a list) with attributes().
y &amp;lt;- 1:10 attr(y, &amp;quot;my_attribute&amp;quot;) &amp;lt;- &amp;quot;This is a vector&amp;quot; attr(y, &amp;quot;my_attribute&amp;quot;) ## [1] &amp;quot;This is a vector&amp;quot; 2. Subsetting outer() function applies a function to two arrays.
x &amp;lt;- c(1, 2.</description></item><item><title>macOS下的一些快捷操作</title><link>https://kongjianyang.github.io/cn/2018/11/30/macos%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/30/macos%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/</guid><description>以下快捷键按照对我的重要程度进行排序
1. 最强大快捷键 使用automator定制化自己的快捷键
打开automator 打开quick action， 选择service input = noinput以及any application都能打开 选择launch application，例如选择Google，运行run测试是不是可以工作，保存为launch Google 打开setting， 选择keyboard，选择shortcuts，选择services定制自己的快捷键 一般选择设置三个以上的键组会快捷键，我设置为shift-command-control-G为快捷键 2. chrome快捷键 快捷键 操作 command+T 增加窗口 command+N 增加打开 command+~ 切换浏览器窗口 ⌘-Option 和向右箭 切换到下一个标签页 ⌘-Option 和向左 切换到上一个标签页 command+W 关闭当前窗口 command+F 搜索 command+0 还原大小 command+option+c 拷贝网址 command+shift+T 重新打开刚刚不小心关闭的网页 ⌘-Option-B 打开书签管理器。 ⌘-Y 打开“历史记录”页面。 command+R 刷新 command+.</description></item><item><title>z-score标准化和R代码实现</title><link>https://kongjianyang.github.io/cn/2018/11/30/z-score%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8Cr%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/30/z-score%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8Cr%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>z-score标准化：标准分数（standard score）也叫z分数（z-score）,是一个分数与平均数的差再除以标准差的过程。 用公式表示为：z=(x-μ)/σ。或者说Z = (x - x(mean)) / x(sd)，其中x为某一具体分数，μ为平均数，σ为标准差。 Z值代表着原始分数和母体平均值之间的距离，是以标准差为单位计算。 标准分数可以回答这样一个问题：“一个给定分数距离平均数多少个标准差?”在平均数之上的分数会得到一个正的标准分数，在平均数之下的分数会得到一个负的标准分数。 经过处理的数据符合标准正态分布，即均值为0，标准差为1， Z score 也可以用来表示组织特异性，0 表示没有组织特异性， Z-score &amp;gt;3 表示组织特异性强
z-score标准化也叫做标准差标准化，经过处理之后的数据会符合标准正态分布，其均值为0，标准差为1。
z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况。其他还有
最小-最大规范化——标准化：对原始数据的线性变换，将数据映射到[0,1]之间 x-min(x) / max(x)-min(x) 移动变量的小数点位置来将变量映射到[-1,1] data &amp;lt;- matrix(1:16,nrow=4) data ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 函数density计算的是数据的核心密度（kernal density）分布，其中density的计算可以通过bw参数（bandwidth）来控制，bw参数最直观的影响就是曲线的平滑性。默认的bw是通过函数bw.nrd0()计算得出，也可以手动设置。
d&amp;lt;-density(data) plot(d) a&amp;lt;-round(scale(data),2) a ## [,1] [,2] [,3] [,4] ## [1,] -1.</description></item><item><title>vim编辑常用命令</title><link>https://kongjianyang.github.io/cn/2018/11/29/vim%E7%BC%96%E8%BE%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Thu, 29 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/29/vim%E7%BC%96%E8%BE%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>一、插入文本 常用的，当然是i，但是如果只用i，那就太土鳖了，记住i、o、a即可， 当然大小写，一般区分前后的概念，这个是vim在设计各类指令的原则。
命令 执行的操作 i 在光标的左侧插入字符 I 在行首插入字符 a 在光标的右侧添加文本 A 在行尾添加文本 o 在当前行下面插入一空行 O 在当前行上面插入一空行 下面还有几个常用的设置：
命令 执行的操作 :set showmode 当vi处在输入模式下时显示提示信息 :set sm 即时显示配对的)或} :set ts=n 把制表符设置为n(默认为8) :set ai 下一行从前一行的缩进位置开始（这个在写代码时比较有用） 二. 查找 命令 执行的操作 /xxx(?</description></item><item><title>R中cowplot包初步学习</title><link>https://kongjianyang.github.io/cn/2018/11/28/r%E4%B8%ADcowplot%E5%8C%85%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/28/r%E4%B8%ADcowplot%E5%8C%85%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</guid><description>cowplot是ggplot2包的一个简单插件，它的目的是为ggplot2提供一个出版级别的主题。
查看cowplot内的主要命令
library(cowplot) ## ## Attaching package: &amp;#39;cowplot&amp;#39; ## The following object is masked from &amp;#39;package:ggplot2&amp;#39;: ## ## ggsave ls(&amp;quot;package:cowplot&amp;quot;) ## [1] &amp;quot;add_sub&amp;quot; &amp;quot;align_margin&amp;quot; &amp;quot;align_plots&amp;quot; ## [4] &amp;quot;axis_canvas&amp;quot; &amp;quot;background_grid&amp;quot; &amp;quot;draw_figure_label&amp;quot; ## [7] &amp;quot;draw_grob&amp;quot; &amp;quot;draw_image&amp;quot; &amp;quot;draw_label&amp;quot; ## [10] &amp;quot;draw_line&amp;quot; &amp;quot;draw_plot&amp;quot; &amp;quot;draw_plot_label&amp;quot; ## [13] &amp;quot;draw_text&amp;quot; &amp;quot;GeomDrawGrob&amp;quot; &amp;quot;get_legend&amp;quot; ## [16] &amp;quot;get_panel&amp;quot; &amp;quot;ggdraw&amp;quot; &amp;quot;ggsave&amp;quot; ## [19] &amp;quot;gtable_remove_grobs&amp;quot; &amp;quot;gtable_squash_cols&amp;quot; &amp;quot;gtable_squash_rows&amp;quot; ## [22] &amp;quot;insert_xaxis_grob&amp;quot; &amp;quot;insert_yaxis_grob&amp;quot; &amp;quot;panel_border&amp;quot; ## [25] &amp;quot;plot_grid&amp;quot; &amp;quot;plot_to_gtable&amp;quot; &amp;quot;save_plot&amp;quot; ## [28] &amp;quot;theme_cowplot&amp;quot; &amp;quot;theme_map&amp;quot; &amp;quot;theme_nothing&amp;quot; 查看函数包含了哪些参数</description></item><item><title>初次使用bookdown编写书籍</title><link>https://kongjianyang.github.io/cn/2018/11/28/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8bookdown%E7%BC%96%E5%86%99%E4%B9%A6%E7%B1%8D/</link><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/28/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8bookdown%E7%BC%96%E5%86%99%E4%B9%A6%E7%B1%8D/</guid><description>bookdown支持采用Rmarkdown (R代码可以运行)或普通markdown编写文档，然后编译成HTML, WORD, PDF, Epub等格式。
1. 基本使用 使用要求：
安装Rstudio 安装Pandoc conda install -c conda-forge pandoc 接下来需要到.Renviron中设置环境：
RSTUDIO_PANDOC=/Applications/RStudio.app/Contents/MacOS/pandoc 安装bookdown install.packages(&amp;#34;bookdown&amp;#34;) 下载demo：
git clone https://github.com/rstudio/bookdown-demo 然后进行编译，运行下载的示例中的bash _build.sh，_book目录下就是成书。
#!/bin/sh Rscript -e &amp;#34;bookdown::render_book(&amp;#39;index.Rmd&amp;#39;, &amp;#39;bookdown::gitbook&amp;#39;)&amp;#34; # 生成pdf需要安装好latex，如果不需要可以注释掉 Rscript -e &amp;#34;bookdown::render_book(&amp;#39;index.Rmd&amp;#39;, &amp;#39;bookdown::pdf_book&amp;#39;)&amp;#34; 如果想在Rstudio中进行预览：
bookdown:::serve_book(&amp;#34;./01Demo/bookdown-demo/&amp;#34;) 2. 文件格式 一个典型的bookdown文档包含多个章节，每个章节在一个R Markdown文件里面 (文件的语法可以是pandoc支持的markdown语法，但后缀必须为Rmd)。
每一个章节都必须以# Chapter title开头。后面可以跟一段概括性语句，概述本章的内容，方便理解，同时也防止二级标题出现在这一页。默认系统会按照文件名的顺序合并Rmd文件。
另外章节的顺序也可在_bookdown.yml文件中通过rmd_files:[&amp;quot;file1.Rmd&amp;quot;, &amp;quot;file2.Rmd&amp;quot;, ..]指定。
如果有index.Rmd，index.Rmd总是出现在第一个位置。通常index.Rmd里面也需要有一章节，如果不需要对这一章节编号的话，可以写作# Preface {-}, 关键是{-}。
在index.Rmd，可以定义Pandoc相关的YAML metadata, 比如标题、作者、日期等 (去掉#及其后的内容)。</description></item><item><title>编写自己的第一个R包并发布到GitHub</title><link>https://kongjianyang.github.io/cn/2018/11/28/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAr%E5%8C%85%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0github/</link><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/28/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAr%E5%8C%85%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0github/</guid><description>1. 编写R包 发现要深入了解一门语言要尝试给这个语言造轮子，所以就开始学习怎么开始写自己的第一个R包了。我习惯利用Rstudio编写R程序，所以在Rstudio中开发。
选择File -&amp;gt; New Project，然后选择New Directory，接着选择R Package，最后给你R包取个名字即可，如下图所示，可以选择git版本进行version control。我的包名称是Rtools。
RStudio会在当前目录（默认是个人目录下）创建一个R包文件夹，主要文件（夹）包括：man，R，DESCRIPTION，NAMESPACE以及xx.Rproj。下面是文件目录解释：
testR(包的名字，这里包的名字叫testR) | |--DESCRIPTION(描述文件，包括包的名字，版本号，标题，描述，依赖关系) |--R(函数源文件) |--function1.R |--function2.R |--... |--man(帮助文档) |--function1.Rd |--function2.Rd |--testR-package.Rd |--... |--NAMESPACE(命名空间) |--vignettes(包的描述文件，可以用rmarkdown写) |--src(非R脚本eg.C.C++,Python) |--data(R包中的数据，最好是.rda格式) |--demo(R包中的demo) |--test(R包中的测试代码) |--... DESCRIPTION文件写了这个R的描述信息，主要为了告诉别人（或者自己）这个R包的一些重要的元数据（官方说法），可以按照自己的需要进行修改：
Package: Rtools Type: Package Title: My First R Package Version: 0.1.0 Author: Liang Maintainer: The package maintainer &amp;lt;yourself@somewhere.net&amp;gt; Description: Just for learn License: GPL Encoding: UTF-8 LazyData: true RoxygenNote: 6.1.1 接下来需要准备好一个写好的R自定义函数，比如在R文件夹创建一个uniprot.R文件，然后将函数写入该文件；我们使用R包就是将输入参数导入函数中，然后函数给我们一个结果。比如我的函数如下：
idmapping &amp;lt;- function(query, inputid, outputid, fmt){ query &amp;lt;- paste(query, collapse = &amp;#34;,&amp;#34;) r &amp;lt;- httr::POST(&amp;#39;http://www.</description></item><item><title>R中进行文件以及文件系统管理</title><link>https://kongjianyang.github.io/cn/2018/11/25/r_files/</link><pubDate>Sun, 25 Nov 2018 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/25/r_files/</guid><description>本文中提到的文件系统管理主要是指文件和目录（即文件夹）的创建、查看、重命名、复制、删除和文件权限处理。
1. 文件操作 创建文件
# 创建一个空文件 A.txt file.create(&amp;quot;A.txt&amp;quot;) # 查看当前目录下的子目录和文件 list.files() # 创建多个空文件 A1.txt，A2.txt，A3.txt file.create(&amp;quot;A1.txt&amp;quot;, &amp;quot;A2.txt&amp;quot;, &amp;quot;A3.txt&amp;quot;) # 查看当前目录下的子目录和文件 list.files() # 创建一个有内容的文件 B.txt cat(&amp;quot;文件测试\n&amp;quot;, file = &amp;quot;B.txt&amp;quot;) list.files() 查看文件
# 显示当前目录中的目录和文件 ## 下面两句结果相同 list.files() # 建议使用该命令，方便记忆 dir() #python中这个意味着查看文件属性 ## 参数full.names = TRUE，确定文件显示全名 ## 参数recursive = TRUE，递归显示，即把目录下的目录和文件都以文件的形式显示 list.files(, full.names = TRUE, recursive = TRUE) # 检查文件是否存在 ## 存在的文件 file.exists(&amp;quot;A.txt&amp;quot;) ## 不存在的文件 file.exists(&amp;quot;readme.txt&amp;quot;) # 判断是否是文件 file_test(&amp;quot;-f&amp;quot;, &amp;quot;A.txt&amp;quot;) 读取文件
# 文件A.txt读取 readLines(&amp;quot;A.</description></item><item><title>R向文本文件插入内容</title><link>https://kongjianyang.github.io/cn/2018/11/25/r_inscert_content/</link><pubDate>Sun, 25 Nov 2018 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/25/r_inscert_content/</guid><description>1. 创造文件并写入 fileConn&amp;lt;-file(&amp;quot;./output.txt&amp;quot;) #创造一个文件 writeLines(c(&amp;quot;Hello&amp;quot;,&amp;quot;World&amp;quot;), fileConn) #写入内容到文件内 close(fileConn) 2. 替代方法 可以使用sink和cat命令写入文件
sink函数将输出结果重定向到文件。
使用方式：sink(file = NULL, append = FALSE, type = c(“output”, “message”),split = FALSE)
append参数：布尔值。TRUE时，输出内容追加到文件尾部。FALSE，覆盖文件原始内容。
cat函数即能输出到屏幕，也能输出到文件.
使用方式：cat(… , file = ““, sep =” “, fill = FALSE, labels = NULL,append = FALSE)
有file时，输出到file。无file时，输出到屏幕。
append参数：布尔值。TRUE时，输出内容追加到文件尾部。FALSE，覆盖文件原始内容。
sink(&amp;quot;./outfile2.txt&amp;quot;) cat(&amp;quot;hello\nworld&amp;quot;) ## hello ## world sink() 3. 替代方法2 R中还有一个write函数，可以直接写入内容到文件内
line=&amp;quot;hello\nworld&amp;quot; write(line,file=&amp;quot;./outfile3.txt&amp;quot;) 4. 插入文件到文本指定位置 创造文件
line=&amp;quot;hello\nworld&amp;quot; write(line,file=&amp;quot;./outfile3.txt&amp;quot;) 读取文件
txt_cont &amp;lt;- readLines(&amp;quot;./outfile3.txt&amp;quot;, warn=FALSE) length(txt_cont) ## [1] 2 在文件的第二行插入内容重新写入</description></item><item><title>Mac下使用crontab进行定时任务</title><link>https://kongjianyang.github.io/cn/2018/11/25/mac%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E8%BF%9B%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/25/mac%E4%B8%8B%E4%BD%BF%E7%94%A8crontab%E8%BF%9B%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid><description>1. 开启 crontab crontab意思是排程命令，查看 crontab 是否启动
sudo launchctl list | grep cron 检查需要的文件
ls -al /etc/crontab 如果 crontab 文件不存在则创建
sudo touch /etc/crontab 2. 添加定时任务 # 打开定时任务设定文件 crontab -e 举个例子, 每分钟输出当前时间到time.txt上.
*/1 * * * * /bin/date &amp;gt;&amp;gt; ~/Desktop/time.txt
查看任务列表
crontab -l 删除任务
# 打开定时任务设定文件 crontab -e 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。
删除crontab文件
crontab -r 可以加上邮件通知
# send email to me MAILTO=&amp;#34;your email stress&amp;#34; git push origin master 如果上步错误的话，可以用下面的命令
git remote set-url origin git@github.com:username/repo.git 3. 语法 格式：分 时 日 月 星期几 命令 # 每天12点1分执行[/example/laohou-cron.</description></item><item><title>Python下负责数据分析的库</title><link>https://kongjianyang.github.io/cn/2018/11/25/python%E4%B8%8B%E8%B4%9F%E8%B4%A3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%BA%93/</link><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/25/python%E4%B8%8B%E8%B4%9F%E8%B4%A3%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%BA%93/</guid><description>Numpy: 基础的数学计算模块，以矩阵为主,纯数学。
pandas 是基于 NumPy 的一个 Python 数据分析包，主要目的是为了数据分析。它提供了大量高级的数据结构和对数据处理的方法。 pandas 有两个主要的数据结构：Series 和 DataFrame。
Series = 一维数组 + 数据标签（索引） Series相当于数组numpy.array DataFrame是一个表格型的数据结构，是以一个或多个二维块存放的数据表格（层次化索引），DataFrame既有行索引还有列索引，它有一组有序的列，每列既可以是不同类型（数值、字符串、布尔型）的数据，或者可以看做有Series组成的字典。
Series: 一组数组（列表或元组），series除了一组数据外还包括一组索引（即只有行索引），索引可自行定义也可利用Series(),自动生成索引； dataframe: 是表格型数据，既有行索引又有列索引，每列数据可以为不同类型数据（数值、字符串、布尔型值），可利用DataFrame（其他数据，dataframe属性)指定dataframe的属性创建dataframe。
Pandas: 提供了一套名为DataFrame的数据结构，适合统计分析中的表结构,在上层做数据分析。
SciPy: 基于Numpy，提供方法(函数库)直接计算结果，封装了一些高阶抽象和物理模型。比方说做个傅立叶变换，这是纯数学的，用Numpy；做个滤波器，这属于信号处理模型了，在Scipy里找。
简洁的说:
NumPy：N维数组容器
SciPy：科学计算函数库
Pandas：表格容器
非数学研究,建议直接入手pandas,包含基础的Numpy方法。
matplotlib是基于Python语言的开源项目，旨在为Python提供一个数据绘图包。matplotlib是受MATLAB的启发构建的。MATLAB是数据绘图领域广泛使用的语言和工具。MATLAB语言是面向过程的。
Seaborn是基于matplotlib的Python可视化库。 它提供了一个高级界面来绘制有吸引力的统计图形。Seaborn其实是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，不需要经过大量的调整就能使你的图变得精致。但应强调的是，应该把Seaborn视为matplotlib的补充，而不是替代物。
sklearn是一个Python第三方提供的非常强力的机器学习库，它包含了从数据预处理到训练模型的各个方面。</description></item><item><title>-bash_profile和-bashrc的区别</title><link>https://kongjianyang.github.io/cn/2018/11/24/bash_profile%E5%92%8C-bashrc%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/bash_profile%E5%92%8C-bashrc%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>/etc/profile 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置。 /etc/bashrc 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。 ~/.bash_profile 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。 ~/.bashrc 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。 ~/.bash_logout 少见，但是意味着当每次退出系统(退出bash shell)时,执行该文件。
另外/etc/profile 中设定的变量(全局)的可以作用于任何用户, 而~/.bashrc 等中设定的变量(局部)只能继承 /etc/profile 中的变量,他们是&amp;quot;父子&amp;quot;关系。
profile用于登录式shell, 而bashrc用于每个交互式shell ~/.bash_profile 是交互式、login 方式进入 bash 运行的 ~/.bashrc 是交互式 non-login 方式进入 bash 运行的 通常二者设置大致相同，所以通常前者会调用后者。 所以一般优先把变量设置在.bashrc里面。比如在crontab里面执行一个命令，.bashrc 设置的环境变量会生效，而 .bash_profile 不会。
设置生效：可以重启生效，也可以使用命令：source
source /etc/profile</description></item><item><title>bedGraph，bed以及bam文件格式转换</title><link>https://kongjianyang.github.io/cn/2018/11/24/bedgraphbed%E4%BB%A5%E5%8F%8Abam%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/bedgraphbed%E4%BB%A5%E5%8F%8Abam%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</guid><description>感兴趣的基因信息包含在bedGraph文件中，下面命令是对其文件格式进行转换，一般进行到bam文件可视化的效果比较好。
1. bedGraph转bed文件 BedGraph ，的数据和bed文件很类似，ChIPseq数据做完peak calling后的bed文件最短只有三列，染色体序号，染色体起始位置和结束位置。如下所示，前面的声明和Wig类似，后面的四列分别表示染色体序号，起始位置，结束位置和value值。相当于为bed文件的延伸格式。
track type=bedGraph name=&amp;#34;BedGraph Format&amp;#34; description=&amp;#34;BedGraph format&amp;#34; visibility=full color=200,100,0 altColor=0,100,200 priority=20 chr19 49302000 49302300 -1.0 chr19 49302300 49302600 -0.75 chr19 49302600 49302900 -0.50 chr19 49302900 49303200 -0.25 chr19 49303200 49303500 0.0 chr19 49303500 49303800 0.25 chr19 49303800 49304100 0.50 chr19 49304100 49304400 0.75 chr19 49304400 49304700 1.00 所以我们想要得到bed文件只需要提取bedGraph的前三列即可，同时注意不要第一行，利用grep -v命令
# Convert bedGraph to bed file grep -v track GSM1252087_edm2-4_RNAseq.bedGraph | cut -f 1-3 &amp;gt; GSM1252087_edm2-4_RNAseq.bed 2.</description></item><item><title>blogdown建立网站</title><link>https://kongjianyang.github.io/cn/2018/11/24/blogdown%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%AB%99/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/blogdown%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%AB%99/</guid><description>https://d.cosx.org/d/419791-blogdown-netlify-non-zero-exist-code-255 https://cosx.org/2018/01/build-blog-with-blogdown-hugo-netlify-github/ https://testliang.netlify.com/</description></item><item><title>conda下多版本Python切换和配置</title><link>https://kongjianyang.github.io/cn/2018/11/24/conda%E4%B8%8B%E5%A4%9A%E7%89%88%E6%9C%ACpython%E5%88%87%E6%8D%A2%E5%92%8C%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/conda%E4%B8%8B%E5%A4%9A%E7%89%88%E6%9C%ACpython%E5%88%87%E6%8D%A2%E5%92%8C%E9%85%8D%E7%BD%AE/</guid><description>##1.问题 学习Python是目前十分火热的一个领域，但是Python3和Python2之间的切换和选择经常使人烦恼，多版本的Python之间经常会有冲突。解决这一问题的一个好的途径是安装anaconda进行环境和版本控制。
##2.教程 检测安装的conda版本，在终端输入命令：
conda --version Conda会返回你安装Anaconda软件的版本。
升级当前版本conda，输入命令：
conda update conda 更新conda到最新版本之后，利用conda进行环境管理
创建一个新环境：
conda create -n python3 激活新环境：
source activate python3 列出所有的环境：
conda info --envs 会列出所有的环境，当前环境前面有*符号
切换环境：
source activate base 返回原环境：
source deactivate 给新环境安装Python3：
conda create -n python3 python=3 检查环境内的Python版本：
python --version 检查环境内的包：
conda list 查找一个包是否能够安装：
conda search beautifulsoup4 告知安装环境的名字并安装这个包：
conda install --name base beautifulsoup4 移除安装的包，必须告知移除包的环境：
conda remove -n base beautifulsoup4 移除一个环境：
conda remove -n python3 --all ##3.总结 以上是使用conda的一些基本命令，使用conda可以帮助我们很好的管理Python及其依赖的包的环境。</description></item><item><title>dplyr包的join函数</title><link>https://kongjianyang.github.io/cn/2018/11/24/dplyr%E5%8C%85%E7%9A%84join%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/dplyr%E5%8C%85%E7%9A%84join%E5%87%BD%E6%95%B0/</guid><description>dplyr中有非常多非常有用的功能，例如filter()，arrange()，select()，mutate()，group_by()。但是这篇教程是谈join函数。
join函数在dplyr包中是个系列函数。 join函数：
join(x, y, by = NULL, copy = FALSE, ...) x,y 为合并的数据框，不要求x,y中排序列唯一 by 为排序依据，默认值Null时按名字相同的量匹配,此时,要求必须有相同列名的列 join为系列函数，包括inner_join、left_join、semi_join和anti_join函数 full_join() full_join连接后的记录数等于”共有的记录数+a独有的记录数+b独有的记录数“，结果可以理解为a、b的并集。
inner_join inner_join连接后的记录数等于”共有的记录数“， 也就是5，结果可以理解为a、b的交集，R语言中的merge函数也可以实现。
left_join left_join连接后的记录数等于”a的记录数“，当然，a是需要放在第一个参数。
right_join right_join连接后的记录数等于”b的记录数“。</description></item><item><title>ggplot排列自己生成的图片顺序</title><link>https://kongjianyang.github.io/cn/2018/11/24/ggplot%E6%8E%92%E5%88%97%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E9%A1%BA%E5%BA%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/ggplot%E6%8E%92%E5%88%97%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E7%89%87%E9%A1%BA%E5%BA%8F/</guid><description>Laying out multiple plots on a page</description></item><item><title>GitHub上删除或者unfork-Repository</title><link>https://kongjianyang.github.io/cn/2018/11/24/github%E4%B8%8A%E5%88%A0%E9%99%A4%E6%88%96%E8%80%85unfork-repository/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/github%E4%B8%8A%E5%88%A0%E9%99%A4%E6%88%96%E8%80%85unfork-repository/</guid><description>01. 原因 在刚开始学习使用GitHub的时候创建了很多的Repository，也fork了很多别人的库，随着自己的学习很多的库自己不再需要了，这时候需要删除不感兴趣的库，以下是解决步骤。
02. 解决 1、进入想要删除的资源库(Repository)，选择资源库的“Settings”
2、进入settings页后，下拉到最下面，会看到Danger Zone区域
3、点击“Delete this repository”，输入repository的名称就可以删除了。
如果以上操作作用于fork后的项目，相对于做了一个unfork(取消fork)操作。</description></item><item><title>git取消链接并删除本地库</title><link>https://kongjianyang.github.io/cn/2018/11/24/git%E5%8F%96%E6%B6%88%E9%93%BE%E6%8E%A5%E5%B9%B6%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%BA%93/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/git%E5%8F%96%E6%B6%88%E9%93%BE%E6%8E%A5%E5%B9%B6%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%BA%93/</guid><description>有的时候我们需要删除从GitHub上克隆下来的库
从github上clone一个仓库：
git clone git@github.com:USERNAME/repo.git 在本地目录下关联远程repository
git remote add origin git@github.com:git_username/repository_name.git 取消本地目录下关联的远程库
git remote remove origin 删除本地库
Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ git branch #显示本地所有分支 * master Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ git init 1#初始化仓库 Reinitialized existing Git repository in D:/Program Files/Git/gitskills/gitskills/.git/ Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ ls -a 2#查看内部文件 ./ ../ .git/ README.md Quincy_C@Quincy MINGW64 /gitskills/gitskills (master) $ rm -rf .git 3#强删.git Quincy_C@Quincy MINGW64 /gitskills/gitskills $ ls -a 4#查看内部文件 .</description></item><item><title>heatmap-2聚类之后得到行名</title><link>https://kongjianyang.github.io/cn/2018/11/24/heatmap-2%E8%81%9A%E7%B1%BB%E4%B9%8B%E5%90%8E%E5%BE%97%E5%88%B0%E8%A1%8C%E5%90%8D/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/heatmap-2%E8%81%9A%E7%B1%BB%E4%B9%8B%E5%90%8E%E5%BE%97%E5%88%B0%E8%A1%8C%E5%90%8D/</guid><description>1.问题 heatmap.2是一种绘画热图的gplots包中的一个功能，十分强大，得到一个精美的热图，命令行不超过20行。
有一个不方便的地方是得到这份热图之后希望知道聚类之后的行名以及具体的数值，以备后续的分析。
2.解决 查阅之后可以通过以下方法进行解决. 首先制造一个绘图的矩阵
y &amp;lt;- matrix(rnorm(50), 10, 5, dimnames=list(paste(&amp;#34;g&amp;#34;, 1:10, sep=&amp;#34;&amp;#34;), paste(&amp;#34;t&amp;#34;, 1:5, sep=&amp;#34;&amp;#34;))) 按行进行聚类
hr &amp;lt;- hclust(as.dist(1-cor(t(y), method=&amp;#34;pearson&amp;#34;)), method=&amp;#34;complete&amp;#34;) 按列进行聚类
hc &amp;lt;- hclust(as.dist(1-cor(y, method=&amp;#34;spearman&amp;#34;)), method=&amp;#34;complete&amp;#34;) 绘制热图
library(gplots) heatmap.2(y, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc), scale=&amp;#34;row&amp;#34;, density.info=&amp;#34;none&amp;#34;, trace=&amp;#34;none&amp;#34;) 得到聚类之后的矩阵结果：
y[rev(hr$labels[hr$order]), hc$labels[hc$order]]</description></item><item><title>Jupyter-Notebook进阶使用教程</title><link>https://kongjianyang.github.io/cn/2018/11/24/jupyter-notebook%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/jupyter-notebook%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><description>1.前略 读博之路上不打算每天都全心全意的投入到老板给的课题中了，晚上八点到十一点学习点新东西。
2. 起因 最近打算好好学习下统计学和机器学习方面的知识，我的习惯是学习新内容前需要有好的记录工具，否则就坚持不下去，容易气馁。之前学习R语言的时候爱上了Rstudio和Rmd这种交互式文档语言(interactive language)，但是因为R更多的是用来做统计分析的，功能还是比较薄弱，不能适应复杂的任务，因此需要开辟新的语言进行学习，之前也学习过python，了解其语法，但是没有坚持的原因有两点，其一本科的时候没有项目进行练手，其二是因为没有找到合适自己的IDE。现在重新学习语言，找到了Jupyter Notebook，类似与Rstudio一样可以做到所写即所得。所以开始熟悉怎么使用Jupyter Notebook，将一些技巧记录在此。
3.技巧 3.1 配置及打开 安装方法之类的不多讲，安装之后希望在任何地方打开Jupyter的话在Terminal下cd到目标文件夹，键入Jupyter Notebook自然能在你的浏览器下打开Jupyter，则工作目录即为你的目标目录。
希望查看Jupyter的配置文件的话键入jupyter notebook --generate-config则能看到配置文件。
3.2 加载本地.py文件 还可以将本地的.py文件load到jupyter的一个cell中 例如有一个test.py文件，需要将其载入到jupyter的一个cell中 test.py内容如下：
import caffe SolverName = &amp;#34;/root/workspace&amp;#34; sovler = caffe.AdamSolver(SolverName) 在需要导入该段代码的cell中只需要输入如下
%load test.py #test.py是当前路径下的一个python文件 3.3 作为unix command使用 jupyter的cell还可以作为unix command使用，具体方法为：在unix command前面加入一个感叹号“！”
例子： 查看python版本：!python --version 运行python文件：!python myfile.py 3.4 添加目录功能 还可以为Jupyter Notebook添加目录功能，原始的Jupyter是不支持markdown添加目录功能的，实际上，可以利用Jupyter notebook extensions 去使得这种功能实现，具体方法：  `conda install -c conda-forge jupyter_contrib_nbextensions` 打开Jupyter Notebook，在它的（新增的）Nbextensions标签下勾选“Table of Contents(2)” ，关于extensions还有很多其他的功能可以自行查看。
3.5 魔法命令 (magic function) 所有以%开头的方法，都是Jupyter里面的所谓魔术方法(Magic function)，也就是ipython内置的一些方法。需要注意的是，魔术方法有%和%%之分，比如%timeit和%%timeit。在ipython中有专门的叫法，前者叫line magic后者叫cell magic。顾名思义，前者是专门针对一行的命令，后者针对多行的命令。</description></item><item><title>Jupyter不显示warming-message</title><link>https://kongjianyang.github.io/cn/2018/11/24/jupyter%E4%B8%8D%E6%98%BE%E7%A4%BAwarming-message/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/jupyter%E4%B8%8D%E6%98%BE%E7%A4%BAwarming-message/</guid><description>运行Jupyter notebook的时候偶尔会提醒有错误信息，让人很烦恼，解决这个问题只需要在cell行内添加一下命令。
#隐藏警告 import warnings warnings.filterwarnings(&amp;#39;ignore&amp;#39;)</description></item><item><title>KEGG数据库</title><link>https://kongjianyang.github.io/cn/2018/11/24/kegg%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/kegg%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>1. 简介 KEGG(Kyoto Encyclopedia of Genes and Genomes)是系统分析基因功能、基因组信息数据库，它有助于研究者把基因及表达信息作为一个整体网络进行研究。KEGG主要包含以下数据库： 其中在 KEGG PATHWAY 数据库中，将生物代谢通路划分为 6 类，分别为：细胞过程（Cellular Processes）、环境信息处理（Environmental Information Processing）、遗传信息处理（Genetic Information Processing）、人类疾病（Human Diseases）、新陈代谢（Metabolism）、生物体系统（Organismal Systems），其中每类又被系统分类为二、三、四层。第二层目前包括有 43 种子 pathway；第三层即为其代谢通路图；第四层为每个代谢通路图的具体注释信息。
2. 探索 首先打开KEGG数据库，你会进入下面这个界面，我们直奔主题，点击KEGG PATHWAY。 点击三级分类的通路，就可以找到我们想要的pathway map了。比如点击三级分类pathway map 的“cell cycle”，然后就进入了下面这样的界面。
一般默认是人的pathway，如果你像查看其他物种上的pathway，你需要点击下拉三角形，选择你所关心的物种。如下面图中所示
KEGG pathway中有着大量的通路图，以PI3K-Akt signaling pathway（ko04151）为例，里面包含了大量的蛋白等化合物，以及它们之间相互作用的关系。
3. 看图说话 在KEGG中有两种代谢图
参考代谢通路图reference pathway，是根据已有的知识绘制的概括的、详尽的具有一般参考意义的代谢图，这种图上就不会有绿色的小框，而都是无色的，所有的框都可以点击查看更详细的信息；
特定物种的代谢图species-specific pathway，会用绿色来标出这个物种特有的基因或酶，只有这些绿色的框点击以后才会给出更详细的信息。
这两种图很好区分，reference pathway 在KEGG中的名字是以map开头的，比如map00010，就是糖酵解途径的参考图；而特定物种的代谢通路图开头三个字符不是map而是种属英文单词的缩写（应该就是一个属的首字母+2个种的首字母）比如酵母的糖酵解通路图，就是sce00010，大肠杆菌的糖酵解通路图就应该是eco00010。 代谢通路中各种符号标识 ：
K+num：基因ID号，表示在所有同源物种中具有相似结构或功能的一类同源蛋白 ko+num： 代谢通路名称，表示一个特定的生物路径 M+ num： 模块名称 C+ num： 化合物名称 E-,-,-,-： 酶名称 R + num : 反应名 RC+ num ： 反映类型 RP+num： 反应物对 图例作用关系：</description></item><item><title>linux下ls的一些操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8Bls%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8Bls%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</guid><description>只显示隐藏文件夹
ls -d .* # -d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表； 按照文件大小排序
ls -lS #从大到小 ls -lSr #从小到大 寻找指定时间文件并移动
find ./ -mmin -60 | xargs -I {} cp {} ../</description></item><item><title>Linux下批量修改文件名</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</guid><description>方法一：Rename函数 Linux下修改文件名有mv和rename。其中mv命令只能对单个文件重命名，这是mv命令和rename命令的在重命名方面的根本区别。
linux的rename命令有两个版本，一个是c语言版本的，一个是perl语言版本的，判断方法： 输入man rename 看到第一行是： RENAME(1) Linux Programmer’s Manual RENAME(1) 这个就是C语言版本的 而如果出现： RENAME(1) Perl Programmers Reference Guide RENAME(1) 则是Perl版本的了
C语言版本格式：rename 原字符串 新字符串 文件名 Perl语言版本格式：rename &amp;rsquo;s/原字符串/新字符串/&amp;rsquo; 文件名
rename支持正则表达式
例子：
字母的替换rename &amp;quot;s/AA/aa/&amp;quot; * //把文件名中的AA替换成aa 修改文件的后缀rename &amp;quot;s//.html//.php/&amp;quot; * //把.html 后缀的改成 .php后缀 批量添加文件后缀rename &amp;quot;s/$//.txt/&amp;quot; * //把所有的文件名都以txt结尾 批量删除文件名rename &amp;quot;s//.txt//&amp;quot; * //把所有以.txt结尾的文件名的.txt删掉
方法二：mv函数 在文件夹shell下创建文件10个文件 touch tmp_{1..10}.txt 找到含有“_“”的文件夹。 find ./ -name &amp;#34;*_*&amp;#34; 读取id, 用mv改名，$为自己理解为赋值后的id，格式为while； do； done find ./ -name &amp;#34;*_*&amp;#34; | while read id; do mv $id ${id/_/-}; done</description></item><item><title>Linux下查看文件命令选择</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E9%80%89%E6%8B%A9/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E9%80%89%E6%8B%A9/</guid><description>Linux内有三大命令可以用来查看文件内容，分别是cat、more、和less，他们之间既有共同点又有区别，例如：cat可以一次性显示整个文件的内容，还可以将多个文件连接起来显示，常与重定向符号配合使用，适用于文件内容少的情况，而more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。more比cat强大，提供分页显示的功能，less比more更强大，提供翻页，跳转，查找等命令。而且more和less都支持：用空格显示下一页，按键b显示上一页。下面详细介绍这3个命令。
1. cat cat命令比较简单，比较常用
cat主要有三大功能：
1.一次显示整个文件:cat filename 2.从键盘创建一个文件:cat &amp;gt; filename 只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件:cat file1 file2 &amp;gt; file 对非空输出行编号，使用cat -b命令：
[root@localhost test]# cat -b log2012.log log2013.log log.log 1 2012-01 2 2012-02 3 ====== 4 2013-01 5 2013-02 6 2013-03 输出所有行号，使用cat -n命令：
[root@localhost test]# cat -n log.log 1 2012-01 2 2012-02 3 4 5 ====== 2. more more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。
常用命令
Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 v 调用vi编辑器 !</description></item><item><title>Linux下递归查找某文件并移动</title><link>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E6%9F%90%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/linux%E4%B8%8B%E9%80%92%E5%BD%92%E6%9F%A5%E6%89%BE%E6%9F%90%E6%96%87%E4%BB%B6%E5%B9%B6%E7%A7%BB%E5%8A%A8/</guid><description>Linux下递归查找某类型文件可以使用find命令，例如我想查找所有的.sh文件，可以使用一下命令
find . -name &amp;#34;*.sh&amp;#34; 而如果我们希望移动所有这类型的文件到指定文件夹，在zsh下可以使用
cp **/*.sh sh_file</description></item><item><title>MacOS下最简单的升级R和R包的方式</title><link>https://kongjianyang.github.io/cn/2018/11/24/macos%E4%B8%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%87%E7%BA%A7r%E5%92%8Cr%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/macos%E4%B8%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%87%E7%BA%A7r%E5%92%8Cr%E5%8C%85%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>升级R #安装devtools包（如果已经安装 跳过此步，进入到下一步） install.packages(&amp;#39;devtools&amp;#39;) library(&amp;#39;devtools&amp;#39;) #安装updateR install_github(&amp;#39;andreacirilloac/updateR&amp;#39;) library(updateR) #更新 updateR(admin_password = &amp;#39;os_admin_user_password&amp;#39;) Reference:
UpdateR package: update R version with a function (on MAC OSX) 升级R包 使用rvcheck::update_all()可以自动更新CRAN, Bioconductor和Github上的R包。其实可以放到系统任务里，每月自动更新一次，然后就可以完全不用管升级的事情。</description></item><item><title>macOS利用brew安装tree命令</title><link>https://kongjianyang.github.io/cn/2018/11/24/macos%E5%88%A9%E7%94%A8brew%E5%AE%89%E8%A3%85tree%E5%91%BD%E4%BB%A4/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/macos%E5%88%A9%E7%94%A8brew%E5%AE%89%E8%A3%85tree%E5%91%BD%E4%BB%A4/</guid><description>01.问题 tree命令可以显示文件夹下的文件结构，是非常好用的一个命令工具，但是不是Unix的built-in命令，需要自行安装，本来利用Homebrew安装既可，但是macOS会报错，如
xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun 02.原因 这个问题产生的原因是没有更新OS X El Capitan，在MAC下，git命令是在Xcode命令工具下的。
###03.解决 首先就是升级OS X El Capitan，使用命令：
xcode-select --install 然后安装tree命令：
brew install tree 已经安装上了tree命令了。</description></item><item><title>macOS系统下各文件夹详解</title><link>https://kongjianyang.github.io/cn/2018/11/24/macos%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/macos%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/</guid><description>macOS是一个基于UNIX核心的系统，增强了系统的稳定性、性能以及响应能力。下图就介绍了macOS，Windows和Linux系统之间的区别
1. 符合unix传统的目录 /bin 传统unix命令的存放目录，如ls，rm，mv等。 /sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 /usr 第三方程序安装目录。 /usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）. /etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 /dev 设备文件存放目录，如何代表硬盘的/dev/disk0。 /tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 /var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 2. OS X系统特有的目录。 /Applications 应用程序目录，默认所有的GUI应用程序都安装在这里； /Library 系统资源库，系统的数据文件、帮助文件、文档等等； 比如字体、ColorSync 配置、偏好设置以及插件都应该安装在 Library 目录下适当的子目录中。 Application Support包含了应用相关的数据以及支持文件，比如第三方的插件，帮助应用，模板以及应用使用到但是并不需要用来支持运行的额外资源文件。按照惯例，所有这些内容都会被存储在以应用名称命名的子目录当中。 Assistants包含了帮助用户进行配置或者其它任务的程序。 Documentation包含了供计算机用户和管理员参考的文档文件和 Apple 帮助包。(Apple 帮助包在Help 子目录当中。) 在本地域中，这个目录包含了 Apple 公司发布的帮助包(不包括开发者文档)。 Extensions包含了设备驱动和其它内核扩展。(只存在于系统域当中。) Favorites包含了指向经常访问的文件夹、文件或者网站的别名。(仅仅存在于用户域当中。)
/Network 网络节点存放目录； /System 他只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 /System/Library/Extensions其实这裡就是用作存放硬件驱动的地方,苹果不称驱动程序为driver, 而是称为Extension. /System/Library/HelpViewer一切和Mac OS Help有关的档案及文件都存放于此 System/Library/CoreServices/Finder.app这个比较特别, 因为这是一个应用而非一个档桉夹, Finder.app可说是负责掌控整个OS上的一切资源. /System/Library/CoreServices/Menu ExtrasStatus bar上面所有系统自带工具的原文件，双击打开可以直接在status bar上添加相应文件 /System/Library/CoreServices/Software Update这裡就是负责Software update的地方 /Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 /Volumes 文件系统挂载点存放目录。 /cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。</description></item><item><title>matplotlib-finance查找库位置并从GitHub安装库</title><link>https://kongjianyang.github.io/cn/2018/11/24/matplotlib-finance%E6%9F%A5%E6%89%BE%E5%BA%93%E4%BD%8D%E7%BD%AE%E5%B9%B6%E4%BB%8Egithub%E5%AE%89%E8%A3%85%E5%BA%93/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/matplotlib-finance%E6%9F%A5%E6%89%BE%E5%BA%93%E4%BD%8D%E7%BD%AE%E5%B9%B6%E4%BB%8Egithub%E5%AE%89%E8%A3%85%E5%BA%93/</guid><description>1. 问题 尝试用python 做个股票绘图软件，要用到finance库，于是开始导入：
import matplotlib.finance as mpf 结果执行的时候直接报错：
ImportError: No module named finance 开始还没有安装模块，就专门装了个 finance 模块，使用 import finance 导入，错误倒是没有了，但是 finance 中没有想要的函数，根本无法导出股票数据。去查看 matplotlib 的文档说明，在matplotlib2.2.2的API中有这么一段话：
The matplotlib.finance, mpl_toolkits.exceltools and mpl_toolkits.gtktools modules have been removed. matplotlib.finance remains available at https://github.com/matplotlib/mpl_finance .
finance这个模块竟然被删除了！！！并且就是从2.2.2版本开始
2. 解决 查找matplotlib安装位置
import matplotlib print matplotlib.__file__ 进入到该位置下从GitHub下载库
git clone git@github.com:matplotlib/mpl_finance.git #安装 python setup.py install 安装好之后需要重启Jupyter notebook。 加载库
import mpl_finance as mpf</description></item><item><title>NCBI上基因组文件格式及解释.h</title><link>https://kongjianyang.github.io/cn/2018/11/24/ncbi%E4%B8%8A%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8A%E8%A7%A3%E9%87%8A.h/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/ncbi%E4%B8%8A%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8A%E8%A7%A3%E9%87%8A.h/</guid><description>NCBI上基因组文件格式及解释 body { margin: 0; font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif; font-size: 14px; line-height: 20px; color: #777; background-color: white; } .container { width: 700px; margin-right: auto; margin-left: auto; } .post { font-family: Georgia, "Times New Roman", Times, "SimSun", serif; position: relative; padding: 70px; bottom: 0; overflow-y: auto; font-size: 16px; font-weight: normal; line-height: 25px; color: #515151; } .post h1{ font-size: 50px; font-weight: 500; line-height: 60px; margin-bottom: 40px; color: inherit; } .</description></item><item><title>Pandas分组函数：groupby、pivot_table及crosstab</title><link>https://kongjianyang.github.io/cn/2018/11/24/pandas%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0groupbypivot_table%E5%8F%8Acrosstab/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/pandas%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0groupbypivot_table%E5%8F%8Acrosstab/</guid><description>1. 起因 利用python的pandas库进行数据分组分析十分便捷，其中应用最多的方法包括：groupby、pivot_table及crosstab，以下分别进行介绍。
2. 详解 首先构造数据
import numpy as np import pandas as pd df = pd.DataFrame({&amp;#39;key1&amp;#39;:[&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;a&amp;#39;],&amp;#39;key2&amp;#39;:[&amp;#39;one&amp;#39;,&amp;#39;two&amp;#39;,&amp;#39;one&amp;#39;,&amp;#39;two&amp;#39;,&amp;#39;one&amp;#39;],&amp;#39;data1&amp;#39;:np.random.randn(5),&amp;#39;data2&amp;#39;:np.random.randn(5)}) 2.1 group函数 分组groupby Pandas中最为常用和有效的分组函数。
1）按列分组
注意以下使用groupby()函数生成的group1是一个中间分组变量，为GroupBy类型。
group1 = df.groupby(&amp;#39;key1&amp;#39;) group2 = df.groupby([&amp;#39;key1&amp;#39;,&amp;#39;key2&amp;#39;]) 使用推导式[x for x in group1]可显示分组内容。
[x for x in group1] [(&amp;#39;a&amp;#39;, data1 data2 key1 key2 0 1.830651 0.407903 a one 1 -0.973132 -0.056084 a two 4 -1.069184 0.043338 a one), (&amp;#39;b&amp;#39;, data1 data2 key1 key2 2 -0.477718 -1.488174 b one 3 -0.</description></item><item><title>purrr中Reduce和map拓展函数式编程</title><link>https://kongjianyang.github.io/cn/2018/11/24/purrr%E4%B8%ADreduce%E5%92%8Cmap%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/purrr%E4%B8%ADreduce%E5%92%8Cmap%E6%8B%93%E5%B1%95%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid><description>purrr 是一个拓展R函数式编程能力的包。在这篇文章中，介绍在purrr中几个非常实用的函数。
purrr已经集成在tidyverse中，所以如果已经安装了tidyverse的话则不需要重复安装了。
1. map 家族 1.1 map函数 library(purrr) numbers &amp;lt;- list(11, 12, 13, 14) map(numbers, sqrt) 得到的结果如下，返回一个列表
[[1]] [1] 3.316625 [[2]] [1] 3.464102 [[3]] [1] 3.605551 [[4]] [1] 3.741657 1.2 map_dbl函数 map_dbl(numbers, sqrt) 返回一个实数原子列表(atomic list)
[1] 3.316625 3.464102 3.605551 3.741657 1.3 map_if函数 map_if函数会对于list进行一个逻辑判断，如果是真则执行命令，否则不执行，保留原值。
#创造一个辅助函数，如果为偶数则返回TRUE is_even &amp;lt;- function(x){ !as.logical(x %% 2) } map_if(numbers, is_even, sqrt) [[1]] [1] 11 [[2]] [1] 3.464102 [[3]] [1] 13 [[4]] [1] 3.741657 1.4 map_at函数 map_at函数是给定位置向量，然后执行命令。</description></item><item><title>Python中mechanize模块练习</title><link>https://kongjianyang.github.io/cn/2018/11/24/python%E4%B8%ADmechanize%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/python%E4%B8%ADmechanize%E6%A8%A1%E5%9D%97%E7%BB%83%E4%B9%A0/</guid><description>Part 1 An introduction about mechanize
import mechanize br = mechanize.Browser() br.open(&amp;#34;http://www.example.com/&amp;#34;) &amp;lt;response_seek_wrapper at 0x109db3170 whose wrapped object = &amp;lt;closeable_response at 0x109d4a5f0 whose fp = &amp;lt;socket._fileobject object at 0x109d386d0&amp;gt;&amp;gt;&amp;gt; response1 = br.follow_link() assert br.viewing_html() print br.title() IANA — IANA-managed Reserved Domains print response1.geturl() https://www.iana.org/domains/reserved print response1.info() #headers Date: Fri, 13 Jul 2018 14:51:52 GMT X-Frame-Options: SAMEORIGIN Referrer-Policy: origin-when-cross-origin Content-Security-Policy: upgrade-insecure-requests Vary: Accept-Encoding Last-Modified: Tue, 21 Jul 2015 00:49:48 GMT Cache-control: public, s-maxage=900, max-age=7202 Expires: Fri, 13 Jul 2018 16:51:52 GMT Content-Type: text/html; charset=UTF-8 Server: Apache Strict-Transport-Security: max-age=48211200; preload X-Cache-Hits: 18 Accept-Ranges: bytes Content-Length: 10225 Connection: close content-type: text/html; charset=utf-8 print response1.</description></item><item><title>python的global函数以及LEGB原则</title><link>https://kongjianyang.github.io/cn/2018/11/24/python%E7%9A%84global%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Alegb%E5%8E%9F%E5%88%99/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/python%E7%9A%84global%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Alegb%E5%8E%9F%E5%88%99/</guid><description>1. 起因 两小段代码的故事：
def myFunc(): B = 10 def inFunc(A): global B B = A ** 5 return B B = 25 myFunc() print B def myFunc(): B = 10 def inFunc(A): global B B = A ** 5 inFunc(B) return B B = 25 myFunc() print B 你能不运行代码直接告诉这两个小代码的结果么？
2. 解释 python中的局部变量和全局变量。
全局变量：所有函数之外定义的变量 局部变量：函数内部定义的变量 或者代码块里的变量
1.函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义了一个局部变量，不管全局域中有没有该变量名，函数中使用的将是局部变量。
(即声明了一个新的局部变量。如果这个变量名字和全部变量名字相同，那么局部变量名字会覆盖全局变量名字）
#[demo1] num = 100 def func(): newValue = 123 #一个全新的局部变量newValue print(newValue) func() #输出局部变量newValue 即新的局部变量 #[demo2] num = 100 def func(): num= 123 #声明一个全新的局部变量num，虽然名字和外界的全部变量相同 但是是新的一个变量且是局部有效的。屏蔽了外面的同名的全部变量 print(num) func() #输出局部变量num=123 即新的局部变量。 2.</description></item><item><title>Python绘图和可视化</title><link>https://kongjianyang.github.io/cn/2018/11/24/python%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/python%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><description>Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib和基于它的库。matplotlib的目的是为Python构建一个MATLAB式的绘图接口。在Jupyter notebook中执行下面的语句：
%matplotlib notebook import matplotlib.pyplot as plt import numpy as np data = np.arange(10) data plt.plot(data) matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure： 如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。
不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：
# 代码的意思是：图像应该是2×2的（即最多4张图）， # 且当前选中的是4个subplot中的第一个（编号从1开始）。 # 如果再把后面两个subplot也创建出来，最终得到的图像如图所示： fig = plt.figure() ax1 = fig.add_subplot(2, 2, 1) ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 3) 使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。 加的绘图命令会在最后一个subplot上.
fig = plt.figure() ax1 = fig.add_subplot(2, 2, 1) ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 3) plt.plot(np.random.randn(50).cumsum(), &amp;#39;k--&amp;#39;) #plt.plot(np.random.randn(50).cumsum(), &amp;#39;k--&amp;#39;) # ax1.</description></item><item><title>R中利用aggregate函数进行多因子统计</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%88%A9%E7%94%A8aggregate%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%A4%9A%E5%9B%A0%E5%AD%90%E7%BB%9F%E8%AE%A1/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%88%A9%E7%94%A8aggregate%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%A4%9A%E5%9B%A0%E5%AD%90%E7%BB%9F%E8%AE%A1/</guid><description>1.介绍 R中aggregate函数的功能强大，它首先将数据进行分组（按行），然后对每一组数据进行函数统计，最后把结果组合成一个比较nice的表格返回。简单说有点类似sql语言中的group by，可以按照要求把数据打组聚合，然后对聚合以后的数据进行加和、求平均等各种操作。
2.详解 通过 mtcars 数据集的操作对这个函数进行简单了解。mtcars 是不同类型汽车道路测试的数据框类型数据：
str(mtcars) &amp;#39;data.frame&amp;#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.</description></item><item><title>R中利用unite函数进行列合并</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%88%A9%E7%94%A8unite%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%88%97%E5%90%88%E5%B9%B6/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%88%A9%E7%94%A8unite%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%88%97%E5%90%88%E5%B9%B6/</guid><description>1. 介绍 unite函数是tidyr包中的一个非常实用的函数，和separate函数相对应，可以对于数据框进行按照格式的列合并。
2.用法 下面实用例子介绍unite函数的用法：
library(tidyr) name1 &amp;lt;- c(&amp;#34;Bob&amp;#34;,&amp;#34;Mary&amp;#34;,&amp;#34;Jane&amp;#34;,&amp;#34;Kim&amp;#34;) birth &amp;lt;- c(&amp;#34;1990-1&amp;#34;,&amp;#34;1980-2&amp;#34;,&amp;#34;1995-5&amp;#34;,&amp;#34;1996-4&amp;#34;) df &amp;lt;- data.frame(name1, birth) 构造一个名为df的数据框，df结构如下： 下面我们想将birth列和name1列以-进行合并，可以使用unite函数了， unite语法如下：
unite(data, col, ..., sep = &amp;#34;_&amp;#34;, remove = TRUE) 利用该语法，我们将name1和birth列按照-进行合并，合并结果存到新的列name-birth中，并保留原始的列。
unite(df,&amp;#34;name-birth&amp;#34;,c(&amp;#34;name1&amp;#34;,&amp;#34;birth&amp;#34;), sep=&amp;#34;-&amp;#34;, remove = F) 合并的结果如下： 3.总结 tidyr包中有很多类似的功能强大的函数，这只是用来进行列合并的其中一列，当然会有很多其他的方法，会在之后详解</description></item><item><title>R中将循环产生的数据框合并</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%B0%86%E5%BE%AA%E7%8E%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A1%86%E5%90%88%E5%B9%B6/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E5%B0%86%E5%BE%AA%E7%8E%AF%E4%BA%A7%E7%94%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A1%86%E5%90%88%E5%B9%B6/</guid><description>##1.问题 今天利用R写循环的时候出现了一个问题，循环内会产生多个数据框，希望将这多个数据库合并并生产一个最终的数据框，最后利用了list和do.call()功能进行了实现。
##2.解决 例如假设我们有如下三个数据框
df1 &amp;lt;- data.frame(cell=c(1,2,3),val=c(345,123,466)) df2 &amp;lt;- data.frame(cell=c(67,3,2),val=c(234,234,56)) df3 &amp;lt;- data.frame(cell=c(3,67,23),val=c(23,8,34)) 现在我们希望将这三个数据框进行合并： 首先创建一个空list，利用get()将所有数据框写入，形成一个2维的list，然后利用do.call()进行合并。
l &amp;lt;- list() for(i in 1:3){ df.now &amp;lt;- get(paste0(&amp;#34;df&amp;#34;,i)) l[[i]] &amp;lt;- df.now } do.call(rbind,l) 经过评论提醒，还有一种方法可能会显得更加易于理解些，即先形成一个空的data.frame，然后直接利用rbind将变量数据框合并到最终的数据框中。
l &amp;lt;- data.frame() for(i in 1:3){ df.now &amp;lt;- get(paste0(&amp;#34;df&amp;#34;,i)) l &amp;lt;- rbind(l, df.now) } 两种方法最后得到的结果都是：
cell val 1 1 345 2 2 123 3 3 466 4 67 234 5 3 234 6 2 56 7 3 23 8 67 8 9 23 34 ##3.</description></item><item><title>R中的BiocParallel和parallel包</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84biocparallel%E5%92%8Cparallel%E5%8C%85/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84biocparallel%E5%92%8Cparallel%E5%8C%85/</guid><description>https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Introduction_To_BiocParallel.pdf</description></item><item><title>R中的S3和S4简介</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84s3%E5%92%8Cs4%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84s3%E5%92%8Cs4%E7%AE%80%E4%BB%8B/</guid><description>R语言有四大类型系统：基础类型、S3类型、S4类型和RC类型。
R虽然被认为是一种函数式语言，但是同样支持面向对象编程，意味着R将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性，灵活性和扩展性。
S3 S3是想了一种基于泛型函数的面对对象方式。泛型函数可以根据传入对象的类型决定调用哪种具体的方法。因为这样对于初学者而言更加容易理解 例如
result &amp;lt;- mean(v1) 要比
result = v1.mean() 更加容易理解。
S3对象是一个list并且有一个名为class的属性，举例说明创建一个foo类的对象并且用class查看他的类
x &amp;lt;- 1 attr(x, &amp;#34;class&amp;#34;) &amp;lt;- &amp;#34;foo&amp;#34; x [1] 1 attr(,&amp;#34;class&amp;#34;) [1] &amp;#34;foo&amp;#34; class(x) [1] &amp;#34;foo&amp;#34; S3没有正式的类型间关系的定义，一个对象可以有多个类型，表现为其class属性是一个向量
class(x) &amp;lt;- c(&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;) class(x) [1] &amp;#34;foo&amp;#34; &amp;#34;bar&amp;#34; 方法分派是指由泛型函数 (generic function) 来决定对某个对象使用的方法. 所有泛型函数都有类似的形式: 一个广义的函数名, 并调用 UseMethod() 来决定为对象分派哪个方法. 这也使得泛型函数的形式都很简单, 比如 mean()
mean function (x, ...) UseMethod(&amp;#34;mean&amp;#34;) &amp;lt;bytecode: 0x103792920&amp;gt; &amp;lt;environment: namespace:base&amp;gt; UseMethod() 会根据对象的 class 属性来决定分派什么方法,所以方法必须以 generic.class 的方式命名才能被 UseMethod() 找到, 比如:
mean.numeric &amp;lt;- function(x, .</description></item><item><title>R中的sweep函数</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84sweep%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84sweep%E5%87%BD%E6%95%B0/</guid><description>函数的用途 base包中sweep()函数是处理统计量的工具。所以一般结合apply()函数来使用，一般我们需要将apply()统计出来的统计量要代回原数据集去对应操作的时候就需要用到sweep()。
扫除、清除也是sweep单词的本义。
函数的参数 sweep(x, MARGIN, STATS, FUN = &amp;#34;-&amp;#34;, check.margin = TRUE, ...) x:即要处理的原数据集 MARGIN：对行或列，或者数列的其他维度进行操作 STATS：需要对原数据集操作用到的统计量 FUN：操作需要用到的四则运算，默认为减法&amp;quot;-&amp;quot;，当然可以修改成&amp;quot;+&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;/&amp;ldquo;即加、乘、除 check.margin:是否需要检查维度是否适宜的问题，默认为TRUE。 …… 实例分析 1、比如我们需要将原数据集所有数据都减去各列的平均数，所以我们需要用apply()计算出每列的平均数，然后用sweep()完成。
require(stats) # for mean head(attitude, 10) ## rating complaints privileges learning raises critical advance ## 1 43 51 30 39 61 92 45 ## 2 63 64 51 54 63 73 47 ## 3 71 70 68 69 76 86 48 ## 4 61 63 45 47 54 84 35 ## 5 81 78 56 66 71 83 47 ## 6 43 55 49 44 54 49 34 ## 7 58 67 42 56 66 68 35 ## 8 71 75 50 55 70 66 41 ## 9 72 82 72 67 71 83 31 ## 10 67 61 45 47 62 80 41 mean.</description></item><item><title>R中的数据去重与缺失值处理</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E4%B8%8E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86/</guid><description>在R语言中，涉及到数据去重与缺失值处理的函数一共有下面这么几个：
unique
distinct
intersect
union
duplicated #布尔判断
is.na()/!is.na() #缺/非缺失值
na.rm=TRUE/FALSE #移除缺失值
na.omit(lc) #忽略缺失值
complete.cases() #完整值
unique函数通常用于去重：
unique(mydata$B) #对含有重复值得向量进行去重 dplyr::distinct(mydata,B) #对含有重复值字段的数据框去重 dplyr中提供了两个函数可以执行交集与补集操作:
duplicated(mydata$B) #返回重复对象的布尔值 mydata[!duplicated(mydata$B),] #剔除重复值，仅保留唯一值</description></item><item><title>R中的正则表达式</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description/></item><item><title>R为数据框求平均数和标准差并绘图</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%A1%86%E6%B1%82%E5%B9%B3%E5%9D%87%E6%95%B0%E5%92%8C%E6%A0%87%E5%87%86%E5%B7%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%A1%86%E6%B1%82%E5%B9%B3%E5%9D%87%E6%95%B0%E5%92%8C%E6%A0%87%E5%87%86%E5%B7%AE%E5%B9%B6%E7%BB%98%E5%9B%BE/</guid><description>01. 准备数据 使用ggplot自带的ToothGrowth数据。导入数据及数据结构如下
library(ggplot2) df &amp;lt;- ToothGrowth df$dose &amp;lt;- as.factor(df$dose) head(df) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 接下来我们利用这个数据绘制带有标准差的直方图。
02. 计算函数 首先我们需要做一个函数计算分组计算我们感兴趣变量的平均数及标准差。
# function to calculate the mean and standard deviation for each group # data: a data frame # varname: the name of a column containing the variable to be summarized # groupnames: vector of column names to be used as grouping variable data_summary &amp;lt;- function(data, varname, groupnames){ require(plyr) summary_func &amp;lt;- function(x, col){ c(mean = mean(x[[col]], na.</description></item><item><title>R包的查看、卸除、安装与卸载</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E5%8C%85%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%8D%B8%E9%99%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E5%8C%85%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%8D%B8%E9%99%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</guid><description>01. 卸载自己古老的包 查看自己的包
mypackages &amp;lt;- installed.packages()[,c(&amp;#39;Package&amp;#39;,&amp;#39;Version&amp;#39;,&amp;#39;LibPath&amp;#39;)] %&amp;gt;% as.data.frame() write.csv(mypackages, &amp;#34;~/Desktop/mypackages.csv&amp;#34;) 从存的文档中找到自己想要卸载的R包
remove.packages(c(&amp;#34;BSgenome.Athaliana.TAIR.TAIR9&amp;#34;, &amp;#34;BSgenome.Hsapiens.UCSC.hg19&amp;#34;, &amp;#34;GenomeInfoDb&amp;#34;, &amp;#34;GenomeInfoDbData&amp;#34;, &amp;#34;GenomicAlignments&amp;#34;, &amp;#34;GenomicFeatures&amp;#34;, &amp;#34;GenomicRanges&amp;#34;, &amp;#34;GO.db&amp;#34;, &amp;#34;GSEABase&amp;#34;, &amp;#34;KEGGgraph&amp;#34;, &amp;#34;KEGGREST&amp;#34;, &amp;#34;learnr&amp;#34;, &amp;#34;RgoogleMaps&amp;#34;, &amp;#34;RSQLite&amp;#34;, &amp;#34;yeastRNASeq&amp;#34;, &amp;#34;yyplot&amp;#34;), lib = .libPaths()[1]) remove.packages(c(&amp;#34;IRdisplay&amp;#34;, &amp;#34;IRkernel&amp;#34;), lib = .libPaths()[2]) mypackages &amp;lt;- installed.packages()[,c(&amp;#39;Package&amp;#39;,&amp;#39;Version&amp;#39;,&amp;#39;LibPath&amp;#39;)] %&amp;gt;% as.data.frame() write.csv(mypackages, &amp;#34;~/Desktop/mypackages_new.csv&amp;#34;) 查看之后上述的包已经被卸载了。
02. 补充部分 查看已加载的包
(.packages()) 卸除已加载的包
detach(&amp;#34;package:RMySQL&amp;#34;) 注意是卸除，不是卸载，也就是说不是把包从R运行环境中彻底删除，只是不希望该包被加载使用。
在包使用函数冲突，检验函数依赖时比较有用。
安装包
install.packages(&amp;#34;TSA&amp;#34;) 列出包所在库的路径
.libPaths() 包的载入
library() 或 require() 安装完包后，需要加载才能使用其中的函数，此时括号中不使用引号。两者的不同之处在于library()载入之后不返回任何信息，而require()载入后则会返回TRUE，因此require()适合用于程序的书写。
包的更新
update.packages() 彻底删除已安装的包：
remove. packages(c(&amp;#34;pkg1&amp;#34;,&amp;#34;pkg2&amp;#34;) , lib = file.path(&amp;#34;path&amp;#34;, &amp;#34;to&amp;#34;, &amp;#34;library&amp;#34;)) 查看已安装的包</description></item><item><title>R将包含重复列的去重并合并值</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E5%B0%86%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%88%97%E7%9A%84%E5%8E%BB%E9%87%8D%E5%B9%B6%E5%90%88%E5%B9%B6%E5%80%BC/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E5%B0%86%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%88%97%E7%9A%84%E5%8E%BB%E9%87%8D%E5%B9%B6%E5%90%88%E5%B9%B6%E5%80%BC/</guid><description>1. 问题 假设我们有数据框df如下：
Chr start stop ref alt Hom/het ID chr1 5179574 5183384 ref Del Het 719 chr1 5179574 5184738 ref Del Het 915 chr1 5179574 5184738 ref Del Het 951 chr1 5336806 5358384 ref Del Het 376 chr1 5347979 5358384 ref Del Het 228 所示ID915和951前面的部分都重复了，现在我们想把它变成如下
Chr start stop ref alt Hom/het ID chr1 5179574 5183384 ref Del Het 719 chr1 5179574 5184738 ref Del Het 915, 951 chr1 5336806 5358384 ref Del Het 376 chr1 5347979 5358384 ref Del Het 228 我们可以根据以下命令进行实现</description></item><item><title>R将数据框内相同变量的数据相加</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E5%B0%86%E6%95%B0%E6%8D%AE%E6%A1%86%E5%86%85%E7%9B%B8%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E5%B0%86%E6%95%B0%E6%8D%AE%E6%A1%86%E5%86%85%E7%9B%B8%E5%90%8C%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0/</guid><description>1. 问题 有的时候从原始数据读入到R中的数据会有很多的重复数据，并没有进行数据合并，对于后续的处理中会造成麻烦，因为R处理这种数据的时候会只取用第一次出现的结果。处理这个问题有很多方法，记录如下。
2. 解决 首先建立一个数据框，用来测试我们的方法：
bevs &amp;lt;- data.frame(cbind(name = c(&amp;#34;Bill&amp;#34;, &amp;#34;Llib&amp;#34;), drink = c(&amp;#34;coffee&amp;#34;, &amp;#34;tea&amp;#34;, &amp;#34;cocoa&amp;#34;, &amp;#34;water&amp;#34;), cost = seq(1:8))) bevs$cost &amp;lt;- as.integer(bevs$cost) bevs 下面利用plyr 包里面的count 函数进行相加
library(plyr) count(bevs, &amp;#34;name&amp;#34;) 同时统计两列，结果如下：
count(bevs, c(&amp;#34;name&amp;#34;, &amp;#34;drink&amp;#34;)) 如果想知道Bill和Llib在不同drink上花费的钱是多少呢？可以使用 aggregate函数。
aggregate(cost ~ name + drink, data = bevs, sum) 统计Bill和Llib的总花费
aggregate(cost ~ name, data = bevs, sum) 3. 总结 总结而言，利用count和aggregate可以很方便的帮助我们整理数据，将重复出现的变量归到一起进行计算。</description></item><item><title>R数据框选中某列之后不降为成列表</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E6%95%B0%E6%8D%AE%E6%A1%86%E9%80%89%E4%B8%AD%E6%9F%90%E5%88%97%E4%B9%8B%E5%90%8E%E4%B8%8D%E9%99%8D%E4%B8%BA%E6%88%90%E5%88%97%E8%A1%A8/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E6%95%B0%E6%8D%AE%E6%A1%86%E9%80%89%E4%B8%AD%E6%9F%90%E5%88%97%E4%B9%8B%E5%90%8E%E4%B8%8D%E9%99%8D%E4%B8%BA%E6%88%90%E5%88%97%E8%A1%A8/</guid><description>1. 问题 数据处理中一个令人头疼的事情是选中数据框中的某列时经常会被降维成列表而不是保持原来数据框的结构，如下：
student &amp;lt;- data.frame(ID=c(11,12,13),Name=c(&amp;#34;Devin&amp;#34;,&amp;#34;Edward&amp;#34;,&amp;#34;Wenli&amp;#34;),Gender=c(&amp;#34;M&amp;#34;,&amp;#34;M&amp;#34;,&amp;#34;F&amp;#34;)) student 当我们想得到name这一行的时候会采用以下方法
name1 &amp;lt;- student$Name name2 &amp;lt;- student[,2] str(name1) str(name2) #Factor w/ 3 levels &amp;#34;Devin&amp;#34;,&amp;#34;Edward&amp;#34;,..: 1 2 3 #Factor w/ 3 levels &amp;#34;Devin&amp;#34;,&amp;#34;Edward&amp;#34;,..: 1 2 3 可以看到数据都是factor类型的，没有保持为数据框，而这是不方面的
#2. 解决 我们可以利用以下两种方式避免这种情况的发生
name3 &amp;lt;- student[,2,drop = FALSE] name4 &amp;lt;- student[&amp;#34;Name&amp;#34;] str(name3) str(name4) #&amp;#39;data.frame&amp;#39;: 3 obs. of 1 variable: #$ Name: Factor w/ 3 levels &amp;#34;Devin&amp;#34;,&amp;#34;Edward&amp;#34;,..: 1 2 3 #&amp;#39;data.frame&amp;#39;: 3 obs. of 1 variable: #$ Name: Factor w/ 3 levels &amp;#34;Devin&amp;#34;,&amp;#34;Edward&amp;#34;,.</description></item><item><title>R语言中的向量和标量</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%90%91%E9%87%8F%E5%92%8C%E6%A0%87%E9%87%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%90%91%E9%87%8F%E5%92%8C%E6%A0%87%E9%87%8F/</guid><description>R语言中最基本的数据类型是向量，与C语言家族不同，R语言中，单个数据(标量)没有单独的数据类型，它只是向量的一种特例，标量以单元素向量的形式出现。标量是只含一个元素的向量，例如f &amp;lt;- 3、g &amp;lt;- &amp;ldquo;US&amp;quot;和h &amp;lt;- TRUE。它们用于保存常量。向量化指的是对于向量中的每一个元素应用函数。
在R中，数字被当成一元向量，因为数据类型中没有标量。R中的向量索引从1开始。
向量的主要性质包括：1）向量是同质的，即向量中所有元素具有相同的模式；2）向量可以按照位置索引；3）向量可以按照多重位置索引，返回一个子向量；4）向量的元素可以被命名。
R语言表面上没有标量的类型，因为标量可以看做是含有一个元素的向量，逻辑运算符对标量和向量有着不同的形式。</description></item><item><title>R语言代码规范</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</guid><description>编程的代码规范目的是使我们的R代码更容易阅读、分享和验证，下述是一些约定俗成的代码规范：
1.0 文件名 对于R file名字的命名，一般采用一些有意义的名字来命名，不要有特殊字符和空格，但是要注意大小写（特别是windowws系统是不管大小写的），所以最好就小写就行了；R代码就放在.R文件中，而R数据文件则放在.RData文件中。我一般不用下划线分割文件名，而是使用大小写交替的方式
GOOD: predict_ad_revenue.R; PredictAdRevenue.R BAD: foo.R
2.0 标识符(Identifiers) 不要使用下划线(_)或连字符(-)标识符。标识符应按照以下命名约定。变量名的首选形式都是小写字母和单词分开用点(variable.name),但也接受variableName;函数名使用首字母大写而不用点(FunctionName);
variable.name is preferred, variableName is accepted
GOOD: avg.clicks
OK: avgClicks
BAD: avg_Clicks
FunctionName
GOOD: CalculateAvgClicks
BAD: calculate_avg_clicks , calculateAvgClicks
Make function names verbs.
Exception: When creating a classed object, the function name
3.0 间距(Spacing) 当使用所有二进制运算符(如=,+,-,&amp;lt;,等)在两端空格。例外:当符号 = 是函数调用时的传递参数周围不用空格隔开。 不要在符号“，”前空格隔开，但需要在“，”后添加空格 good style
tab.prior &amp;lt;- table(df[df$days.from.opt &amp;lt; 0, &amp;#34;campaign.id&amp;#34;]) total &amp;lt;- sum(x[, 1]) total &amp;lt;- sum(x[1, ])123 bad style</description></item><item><title>R语言学习笔记之相关性矩阵分析及其可视化</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96/</guid><description>https://zhuanlan.zhihu.com/p/33617479?from_voters_page=true</description></item><item><title>R语言爬虫入门-rvest教程</title><link>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-rvest%E6%95%99%E7%A8%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/r%E8%AF%AD%E8%A8%80%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-rvest%E6%95%99%E7%A8%8B/</guid><description>安装包
# install.packages(&amp;#34;rvest&amp;#34;) 查看rvest包的详细信息
library(help = rvest) ###包的用法：
read_html() 读取html文档的函数，其输入可以是线上的url，也可以是本地的html文件，甚至是包含html的字符串也可以。
html_nodes() 选择提取文档中制定元素的部分。可以使用css selectors，例如html_nodes(doc, &amp;ldquo;table td&amp;rdquo;)；也可以使用xpath selectors，例如html_nodes(doc, xpath = &amp;ldquo;//table//td&amp;rdquo;)。
html_tag() 提取标签名称；html_text() 提取标签内的文本；html_attr() 提取指定属性的内容；html_attrs() 提取所有的属性名称及其内容；
html_table() 解析网页数据表的数据到R的数据框中。
html_form(),set_values()和submit_form() 分别表示提取、修改和提交表单。
在中文网页中我们经常会遇到乱码的问题，这里提供了两个函数来解决：guess_encoding()用来探测文档的编码，方便我们在读入html文档时设置正确的编码格式，repair_encoding()用来修复html文档读入后的乱码问题。
还有一些函数，用来模拟网上的浏览行为，如html_session(),jump_to(),follow_link(),back(),forward(),submit_form()等等。
library(rvest) web&amp;lt;-read_html(&amp;#34;https://book.douban.com/top250?icn=index-book250-all&amp;#34;,encoding=&amp;#34;UTF-8&amp;#34;) position &amp;lt;- web %&amp;gt;% html_nodes(&amp;#34;p.pl&amp;#34;) %&amp;gt;% html_text() web position 第一行是加载Rvest包。
第二行是用read_html函数读取网页信息（类似Rcurl里的getURL），在这个函数里只需写清楚网址和编码（一般就是UTF-8）即可。
第三行是获取节点信息。用%&amp;gt;%符号进行层级划分。web就是之前存储网页信息的变量，所以我们从这里开始，然后html_nodes()函数获取网页里的相应节点。在下面代码里我简单的重现了原网页里的一个层级结构。可以看到，实际上我们要爬取的信息在25个class属性为pl的标签里的文本。
[清] 曹雪芹 著 / 人民文学出版社 / 1996-12 / 59.70元 而对于这样的结构，在htmlnodes()函数里的写法就是简单的 "p.pl"，其中“.”表示class属性的值，如果是id属性则用“#”，如果大家学过CSS选择器就很好理解了，是完全一致的。 最后我们用html_text()函数表示获取文本信息，否则返回的是整个标签。总体上用以下一行代码就可以实现：
Example 2 到天气网(http://lishi.</description></item><item><title>shell编程-bash-shell中的特殊变量</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F/</guid><description>1.介绍 shell有很多以$开头的特殊变量，以下是对于这些变量的说明：
变量 意义 $$ Shell本身的PID（ProcessID） $! Shell最后运行的后台Process的PID $? 最后运行的命令的结束代码（返回值） $- 使用Set命令设定的Flag一览 $* 所有参数列表。如&amp;quot;$*&amp;ldquo;用「&amp;quot;」括起来的情况、以&amp;rdquo;$1 $2 … $n&amp;quot;的形式输出所有参数。 $@ 所有参数列表。如&amp;quot;$@&amp;ldquo;用「&amp;quot;」括起来的情况、以&amp;rdquo;$1&amp;quot; &amp;ldquo;$2&amp;rdquo; … &amp;ldquo;$n&amp;rdquo; 的形式输出所有参数。 $# 添加到Shell的参数个数 $0 Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数… 2.例子 下面通过一个例子解释怎么使用这些特殊变量 命令一个variable.sh的简单脚本，其内容如下
#!/bin/bash echo &amp;#34;number:$#&amp;#34; # $# 是传给脚本的参数个数 echo &amp;#34;scname:$0&amp;#34; # $0 是脚本本身的名字 echo &amp;#34;first :$1&amp;#34; # $1是传递给该shell脚本的第一个参数 echo &amp;#34;second:$2&amp;#34; # $2是传递给该shell脚本的第二个参数 echo &amp;#34;argume:$@&amp;#34; # $@ 是传给脚本的所有参数的列表 echo &amp;#34;all argume:$*&amp;#34; # $* 所有参数列表 echo &amp;#34;finish code:$?</description></item><item><title>shell编程-bash-shell的字符串操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid><description>1.字符串属性 字符有可能是数字、字母、空格、其他特殊字符，而字符串有可能是它们中的一种或者多种的组合，在组合之后还可能形成具有特定意义的字符串，诸如邮件地址，URL地址等。
数字或者数字组合
$ i=5;j=9423483247234; $ echo $i | grep &amp;#34;^[0-9]$&amp;#34; 5 $ echo $j | grep &amp;#34;^[0-9]\+$&amp;#34; 9423483247234 字符组合
$ c=&amp;#34;A&amp;#34;; d=&amp;#34;fwefewjuew&amp;#34;; e=&amp;#34;fewfEFWefwefe&amp;#34; $ echo $c | grep &amp;#34;^[A-Z]$&amp;#34; A $ echo $d | grep &amp;#34;^[a-z]\+&amp;#34; fwefewjuew $ echo $e | grep &amp;#34;^[a-zA-Z]\+$&amp;#34; fewfEFWefwefe 字母和数字的组合
$ ic=&amp;#34;432fwfwefeFWEwefwef&amp;#34; $ echo $ic | grep &amp;#34;^[0-9a-zA-Z]\+$&amp;#34; 432fwfwefeFWEwefwef 匹配邮件地址
$ echo &amp;#34;test2007@lzu.cn&amp;#34; | grep &amp;#34;[0-9a-zA-Z\.]*@[0-9a-zA-Z\.]*&amp;#34; test2007@lzu.cn 匹配 URL 地址
$ echo &amp;#34;http://news.lzu.edu.cn/article.jsp?newsid=10135&amp;#34; | grep &amp;#34;^http://[0-9a-zA-Z\.</description></item><item><title>shell编程-bash-shell的布尔运算</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</guid><description>在 Bash 里有这样的常量(实际上是两个内置命令，在这里我们姑且这么认为，后面将介绍)，即 true 和 false，一个表示真，一个表示假。对它们可以进行与、或、非运算等常规的逻辑运算。
1. 与或非运算 $ if true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi YES $ if false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO 与运算用&amp;amp;&amp;amp;表示
$ if true &amp;amp;&amp;amp; true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi YES $ if true &amp;amp;&amp;amp; false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO $ if false &amp;amp;&amp;amp; false;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO $ if false &amp;amp;&amp;amp; true;then echo &amp;#34;YES&amp;#34;; else echo &amp;#34;NO&amp;#34;; fi NO 或运算用||表示</description></item><item><title>shell编程-bash-shell的数值计算</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/</guid><description>1. 数据计算基础 使用man 或者info查看shell bash的判断命令test，Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。
man test info test 可以使用type查看一个命令是否是shell内置的函数，例如
$ type type type is a shell builti $ type awk awk is /usr/bin/awk 从结果可知： let 是 Shell 内置命令，awk是外部命令，在 /usr/bin 目录下
expr命令是一个手工命令行计数器，用于在UNIX/LINUX下求表达式变量的值，一般用于整数值，也可用于字符串。
$ expr 5 % 2 1 bc 命令是任意精度计算器语言，通常在linux下当计算器用。它类似基本的计算器, 使用这个计算器可以做基本的数学运算。
$ bc bc 1.06 Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc. This is free software with ABSOLUTELY NO WARRANTY. For details type `warranty&amp;#39;. 3^2 9 let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</description></item><item><title>shell编程-bash-shell的文件操作</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-bash-shell%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid><description>1. 基本操作 ls 命令显示文件基本属性，d 表示目录，- 表示普通文件（或者硬链接），l 表示符号链接，p 表示管道文件，b 和 c 分别表示块设备和字符设备。除此之外还可以使用stat命令，stat以文字的格式来显示inode的内容。
$ stat bin/ 16777220 8608385535 drwxr-xr-x 37 root wheel 0 1184 &amp;#34;Nov 23 09:06:38 2018&amp;#34; &amp;#34;Nov 10 01:38:56 2018&amp;#34; &amp;#34;Nov 10 01:38:56 2018&amp;#34; &amp;#34;Sep 21 00:17:17 2018&amp;#34; 4096 0 0x88000 bin/ file命令也可以给出文件的基本信息
$ file bin bin: directory 可以使用chmod给文件添加权限
chmod 777 regular_file 可以使用passwd命令给用户修改自己的密码
passwd #普通用户通过执行该命令，修改自己的密码 可以使用tree显示目录树
$ tree #当前目录 2. 压缩与解压缩文件 #tar $ tar -cf file.tar file #压缩 $ tar -xf file.</description></item><item><title>shell编程-shell编程基础</title><link>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/shell%E7%BC%96%E7%A8%8B-shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>1.什么是shell shell是介于用户和操作系统之间的一个接口，用来接收用户的键盘输入，并分析和执行输入字符串中的命令，然后给用户返回执行结果，于GUI相比，shell因为使用命令行，所以使用起来可能比较复杂，但是使用的资源会比较少，而且拥有批处理的功能。
一图看shell在操作系统中的位置 使用命令查看当前shell
echo $SHELL #/bin/zsh ls -l /bin/zsh #-rwxr-xr-x 1 root wheel 610224 Sep 21 00:17 /bin/zsh 如果你发现当前 Shell 不是 Bash，请用下面的方法替换它：
$ bash $ echo $SHELL # 确认一下 /bin/bash ##2.简单的shell脚本 假设我们设计一个test.sh的脚本，内容如下
#!/bin/bash # test.sh echo &amp;#34;Hello, World&amp;#34; 重点是该文件的第一行，当我们直接运行该脚本文件时，该行告诉操作系统使用用#! 符号之后面的解释器以及相应的参数来解释该脚本文件，通过分析第一行，我们发现对应的解释器是 /bin/bash。
3.shell的执行原理 Shell 接收用户输入的脚本名，并进行分析。如果文件被标记为可执行，但不是被编译过的程序，Shell 就认为它是一个 Shell 脚本。 Shell 将读取其中的内容，并加以解释执行。所以，从用户的观点看，执行 Shell 脚本的方式与执行一般的可执行文件的方式相似。
因此，用户开发的 Shell 脚本可以驻留在命令搜索路径的目录之下（通常是 /bin、/usr/bin等），像普通命令一样使用。这样，也就开发出自己的新命令。如果打算反复使用编好的 Shell 脚本，那么采用这种方式就比较方便。</description></item><item><title>tidyverse包简介</title><link>https://kongjianyang.github.io/cn/2018/11/24/tidyverse%E5%8C%85%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/tidyverse%E5%8C%85%E7%AE%80%E4%BB%8B/</guid><description>tidyverse包是对一些具有相同思想，且可以一同工作的R包的收集。 载入tidyverse包的时候提醒哪些包是一同载入的，哪些包是有冲突的。
&amp;gt; library(tidyverse) ── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ── ✔ ggplot2 2.2.1 ✔ purrr 0.2.5 ✔ tibble 1.4.2 ✔ dplyr 0.7.6 ✔ tidyr 0.8.1 ✔ stringr 1.3.1 ✔ readr 1.1.1 ✔ forcats 0.3.0 ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() 这些包按照功能可以分为数据导入、数据整理、数据转换、可视化、建模、编程。
1. 数据导入 readr：read_csv(); read_tsv(); read_delim(); read_fwf(); read_table(); - read_log(); readxl：read_xls(); read_xlsx(); haven：打开SAS 、SPSS、Stata等外部数据 这里要提一下，read.table()是R自带的，而read_table()是readr包有的。
2. 数据整理 tibble: 对data.frame的改进，一种数据格式 tidyr:清洗数据 gather(); spread(); Tibble是数据框的一种形式，但是比数据框更整洁，结构更加紧凑，可以理解为tidy table之意。可以通过转置函数as_tibble()来将data.</description></item><item><title>tmux-指南</title><link>https://kongjianyang.github.io/cn/2018/11/24/tmux-%E6%8C%87%E5%8D%97/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/tmux-%E6%8C%87%E5%8D%97/</guid><description>我的tmux配置 https://wdxtub.com/2016/03/30/tmux-guide/</description></item><item><title>WGCNA构建基因共表达网络详细教程</title><link>https://kongjianyang.github.io/cn/2018/11/24/wgcna%E6%9E%84%E5%BB%BA%E5%9F%BA%E5%9B%A0%E5%85%B1%E8%A1%A8%E8%BE%BE%E7%BD%91%E7%BB%9C%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/wgcna%E6%9E%84%E5%BB%BA%E5%9F%BA%E5%9B%A0%E5%85%B1%E8%A1%A8%E8%BE%BE%E7%BD%91%E7%BB%9C%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</guid><description>这篇文章更多的是对于混乱的中文资源的梳理，并补充了一些没有提到的重要参数，希望大家不会踩坑。
#1. 简介
1.1 背景 WGCNA（weighted gene co-expression network analysis，权重基因共表达网络分析）是一种分析多个样本基因表达模式的分析方法，可将表达模式相似的基因进行聚类，并分析模块与特定性状或表型之间的关联关系，因此在基因组研究中被广泛应用。
相比于只关注差异表达的基因，WGCNA利用数千或近万个变化最大的基因或全部基因的信息识别感兴趣的基因集，并与表型进行显著性关联分析。既充分利用了信息，也把数千个基因与表型的关联转换为数个基因集与表型的关联，免去了多重假设检验校正的问题。
WGCNA算法首先假定基因网络服从无尺度分布(scale free network)，并定义基因共表达相关矩阵、基因网络形成的邻接函数，然后计算不同节点的相异系数，并据此构建分层聚类树(hierarchical clustering tree)，该聚类树的不同分支代表不同的基因模块(module)，模块内基因共表达程度高，而分属不同模块的基因共表达程度低。
##1.2 无尺度网络 网络的数学名称是图，在图论中对于每一个节点有一个重要概念，即：度(degree)。一个点的度是指图中该点所关联的边数。如下图，如果不加以思考，人们很容易认为生活中常见的网络会是一种random network，即每一个节点的度相对平均。然而第二种图，即scale-free network才是一种更稳定的选择。Scale-free network具有这样的特点，即存在少数节点具有明显高于一般点的度，这些点被称为hub。由少数hub与其它节点关联，最终构成整个网络。这样的网络的节点度数与具有该度数的节点个数间服从power distribution。生物体选择scale-free network而不是random network尤其进化上的原因，对于scale-free network，少数关键基因执行主要功能，这种网络具有非常好的鲁棒性(Robust)，即只要保证hub的完整性，整个生命体的基本活动在一定刺激影响下将不会受到太大影响，而random network若受到外界刺激，其受到的伤害程度将直接与刺激强度成正比。
1.3 相关术语 共表达网络：点代表基因，边代表基因表达相关性。加权是指对相关性值进行冥次运算 (冥次的值也就是软阈值 (power, pickSoftThreshold这个函数所做的就是确定合适的power))。无向网络(unsigned network)的边属性计算方式为 abs(cor(genex, geney)) ^ power；有向网络(signed network)的边属性计算方式为 (1+cor(genex, geney)/2) ^ power; sign hybrid的边属性计算方式为cor(genex, geney)^power if cor&amp;gt;0 else 0， sign hybrid意味着它既包含加权网络也包含非加权网络。这种处理方式强化了强相关，弱化了弱相关或负相关，使得相关性数值更符合无标度网络特征，更具有生物意义。除了软阈值还有硬阈值一说，计算方式是 a_ij = 1 if s_ij &amp;gt; β otherwise a_ij = 0。这里的β就是硬阈值(hard threshold)。
Module(模块)：高度內连的基因集。在无向网络中，模块内是高度相关的基因。在有向网络中，模块内是高度正相关的基因。
Connectivity (连接度)：类似于网络中 “度” (degree)的概念。每个基因的连接度是与其相连的基因的边属性之和。</description></item><item><title>windows下的Linux子系统安装conda和jupyterlab</title><link>https://kongjianyang.github.io/cn/2018/11/24/windows%E4%B8%8Blinux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85conda%E5%92%8Cjupyterlab/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/windows%E4%B8%8Blinux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85conda%E5%92%8Cjupyterlab/</guid><description>1.安装conda 升级系统
sudo apt-get update -y &amp;amp;&amp;amp; sudo apt-get upgrade -y 下载anaconda
wget https://repo.anaconda.com/archive/Anaconda3-5.0.1-Linux-x86_64.sh 安装anaconda
bash Anaconda3-5.0.1-Linux-x86_64.sh 按照安装教程进行下去
激活安装
source ~/.bashrc 查看安装
conda list 2.安装jupyterlab conda install -c conda-forge jupyterlab 3.使用Jupyterlab jupyter lab</description></item><item><title>xargs命令与管道的区别</title><link>https://kongjianyang.github.io/cn/2018/11/24/xargs%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/xargs%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>xargs是一条Unix 和类Unix 操作系统 的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。
下面两个例子解释xargs命令与管道之间的区别
echo &amp;#39;main&amp;#39; | cat # main 这条命令中cat会从其标准输入中读取内容并处理，也就是会输出 &amp;lsquo;main&amp;rsquo; 字符串。echo命令将其标准输出的内容 &amp;lsquo;main&amp;rsquo; 通过管道定向到 cat 的标准输入中
echo &amp;#39;--help&amp;#39; | xargs cat #cat: illegal option -- - #usage: cat [-benstuv] [file ...] 上述的命令类似
cat --help 可以看到 echo &amp;lsquo;&amp;ndash;help&amp;rsquo; | cat 该命令输出的是echo的内容，也就是说将echo的内容当作cat处理的文件内容了，实际上就是echo命令的输出通过管道定向到cat的输入了。然后cat从其标准输入中读取待处理的文本内容。这等价于在test.txt文件中有一行字符 &amp;lsquo;&amp;ndash;help&amp;rsquo; 然后运行 cat test.txt 的效果。
而 echo &amp;lsquo;&amp;ndash;help&amp;rsquo; | xargs cat 等价于 cat &amp;ndash;help 什么意思呢，就是xargs将其接受的字符串 &amp;ndash;help 做成cat的一个命令参数来运行cat命令，同样 echo &amp;rsquo;test.c test.cpp&amp;rsquo; | xargs cat 等价于 cat test.c test.cpp 此时会将test.c和test.cpp的内容都显示出来。</description></item><item><title>三维基因组学研究之Hi-C</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E4%B8%89%E7%BB%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B9%8Bhi-c/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E4%B8%89%E7%BB%B4%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B9%8Bhi-c/</guid><description>1. 技术原理 基因组研究的维度可以分为很多种，例如下图所示
其中Hi-C是研究三维结构的一种方法。Hi-C技术源于染色体构象捕获（Chromosome Conformation Capture, 3C）技术，利用高通量测序技术，结合生物信息分析方法，研究全基因组范围内整个染色质DNA在空间位置上的关系，获得高分辨率的染色质三维结构信息。
其中染色质构象捕获（3C）技术是用福尔马林瞬时固定细胞核染色质，用过量的限制性内切酶酶切消化染色质 - 蛋白质交联物，在 DNA 浓度极低而连接酶浓度极高的条件下用连接酶连接消化物，蛋白酶消化交联物以释放出结合的蛋白质，用推测可能有互作的目的片段引物进行普通PCR和定量PCR来确定是否存在相互作用。3C 技术假定物理上互作的 DNA 片段连接频率最高，以基因座特异性 PCR 来检测基因组中 DNA 片段之间的物理接触，最终以 PCR 产物的丰度来确定是否存在相互作用。
Hi-C技术在3C的基础上，在酶切后将缺口进行补平（dCTP 进行生物素标），然后用连接酶进行连接，将样本进行超声破碎，随后用生物素亲和层析将片段沉淀（也就是抓下来带有生物素标记的片段），加上接头进行深度测序。
2. 技术流程 下图显示其技术流程 第一步还是用甲醛使细胞内空间上靠近的DNA片段形成共价键；然后用限制性内切酶将染色质片段化；第三步用生物酰化的核酸分子链接酶切形成的粘性末端，链接过程需要在稀释的溶液中进行，有助于形成分子内链接；第四步纯化并片段化DNA，用链霉亲和素的磁珠富集含生物酰化的junction片段；最后，对收集到的junction片段进行建库并使用pair-end方法测序。
3. 分析步骤 Hi-C的优势在于其结合了二代测序，这势必也使得其数据分析相对复杂了。目前比较成熟的数据分析流程大致包含6个步骤：
（1） 前期raw reads过滤（跟一般二代测序数据处理基本一致） （2） 序列比对。建议采用pair-end测序模式 （3） 定位酶切位点。比对寻找到reads pairs在基因组物理位置之后，通过插入片段大小的限制搜索reads pairs两端每条read所对应的最近的酶切片段。酶切片段的位置代表了DNA交互产生的大致位置 （4） 筛选出有效的比对片段。配对的reads位于酶切位点两端且mapped的方向相反 （5） 整合DNA 片段交互强度。 （6） DNA片段交互矩阵标准化。
分析流程可如下图所示：</description></item><item><title>为Jupyter-Notebook添加目录</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E4%B8%BAjupyter-notebook%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E4%B8%BAjupyter-notebook%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/</guid><description>1. 问题 从R的RMarkdown转到Python的Jupyter Notebook的时候会发现一个问题. 使用RStudio生成RMarkdown的时候, 可以添加目录(Table of Contents, TOC). 在RStudio添加一个目录, 目录里面的内容根据RMarkdown每一个标题自动生成. 这样只需要点击目录里面相应的内容, 就可以很快的跳到RMarkdown对应的地方，非常有效率。但是很可惜的是, 默认Jupyter Notebook是没有生成目录这个功能的。但是我们可以通过Jupyter Notebook extensions开启这个功能。
2. 解决 第一步, 安装 Jupyter Notebook
这个是必须的. 如果还没安装的话, 建议安装 anaconda 第二步, 安装Jupyter Notebook extensions
conda install -c conda-forge jupyter_contrib_nbextensions 第三步, 开启toc2插件
运行Jupyter Notebook, 在打开的Notebook界面里, 你会发现多了一个Nbextensions,点击这个tab, 会有如下界面
勾选Table of Contents (有的版本是toc2). 然后创建或者打开一个Jupter Notebook
第四步, 生成目录
在Notebook上面选项中,多了一个生成目录图标, 如下图中最右边的图标.点击这个图标就会生成一个目录. 在Notebook里添加标题(也就是用###生成的Markdown内容)会自动添加到目录里面. 在目录上面, 有个小的n图标, 这表示自动对每个标题编号, 点击这个图标可以打开或者关闭这个功能。
3. 总结 Rmarkdown和Jupyter notebook用来做轻量级的编程都是非常好的，他们彼此之间的相似点也非常多，这两个工具某种程度上也降低了R和Python语言学习门槛，可以花更多的时间在这两个工具上。</description></item><item><title>使用-R，DiagrammeR-和-Blogdown-快速画箭头图表</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E4%BD%BF%E7%94%A8-rdiagrammer-%E5%92%8C-blogdown-%E5%BF%AB%E9%80%9F%E7%94%BB%E7%AE%AD%E5%A4%B4%E5%9B%BE%E8%A1%A8/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E4%BD%BF%E7%94%A8-rdiagrammer-%E5%92%8C-blogdown-%E5%BF%AB%E9%80%9F%E7%94%BB%E7%AE%AD%E5%A4%B4%E5%9B%BE%E8%A1%A8/</guid><description>https://www.jianshu.com/p/5e28292fc5d1</description></item><item><title>利用ggplot绘制带百分比饼图</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8ggplot%E7%BB%98%E5%88%B6%E5%B8%A6%E7%99%BE%E5%88%86%E6%AF%94%E9%A5%BC%E5%9B%BE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8ggplot%E7%BB%98%E5%88%B6%E5%B8%A6%E7%99%BE%E5%88%86%E6%AF%94%E9%A5%BC%E5%9B%BE/</guid><description>1. 介绍 有的时候我们需要利用饼图进行统计结果的占比展示，在R中可以利用ggplot进行绘制，但是ggplot中实际上并没有直接的函数可以绘制饼图，饼图实际上是geom_bar的一个变形。下面我们就来看看如何利用ggplot绘制带百分比的饼图。
2. 步骤 library(dplyr) library(ggplot2) library(ggmap) # 为了引用主题theme_nothing，用来消除原始ggplot绘图自带的一切标签 df &amp;lt;- data.frame(value = c(52, 239, 9), Group = c(&amp;#34;Positive&amp;#34;, &amp;#34;Negative&amp;#34;, &amp;#34;Neutral&amp;#34;)) %&amp;gt;% # factor levels need to be the opposite order of the cumulative sum of the values mutate(Group = factor(Group, levels = c(&amp;#34;Neutral&amp;#34;, &amp;#34;Negative&amp;#34;, &amp;#34;Positive&amp;#34;)), cumulative = cumsum(value), midpoint = cumulative - value / 2, label = paste0(Group, &amp;#34; &amp;#34;, round(value / sum(value) * 100, 1), &amp;#34;%&amp;#34;)) ggplot(df, aes(x = 1, weight = value, fill = Group)) + geom_bar(width = 1, position = &amp;#34;stack&amp;#34;) + coord_polar(theta = &amp;#34;y&amp;#34;) ## 以y轴建立极坐标 + geom_text(aes(x = 1.</description></item><item><title>利用PyPDF2合并PDF文件</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8pypdf2%E5%90%88%E5%B9%B6pdf%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8pypdf2%E5%90%88%E5%B9%B6pdf%E6%96%87%E4%BB%B6/</guid><description>1. 问题 有的时候我们有一系列PDF文件我们希望合并到一个PDF中进行查看和打印，这个时候合并PDF文件就非常有用，PyPDF2库可以帮助我们做到这点。
2. 用法 PyPDF2 包括了 PdfFileReader PdfFileMerger PageObject PdfFileWriter 四个常用的主要 Class。
以下命令可以解释这个库是怎么工作的
from PyPDF2 import PdfFileReader, PdfFileWriter readFile = &amp;#39;read.pdf&amp;#39; writeFile = &amp;#39;write.pdf&amp;#39; # 获取一个 PdfFileReader 工具 pdfReader = PdfFileReader(open(readFile, &amp;#39;rb&amp;#39;)) # 获取 PDF 的页数 pageCount = pdfReader.getNumPages() print(pageCount) # 返回一个 PageObject page = pdfReader.getPage(i) # 获取一个 PdfFileWriter 工具 pdfWriter = PdfFileWriter() # 将一个 PageObject 插手到 PdfFileWriter 中 pdfWriter.addPage(page) # 输出到文件中 pdfWriter.write(open(writeFile, &amp;#39;wb&amp;#39;)) 接下来的命令是一个实例
from PyPDF2 import PdfFileMerger pdfs = [&amp;#39;file1.</description></item><item><title>利用Python将基因表达数据存为字典</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8python%E5%B0%86%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E6%95%B0%E6%8D%AE%E5%AD%98%E4%B8%BA%E5%AD%97%E5%85%B8/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8python%E5%B0%86%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E6%95%B0%E6%8D%AE%E5%AD%98%E4%B8%BA%E5%AD%97%E5%85%B8/</guid><description>1. 问题 我们的基因表达数据如下表所示
cond1 cond2 cond3 gene1 1.57 2.52 12.05 gene2 0.01 8.90 31.20 gene3 57.05 12.14 50.76 我们希望能够利用Python将这个基因表达文件存为一个dictionary，这样我们能很容易的通过基因名和样品名得到基因的表达量，我们还可以筛选表达量大于某个值的所有基因和样品， 如下：
myDict[(&amp;#39;gene1&amp;#39;,&amp;#39;cond1&amp;#39;)] = 1.57 myDict[(&amp;#39;gene1&amp;#39;,&amp;#39;cond2&amp;#39;)] = 2.52 myDict[(&amp;#39;gene1&amp;#39;,&amp;#39;cond3&amp;#39;)] = 12.05 myDict[(&amp;#39;gene2&amp;#39;,&amp;#39;cond1&amp;#39;)] = 0.01 ... 2. Python解决 利用Python的逻辑是首先将基因名和样品名存为一个元祖，然后将此元祖作为字典里面的key，将基因表达量作为字典里面的value。
data = open(input_file, &amp;#39;rU&amp;#39;) l = data.readline().rstrip(&amp;#34;\r\n&amp;#34;) conds = l.split(&amp;#34;\t&amp;#34;) conds.pop(0) d = dict() for l in data: l = l.rstrip(&amp;#34;\r\n&amp;#34;) vals = l.split(&amp;#34;\t&amp;#34;) gene = vals[0] vals.pop(0) valIdx = 0 for val in vals: cond = conds[valIdx] d[(gene, cond)] = float(val) valIdx += 1 ## 额外部分，想得到基因表达量大于12的基因和样品 value12={k:v for k,v in d.</description></item><item><title>利用集群(cluster)运行R脚本的技巧</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8%E9%9B%86%E7%BE%A4cluster%E8%BF%90%E8%A1%8Cr%E8%84%9A%E6%9C%AC%E7%9A%84%E6%8A%80%E5%B7%A7/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%88%A9%E7%94%A8%E9%9B%86%E7%BE%A4cluster%E8%BF%90%E8%A1%8Cr%E8%84%9A%E6%9C%AC%E7%9A%84%E6%8A%80%E5%B7%A7/</guid><description>1. 编写脚本 首先编写一个R脚本保存在当前目录下，例如HeatMap.R
library(gplots) qlf_path &amp;lt;- &amp;#34;../07DEgene/QLF_DEG/&amp;#34; file_name &amp;lt;- dir(qlf_path) figure_path &amp;lt;- &amp;#34;../07DEgene/figure/qlf_heatmap/&amp;#34; for (k in 21:21){ mymain &amp;lt;- strsplit(file_name[k], &amp;#34;_&amp;#34;)[[1]][c(1,2,4,5)] mymain &amp;lt;- paste(mymain, collapse = &amp;#34;_&amp;#34;) figure_name &amp;lt;- paste0(figure_path, mymain, &amp;#34;.pdf&amp;#34;) pdf(figure_name) qlf_file &amp;lt;- paste0(qlf_path, file_name[k]) data &amp;lt;- read.table(qlf_file) data &amp;lt;- as.matrix(data) mycol &amp;lt;- colorpanel(n=40,low=&amp;#34;blue&amp;#34;,high=&amp;#34;yellow&amp;#34;) heatmap.2(data, col = mycol, scale = &amp;#34;row&amp;#34;, key=TRUE, trace=&amp;#34;none&amp;#34;,cexCol=1,cexRow=0.5, srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1), Rowv= T, Colv = F, lmat=rbind( c(0, 3), c(2,1), c(4,0) ), lhei=c(1.</description></item><item><title>基因的分子结构</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%9F%BA%E5%9B%A0%E7%9A%84%E5%88%86%E5%AD%90%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%9F%BA%E5%9B%A0%E7%9A%84%E5%88%86%E5%AD%90%E7%BB%93%E6%9E%84/</guid><description>人类结构基因4个区域：①编码区，包括外显子与内含子；②前导区，位于编码区上游，相当于RNA5’末端非编码区（非翻译区）；③尾部区，位于RNA3’编码区下游，相当于末端非编码区（非翻译区）；④调控区，包括启动子和增强子等。基因编码区的两侧也称为侧翼顺序。
基因经过转录形成Pre mRNA，这里面包含着内含子和外显子（5端是以外显子打头，但是这段外显子不仅包含CDS，还包含5&amp;rsquo; UTR；3端是以外显子结束，但是这段外显子不仅包含CDS，还包含3&amp;rsquo; UTR），经过剪接形成成熟mRNA,内含子已减掉，如果抛开后来加上去的cap和poly A的话，这时全是外显子，但是不全是CDS，因为只有中间的那部分以起始密码子开始、以终止密码子结束的片段才是CDS，只有这部分才会被翻译成蛋白质。
一个mRNA EXON可能仅部分编码蛋白质，恰恰是上游或下游非编码区存在时。每个Exon的蛋白质编码部分由CDS元件表示。CDS元件还编码终止密码子。
对于存在非翻译区的区域，将出现UTR。UTR代表Exon的非蛋白质编码部分。UTR（Untranslated Regions)即非翻译区，是信使RNA（mRNA）分子两端的非编码片段。5&amp;rsquo;-UTR从mRNA起点的甲基化鸟嘌呤核苷酸帽延伸至AUG起始密码子，3&amp;rsquo;-UTR从编码区末端的终止密码子延伸至多聚A尾巴（Poly-A）的末端。
其中一个基因有可能有多个转录本，原因是由于不同的剪接方式造成的。我们都知道，基因转录之后，首先是形成前体mRNA，通过剪切内含子连接外显子，5’端加帽及3’端加尾之后形成成熟的mRNA。
但是在剪切的过程中可能会剪切掉外显子，也有可能保留部分内含子，这样就形成了多种mRNA即多个转录本。
其中注意平时经常说到的promoter不属于intron和Exon的任何一个，属于Non Coding Sequence也是Regulatory Sequence。</description></item><item><title>富集分析（超几何分布）（Fisher's-Exact-Test）</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83fishers-exact-test/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E8%B6%85%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83fishers-exact-test/</guid><description>1. 简介 超几何分布（hypergeometric）是统计学上一种离散概率分布。它描述了由有限个物件中抽出n个物件，成功抽出指定种类的物件的个数（不归还）。
超几何分布和Fisher&amp;rsquo;s Exact Test是完全一模一样的原理，只是两种不同的称谓。
例如在有N个样本，其中m个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的机率：
上式可如此理解：n^N 表示所有在N个样本中抽出n个，而抽出的结果不一样的数目。 k^m 表示在m个样本中，抽出k个的方法数目。剩下来的样本都是及格的，而及格的样本有N-m个，剩下的抽法便有(n-K^N-m)种。
若n=1，超几何分布还原为伯努利分布。
若N接近∞，超几何分布可视为二项分布。注意二项分布是有归还 (with replacement) 的抽取。
然后计算得到的p-value通过Bonferroni校正之后，以0.05为阈值（小于0.05），满足此条件的GO term定义为显著富集。
（1）超几何分布的模型是不放回抽样
（2）超几何分布中的参数是M,N,n上述超几何分布记作X~H(n，M，N）。
2. 例子 以文章Gene Expre ssion in Ovarian Cancer Reflects Both Morphology and Biological Behavior, Distinguishing Clear Cell from Other Poor-Prognosis Ovarian Carcinomas所鉴定的差异基因为例。
测试一下这些基因和化学刺激响应的相关性。
样本的大小是n，属于“化学刺激响应”这个分类的基因有k个。
eg &amp;lt;- c(&amp;#34;7980&amp;#34;, &amp;#34;3081&amp;#34;, &amp;#34;3162&amp;#34;, &amp;#34;3059&amp;#34;, &amp;#34;1545&amp;#34;, &amp;#34;1917&amp;#34;, &amp;#34;6696&amp;#34;, &amp;#34;5797&amp;#34;, &amp;#34;6648&amp;#34; , &amp;#34;10397&amp;#34; , &amp;#34;6781&amp;#34;, &amp;#34;5817&amp;#34;, &amp;#34;1282&amp;#34;, &amp;#34;1284&amp;#34;, &amp;#34;6948&amp;#34;, &amp;#34;7077&amp;#34;) n &amp;lt;- length(eg) k &amp;lt;- sum(eg %in% allgeneInCategory) n k #16 #12 那么做为背景，总体基因为N，属于“化学刺激响应”这个分类的基因有M个。</description></item><item><title>序列比较中ClustalW和BLAST的区别</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83%E4%B8%ADclustalw%E5%92%8Cblast%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83%E4%B8%ADclustalw%E5%92%8Cblast%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>序列比对是生物信息学研究中一种常见且经典的手段。经过多年的发展，序列比对也诞生了很多种方法，这篇文章选择讨论的是两种比较常见的序列比对方法，选择哪种比对方法也是科研中容易踩坑的一个点。
#BLAST
BLAST(Basic Local Alignment Search Tool )算法是1990年由Altschul等人提出的两序列局部比对算法，采用了一种短片段匹配算法和一种有效的统计模型来找出目的序列和数据库之间的最佳局部比对效果。
它的基本思想是：通过产生数量更少的但质量更好的增强点来提高匹配的精确度。首先采用哈希法对查询序列以碱基的位置为索引建立哈希表，然后将查询序列和数据库中所有序列联配，找出精确匹配的“种子”，以“种子”为中心，使用动态规划法向两边扩展成更长的联配，最后在一定精度范围内选取符合条件的联配按序输出。得分最高的联配序列就是最有比对序列。
其算法过程可简单描述为：
从两个序列中找出一些长度相等且可以形成无空位完全匹配的子序列，即序列片段对； 找出两个序列之间所有匹配程度超过一定值的序列片段对； 将得到的序列片段对根据给定的相似性阂值延伸，得到一定长度的相似性片段，称为高分值片段对。 将Query序列中每k个字的组合做成一个表，以k=3为例(DNA序列中，我们则常以k=11为例)，我们&amp;quot;依序&amp;quot;将Query序列中每3个字的组合视为一个字组，并将这些字组列在一张字组表上，直到Query序列中最后一个字也被收入进表上为止 根据打分矩阵(scoring matrix)为所有的字母对打分。下面是一个比较常见打分矩阵，相同匹配加2，AG，CT减5，其他不匹配减7，空位减5。给出一个阈值T，留下高于T的单词匹配对，作为后面extend的seed。 为每对单词执行上面步骤，找出所有打分高于T单词对。找到所有的seed。
4.在实际运行中，算法最大的消耗在步骤extend上面，减少extend的方法就是减少seed的数目。对于选出的seed，可以将距离相近的合并为一个seed，这样就可以减少大量extend的计算量。
5.下一步是extend的步骤，对于每一对选择出来的种子，将其向两边延伸，使其在尽可能长的距离得到尽可能多的分数。具体方法是逐渐向两边扩展，规定常数 D，在扩展到分数为Highest Score-D时停止，如果最终得分大于得分阈值S，则将其设为高分区域HSP(high-scoring segment pair, HSP)。 将相邻的或距离较近的HSP合并。
对于每部分HSP使用Smith-Watermans算法进行局部性比对，为每部分打分，作为最终结果。
这里我们知道BLAST是基于局部比对的方法，另一个常用来做序列比对的方法是全局比对，ClustalW是其中的一个代表。
#ClustalW CLUSTALW(它的PC版本是CLUSTALX)是目前使用最广泛的多序列比对程序。它采用的是一种渐进的比对方法(progressive methods)，先将多个序列两两比对构建距离矩阵，反映序列之间两两关系；然后根据距离矩阵计算产生系统进化指导树，对关系密切的序列进行加权；然后从最紧密的两条序列开始，逐步引入临近的序列并不断重新构建比对，直到所有序列都被加入为止。
ClustalW采用的是全局比对的算法，所以当我们用BLAST和ClustalW进行比对的时候结果很大概率上是不一样的，下图是一个例子 这样引出一个问题，我们什么时候选择用BLAST，什么时候选择用ClustalW呢？ 下面的表可以用来进行参考
全局比对 局部比对 比较的是全部长度(end to end alignment) 找到局部最高相似性 包含query和target全部信息 匹配部分query信息到target上 如果两条序列长度相当，相似性高，建议全局 只考虑序列的局部结构 全部匹配常见于寻找同源基因 (人和老鼠) 常见于寻找DNA的保守区域 采用Needleman-Wunsch算法 采用Smith-Whaterman算法 上世纪70年代，Needleman-Wunsch提出了End-to-end的全局比对算法，但是随着越来越多的蛋白质被测序，人们越来约发现某些蛋白差异虽然很大，但是在局部的功能域上却很相似，这些功能域相当保守且发挥相近的重要功能，但是仅靠全局比对算法却很那发现他们。所以就有了Smith-Whaterman算法。Smith-Whaterman算法的主要创新点是给Needleman-Wunsch的算法设置了一个最低罚分不超过0的选项。公式看起来很简单。但是这个0花了整整10年时间，其实这个0只是赋予了一部分（局部）重新开始的机会。</description></item><item><title>循环存多张图片</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E5%BE%AA%E7%8E%AF%E5%AD%98%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E5%BE%AA%E7%8E%AF%E5%AD%98%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/</guid><description>library(ggpubr) trait_names &amp;lt;- colnames(Het_Ind)[5:18] plot &amp;lt;- list() for (i in 1:length(trait_names)){ trait_data &amp;lt;- Het_Ind[, c(&amp;#34;Genotype&amp;#34;, &amp;#34;NRate&amp;#34;, trait_names[i])] colnames(trait_data) &amp;lt;- c(&amp;#34;Genotype&amp;#34;, &amp;#34;Nitrogen&amp;#34;, &amp;#34;Value&amp;#34;) trait_data$Genotype &amp;lt;- factor(trait_data$Genotype, levels = sort(c(&amp;#34;B73xILP1&amp;#34;, &amp;#34;B73xPH207&amp;#34;, &amp;#34;B73xIHP1&amp;#34;, &amp;#34;B73xPHG84&amp;#34;, &amp;#34;B73xLH82&amp;#34;, &amp;#34;B73xMo17&amp;#34;))) trait_data$Nitrogen &amp;lt;- factor(trait_data$Nitrogen, levels = c(&amp;#34;LN&amp;#34;, &amp;#34;HN&amp;#34;)) plot[[i]] &amp;lt;- ggplot(trait_data, aes(x=Genotype, y=Value, fill = Nitrogen)) + geom_bar(stat = &amp;#34;identity&amp;#34;, position= &amp;#34;dodge&amp;#34;, width=0.8) + theme_bw() + geom_text(aes(label=round(trait_data$Value, digits = 2)), position = position_dodge(width = 0.8), size =2.5) + labs(title= trait_names[i], x = &amp;#34;Genotype&amp;#34;, y = &amp;#34;log2(Hybrid / MP)&amp;#34;) + theme(axis.</description></item><item><title>我的vim个性配置</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%88%91%E7%9A%84vim%E4%B8%AA%E6%80%A7%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%88%91%E7%9A%84vim%E4%B8%AA%E6%80%A7%E9%85%8D%E7%BD%AE/</guid><description>mac下安装vim
brew install vim 我的一些vim配置信息
&amp;#34; 显示行号 set number &amp;#34; 启用鼠标 set mouse=a &amp;#34; 显示标尺 set ruler &amp;#34; 历史纪录 set history=1000 &amp;#34; 输入的命令显示出来，看的清楚些 set showcmd &amp;#34; 状态行显示的内容 set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\&amp;#34;%d/%m/%y\ -\ %H:%M\&amp;#34;)} &amp;#34; 启动显示状态行1，总是显示状态行2 set laststatus=2 &amp;#34; 语法高亮显示 syntax on set fileencodings=utf-8,gb2312,gbk,cp936,latin-1 set fileencoding=utf-8 set termencoding=utf-8 set fileformat=unix set encoding=utf-8 &amp;#34; 配色方案 colorscheme desert &amp;#34; 指定配色方案是256色 set t_Co=256 set wildmenu &amp;#34; 去掉有关vi一致性模式，避免以前版本的一些bug和局限，解决backspace不能使用的问题 set nocompatible set backspace=indent,eol,start set backspace=2 &amp;#34; 启用自动对齐功能，把上一行的对齐格式应用到下一行 set autoindent &amp;#34; 依据上面的格式，智能的选择对齐方式，对于类似C语言编写很有用处 set smartindent &amp;#34; vim禁用自动备份 set nobackup set nowritebackup set noswapfile &amp;#34; 用空格代替tab set expandtab &amp;#34; 设置显示制表符的空格字符个数,改进tab缩进值，默认为8，现改为4 set tabstop=4 &amp;#34; 统一缩进为4，方便在开启了et后使用退格(backspace)键，每次退格将删除X个空格 set softtabstop=4 &amp;#34; 设定自动缩进为4个字符，程序中自动缩进所使用的空白长度 set shiftwidth=4 &amp;#34; 设置帮助文件为中文(需要安装vimcdoc文档set helplang=cn &amp;#34; 显示匹配的括号 set showmatch &amp;#34; 文件缩进及tab个数 au FileType html,python,vim,javascript setl shiftwidth=4 au FileType html,python,vim,javascript setl tabstop=4 au FileType java,php setl shiftwidth=4 au FileType java,php setl tabstop=4 &amp;#34; 高亮搜索的字符串 set hlsearch &amp;#34; 检测文件的类型 filetype on filetype plugin on filetype indent on &amp;#34; C风格缩进 set cindent set completeopt=longest,menu &amp;#34; 功能设置 &amp;#34; 去掉输入错误提示声音 set noeb &amp;#34; 自动保存 set autowrite &amp;#34; 突出显示当前行 set cursorline &amp;#34; 突出显示当前列 set cursorcolumn &amp;#34;设置光标样式为竖线vertical bar &amp;#34; Change cursor shape between insert and normal mode in iTerm2.</description></item><item><title>批量删除PBS程序</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4pbs%E7%A8%8B%E5%BA%8F/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4pbs%E7%A8%8B%E5%BA%8F/</guid><description>假设我们有 7823111到7823118的一系列PBS的程序，现在因为某原因要删除它们。我们可以通过以下命令对其批量删除。
第一个是
qdel {17979..18028} 第二个，如果所有的PBS程序都是某用户自己提交的，可以使用下面命令
qdel -u [user] 这两个能很好地进行PBS程序的批量删除。</description></item><item><title>服务器端使用IGV</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8igv/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8igv/</guid><description>1. 打开IGV 终端打开IGV
module load igv module show igv 提示以下信息
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- /depot/bioinfo/apps/modules/igv/2.3.60: -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- whatis(&amp;#34;Visualization tool for interactive exploration of genomic datasets &amp;#34;) load(&amp;#34;java&amp;#34;) prepend_path(&amp;#34;PATH&amp;#34;,&amp;#34;/group/bioinfo/apps/apps/IGV_2.3.60&amp;#34;) help([[ Notes: IGV (Integrative Genomics Viewer) version 2.3.60 Visualization tool for interactive exploration of genomic datasets http://www.broadinstitute.org/software/igv/home User Guide: http://www.broadinstitute.org/software/igv/UserGuide FAQ: http://www.broadinstitute.org/software/igv/FAQ Forum: https://groups.google.com/forum/#!forum/igv-help Info: /group/bioinfo/apps/apps/IGV_2.3.60/readme.txt Start with &amp;#34;igv.sh&amp;#34; Need X11 display: More config info at: https://www.rcac.purdue.edu/compute/carter/guide/#accounts_login_x11 ]]) 提示打开IGV通过igv.sh， 输入
igv.sh &amp;amp; 2. 搭配使用igvtools module load igvtools module show igvtools 提示以下信息</description></item><item><title>服务器端使用Jupyter-Hub及相关配置</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8jupyter-hub%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8jupyter-hub%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</guid><description>加载anaconda模块
module load anaconda/5.0.0-py36 创建自己的环境
conda create -n py36 python=3.6 ipython ipykernel 查看当前环境
conda info --envs 激活环境
source activate py36 安装nb_conda以在Jupyter notebook中调用不同的环境
conda install nb_conda 启动Jupyter notebook
jupyter notebook 终端运行jupyter notebook后打开了jupyter的网页，关闭jupyter的网页后同时按下ctrl和C键退出终端jupyter notebook。 k 完成之后返回原始环境
source deactivate py36</description></item><item><title>查R里面函数的源码</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E6%9F%A5r%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%9A%84%E6%BA%90%E7%A0%81/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E6%9F%A5r%E9%87%8C%E9%9D%A2%E5%87%BD%E6%95%B0%E7%9A%84%E6%BA%90%E7%A0%81/</guid><description>https://blog.csdn.net/bangemantou/article/details/17097101</description></item><item><title>热图实践</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E7%83%AD%E5%9B%BE%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E7%83%AD%E5%9B%BE%E5%AE%9E%E8%B7%B5/</guid><description>https://bioconductor.statistik.tu-dortmund.de/packages/3.1/bioc/vignettes/ComplexHeatmap/inst/doc/ComplexHeatmap.html https://www.bioconductor.org/packages/devel/bioc/vignettes/ComplexHeatmap/inst/doc/s9.examples.html https://www.bioconductor.org/packages/devel/bioc/vignettes/ComplexHeatmap/inst/doc/s3.a_list_of_heatmaps.html</description></item><item><title>详解MySQL及RMySQL</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E8%AF%A6%E8%A7%A3mysql%E5%8F%8Armysql/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E8%AF%A6%E8%A7%A3mysql%E5%8F%8Armysql/</guid><description>01. Mac上安装MySQL 访问MySQL的官网http://www.mysql.com/downloads/ 然后在页面中会看到“MySQL Community Server”下方有一个“download”点击。进入MySQL的下载界面（http://www.mysql.com/downloads/mysql/），如果你是用的Mac OS来访问的话那么就会默认为你选好了Mac OS X 平台，而下面罗列的都是在Mac OS上能用的MySQL的版本，如果是用的其他平台，在“Select Platform”选项的下拉列表中选一下就好了。按照安装步骤一路向下走，记得保存最后弹出框中的密码（它是你mysql root账号的密码）。 打开设置并且点击MySQL并开启MySQL服务。
此时我们在终端输入此时我们在命令行输入mysql -uroot -p命令会提示没有commod not found，我们还需要将mysql加入系统环境变量。
(1).进入/usr/local/mysql/bin,查看此目录下是否有mysql。
(2).执行vim ~/.bash_profile
PATH=$PATH:/usr/local/mysql/bin 添加完成后，按esc，然后输入wq保存。最后在命令行输入source ~/.bash_profile。 现在你就可以通过mysql -uroot -p登录mysql了，会让你输入密码，就是之前弹窗中记录的密码
至此MySQL成功安装到mac电脑下，可以进行下面的开发了。
02. 安装RMySQL 安装RMySQL非常简单，安装之后可以使用help命令查询包的介绍信息
install.packages(&amp;#34;RMySQL&amp;#34;) library(RMySQL) help(&amp;#34;RMySQL&amp;#34;) 03. RMySQL基本操作 创造一个新的数据库并使用，SQL查询可以通过dbSendQuery或dbGetQuery传给数据库管理系统。dbGetQuery传送查询语句，把结果以数据框形式返回。dbSendQuery传送查询，返回的结果是继承&amp;quot;DBIResult&amp;quot;的一个子类的对象。函数fetch用于获得查询结果的部分或全部行，并以列表返回。函数dbHasCompleted确定是否所有行已经获得了，而dbGetRowCount返回结果中行的数目。如果只是简单的读整个表，也可以用dbReadTable函数。
library(RMySQL) mydb = dbConnect(MySQL(), #数据库平台类型 user=&amp;#39;root&amp;#39;, #登录账号（MySQL初始安装时设置的账号） password=&amp;#39;password&amp;#39;, #登录密码（MySQL初始安装时设置的密码） host=&amp;#39;localhost&amp;#39;) # creating a database using RMySQL in R dbSendQuery(mydb, &amp;#34;CREATE DATABASE bookstore;&amp;#34;) dbSendQuery(mydb, &amp;#34;USE bookstore;&amp;#34;) # reconnecting to database we just created using following command in R : mydb = dbConnect(MySQL(), user=&amp;#39;root&amp;#39;, password=&amp;#39;password&amp;#39;, host=&amp;#39;localhost&amp;#39;, dbname=&amp;#34;bookstore&amp;#34;) # 重连数据库 dbSendQuery(mydb, &amp;#34;drop table if exists books, authors&amp;#34;) 在数据库中创造表：</description></item><item><title>详解R中的apply家族函数</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E8%AF%A6%E8%A7%A3r%E4%B8%AD%E7%9A%84apply%E5%AE%B6%E6%97%8F%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E8%AF%A6%E8%A7%A3r%E4%B8%AD%E7%9A%84apply%E5%AE%B6%E6%97%8F%E5%87%BD%E6%95%B0/</guid><description>R语言中提供了一系列apply()的函数，为数据分析中Split-Apply-Combine的策略提供了简洁方便的实现，这些函数的基本工作流程都是首先将数据按照某种规则划分（split）为较小的几部分，然后对各个部分应用（apply）某些操作，再将结果整合（combine）起来。关于Split-Apply-Combine策略的详细内容，可以参考Hadley Wickham的The Split-Apply-Combine Strategy for Data Analysis一文。
apply()家族主要有以下7类函数：
base::apply Apply Functions Over Array Margins base::by Apply a Function to a Data Frame Split by Factors base::eapply Apply a Function Over Values in an Environment base::lapply Apply a Function over a List or Vector base::mapply Apply a Function to Multiple List or Vector Arguments base::rapply Recursively Apply a Function to a List base::tapply Apply a Function Over a Ragged Array 1. apply()函数 # create a matrix of 10 rows x 2 columns m &amp;lt;- matrix(c(1:10, 11:20), nrow = 10, ncol = 2) # mean of the rows apply(m, 1, mean) [1] 6 7 8 9 10 11 12 13 14 15 # mean of the columns apply(m, 2, mean) [1] 5.</description></item><item><title>避免服务器上的老文件被系统删除</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E9%81%BF%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%80%81%E6%96%87%E4%BB%B6%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E9%81%BF%E5%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%80%81%E6%96%87%E4%BB%B6%E8%A2%AB%E7%B3%BB%E7%BB%9F%E5%88%A0%E9%99%A4/</guid><description>学校规定服务器上的文件大于60天没有修改或者接触就会被系统删除，之前吃过这个亏，最近又收到系统提醒，所以写个小脚本避免文件被删除
#! /bin/bash purgelist | tail -n +9 &amp;gt; purgelist.txt # purgelist用来寻找系统内大于60天没有被修改或者接触的文件，前9行是一些无关信息，将要移除的文件存到purgelist.txt中 #读取purgelist.txt文件，对每个文件读head，达到更改最后接触时间的目的 cat purgelist.txt | while read LINE do head $LINE done 最后在系统运行bash avoid_purge.sh即可。</description></item><item><title>酵母双杂交系统解析</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E9%85%B5%E6%AF%8D%E5%8F%8C%E6%9D%82%E4%BA%A4%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E9%85%B5%E6%AF%8D%E5%8F%8C%E6%9D%82%E4%BA%A4%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</guid><description>1. 简介 研究蛋白质之间的相互作用是当前蛋白质组学研究中的一个热点，常见的研究方法有以下多种： 其中酵母双杂交技术作为发现和研究在活细胞体内的蛋白质与蛋白质之间的相互作用的技术平台，在近几年来得到了广泛运用。
酵母双杂交系统是在真核模式生物酵母中进行的，研究活细胞内蛋白质相互作用，对蛋白质之间微弱的、瞬间的作用也能够通过报告基因的表达产物敏感地检测得到，它是一种具有很高灵敏度的研究蛋白质之间关系的技术。
酵母作为报告菌株还有以下好处
酵母的转化比较容易，已有的转化方法，如LiAc转化法，能将转化效率稳定在10^4 － 10^5/ug
酵母能同时容纳两种以上的质粒，从酵母中提取质粒也比较方便
酵母含有可直接进行选择的标记基因和特征性的报告基因，如LacZ之类简单明了的报告基因，通过颜色反应即可验证
酵母双杂交技术既可以用来研究哺乳动物基因组编码的蛋白质之间的互作，也可以用来研究高等植物基因组编码的蛋白质之间的互作。
因此，酵母双杂交技术在许多的研究领域中有着广泛的应用。
2. 原理 酵母双杂交系统的建立是基于对真核生物调控转录起始过程的认识。细胞起始基因转录需要有反式转录激活因子的参与。反式转录激活因子，例如酵母转录因子GAL4在结构上是组件式的（modular），往往由两个或两个以上结构上可以分开，功能上相互独立的结构域（domain）构成，其中有DNA结合功能域和转录激活结构域。这两个结合域将它们分开时仍分别具有功能，但不能激活转录，只有当被分开的两者通过适当的途径在空间上较为接近时，才能重新呈现完整的GAL4转录因子活性，并可激活上游激活序列的下游启动子，使启动子下游基因得到转录。
3. 步骤</description></item><item><title>链特异性测序及在IGV中的可视结果</title><link>https://kongjianyang.github.io/cn/2018/11/24/%E9%93%BE%E7%89%B9%E5%BC%82%E6%80%A7%E6%B5%8B%E5%BA%8F%E5%8F%8A%E5%9C%A8igv%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%86%E7%BB%93%E6%9E%9C/</link><pubDate>Sat, 24 Nov 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/24/%E9%93%BE%E7%89%B9%E5%BC%82%E6%80%A7%E6%B5%8B%E5%BA%8F%E5%8F%8A%E5%9C%A8igv%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%86%E7%BB%93%E6%9E%9C/</guid><description>1. 介绍 与链特异性测序相对的是传统的非链特异性文库。
通过链特异性测序，我们可以清楚的知道得到的 reads 跟转录本是同向的还是反向的。其中常见的链特异性测序的方法是dUTP方法。dUTP方法是先利用随机引物合成RNA的一条cDNA链，在合成第二条链的时候用dUTP代替dTTP，加adaptor后用UDGase处理，将有U的第二条cDNA降解掉。这样最后的insert DNA fragment都是来自于第一条cDNA，也就是dUTP叫fr-firststrand的原因。
2. 正反链 DNA 的正链和负链，就是那两条反向互补的链。参考基因组给出的那个链就是所谓的正链（forword），另一条链是反链（reverse）。但是这正反一定不能和正义链（sense strand）反义链（antisense strand）混淆，两条互补的DNA链其中一条携带编码蛋白质信息的链称为正义链，另一条与之互补的称为反义链。
3. IGV可视化 IGV可视化read时候有多项可以选
Read strand First-of-pair strand 图示按照igv 颜色选项中的read strand 方向进行区分，可以看到所有红色read都是在正链方向（注意正链不是正义链），而所有蓝色的read都是负链方向。 如果这个时候把颜色选项改为按照first of pair of strand来区分，会出现下图的变化。
如果对非链特异性文库使用的first of pair of strand可视化会出现下面的情况
可以看到同一个gene相关的read颜色还是混杂的，因为它并不是链特异性文库，所以不能分开first strand和second strand。</description></item><item><title>Pearson-spearman相关性计算的异同</title><link>https://kongjianyang.github.io/cn/2018/11/08/pearson_spearman/</link><pubDate>Thu, 08 Nov 2018 13:42:27 -0500</pubDate><guid>https://kongjianyang.github.io/cn/2018/11/08/pearson_spearman/</guid><description>&lt;p>三个相关性系数（pearson, spearman,
kendall）反应的都是两个变量之间变化趋势的方向以及程度，其值范围为-1到+1，0表示两个变量不相关，正值表示正相关，负值表示负相关，值越大表示相关性越强。&lt;/p></description></item><item><title>Figure with error bar and significant markers based on ggplot2</title><link>https://kongjianyang.github.io/en/2018/07/19/add-error-bar-and-significant-markers-to-the-figure-based-on-ggplot2/</link><pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/07/19/add-error-bar-and-significant-markers-to-the-figure-based-on-ggplot2/</guid><description>Create the data set
library(ggplot2) df &amp;lt;- data.frame(treatment = factor(c(1, 1, 1, 2, 2, 2, 3, 3, 3)), response = c(2, 5, 4, 6, 9, 7, 3, 5, 8),group = factor(c(1, 2, 3, 1, 2, 3, 1, 2, 3)),se = c(0.4, 0.2, 0.4, 0.5, 0.3, 0.2, 0.4, 0.6, 0.7)) head(df) ## treatment response group se ## 1 1 2 1 0.4 ## 2 1 5 2 0.2 ## 3 1 4 3 0.</description></item><item><title>Heatmap.2 and pheatmap in R practice</title><link>https://kongjianyang.github.io/en/2018/07/17/heatmap-2-and-pheatmap-in-r-practice/</link><pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/07/17/heatmap-2-and-pheatmap-in-r-practice/</guid><description>Part 1 heatmap.2 1. get the data library(gplots) ## ## Attaching package: &amp;#39;gplots&amp;#39; ## The following object is masked from &amp;#39;package:stats&amp;#39;: ## ## lowess library(RColorBrewer) data &amp;lt;- read.table(header = T, text = &amp;quot; ,var1,var2,var3,var4 measurement1,0.094,0.668,0.4153,0.4613 measurement2,0.1138,-0.3847,0.2671,0.1529 measurement3,0.1893,0.3303,0.5821,0.2632 measurement4,-0.0102,-0.4259,-0.5967,0.18 measurement5,0.1587,0.2948,0.153,-0.2208 measurement6,-0.4558,0.2244,0.6619,0.0457 measurement7,-0.6241,-0.3119,0.3642,0.2003 measurement8,-0.227,0.499,0.3067,0.3289 measurement9,0.7365,-0.0872,-0.069,-0.4252 measurement10,0.9761,0.4355,0.8663,0.8107&amp;quot;, fill = T, sep =&amp;quot;,&amp;quot;, row.names = 1) data ## var1 var2 var3 var4 ## measurement1 0.0940 0.6680 0.4153 0.4613 ## measurement2 0.1138 -0.3847 0.2671 0.</description></item><item><title>Practice for 'R for Biologists'</title><link>https://kongjianyang.github.io/en/2018/07/16/practice-for-r-for-biologists/</link><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/07/16/practice-for-r-for-biologists/</guid><description>Part 1 Basic R displays 7 digits by default. You can display more digits with options(). More than 15 digits could be unreliable. This is a global option; remains in effect until further notice
options(digits = 15) 2/3; 2.1^3.1 ## [1] 0.666666666666667 ## [1] 9.97423999265871 built-in mathematical constants and functions
2*pi ## [1] 6.28318530717959 sin(2*pi) ## [1] -2.44929359829471e-16 # This is e exp(1) ## [1] 2.71828182845905 sqrt(2) ## [1] 1.</description></item><item><title>Functional programming-Map, Reduce, Filter and Lambda</title><link>https://kongjianyang.github.io/en/2018/06/17/functional-programming-map-reduce-filter-and-lambda/</link><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/06/17/functional-programming-map-reduce-filter-and-lambda/</guid><description>This post will talk about four useful function in R programming. Map, Reduce, Filter and Lambda.
LAMBDA Lambda can be seen as a short (normally one line) function definition. There is no particular syntax for lambda in R, except that you don’t need to assign the function to a variable (function name), and also you will need to enclose the function using brackets or curly brace. For example:
(function add(x, y) x+y) {function add(x, y) x+y} We can pass the lambda function as a parameter to other functions e.</description></item><item><title>Add p value and significant marker for ggplot based on ggpubr</title><link>https://kongjianyang.github.io/en/2018/06/07/add-p-value-and-significant-marker-for-ggplot-based-on-ggpubr/</link><pubDate>Thu, 07 Jun 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/06/07/add-p-value-and-significant-marker-for-ggplot-based-on-ggpubr/</guid><description>The ‘ggpubr’ package provides some easy-to-use functions for creating and customizing ‘ggplot2’- based publication ready plots. -A. Kassambara.
Reference
1. Preparation install the package
install.packages(&amp;quot;ggpubr&amp;quot;) or you can install the latest version form github
if(!require(devtools)) install.packages(&amp;quot;devtools&amp;quot;) # if havn`t install devtools before, install it first devtools::install_github(&amp;quot;kassambara/ggpubr&amp;quot;) load package
library(ggpubr) load data
data(&amp;quot;ToothGrowth&amp;quot;) head(ToothGrowth) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.</description></item><item><title>Flow charts in R using DiagrammeR</title><link>https://kongjianyang.github.io/en/2018/05/08/flow-charts-in-r-using-diagrammer/</link><pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/05/08/flow-charts-in-r-using-diagrammer/</guid><description>library(DiagrammeR) DiagrammeR(&amp;quot;graph LR; A--&amp;gt;B; B--&amp;gt;C; B--&amp;gt;D&amp;quot;) {"x":{"diagram":"graph LR;\n A--B;\n B--C;\n B--D"},"evals":[],"jsHooks":[]} library(DiagrammeR) DiagrammeR(&amp;quot;graph TB; A(Rounded)--&amp;gt;B[Squared]; B---C{Rhombus!}; C--&amp;gt;D&amp;gt;flag shape]; C--&amp;gt;E((Circle));&amp;quot;) {"x":{"diagram":"graph TB;\n A(Rounded)--B[Squared];\n B---C{Rhombus!};\n C--Dflag shape];\n C--E((Circle));"},"evals":[],"jsHooks":[]} library(DiagrammeR) DiagrammeR(&amp;quot; graph TD; A[rect]-- add style --&amp;gt;A2[rect + style]; B{rhombus}---|+ some style|B2{rhombus + style}; C(rounded); D((circle)); style A2 fill:#c12,stroke-width:5px; style B2 fill:none, stroke-dasharray:10; &amp;quot;) {"x":{"diagram":"\n graph TD;\n A[rect]-- add style --A2[rect + style];\n B{rhombus}---|+ some style|B2{rhombus + style};\n C(rounded); D((circle)); \n style A2 fill:#c12,stroke-width:5px;\n style B2 fill:none, stroke-dasharray:10;\n"</description></item><item><title>Read Your Dataset in R From Copy Paste Text</title><link>https://kongjianyang.github.io/en/2018/05/04/read-your-dataset-in-r-from-copy-paste-words/</link><pubDate>Fri, 04 May 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/05/04/read-your-dataset-in-r-from-copy-paste-words/</guid><description>Problem Sometimes, we may want import a small dataset to our R code. And this may be annoying if we still need store data into a csv or txt file and then read dataset in from a file. A convenient way is read data in just from copy paste text. This post will solve this problem.
Solution Fisrt we need to store the data in a character variable</description></item><item><title>Set Significant Letters in the Bar Plot in ggplot2</title><link>https://kongjianyang.github.io/en/2018/05/04/set-letters-in-the-graph/</link><pubDate>Fri, 04 May 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/05/04/set-letters-in-the-graph/</guid><description>Problem As a biologist, one daily work is comparing the treatment and untreatment group and find if there are any significant difference. One common way is drawing a barplot with error bar and put the significant letters a little higher than the bar plot. Like a figure showing below: annotations for significant differences based on p value.
Results are usually drawn in a barplot. For all variables with the same letter, the difference between the means is not statistically significant.</description></item><item><title>ggplot2 plotting with error bars</title><link>https://kongjianyang.github.io/en/2018/05/03/ggplot2-plotting-with-error-bars/</link><pubDate>Thu, 03 May 2018 00:00:00 +0000</pubDate><guid>https://kongjianyang.github.io/en/2018/05/03/ggplot2-plotting-with-error-bars/</guid><description>Problem As a biologist, we need to plot a lot of data every day. To make our result more convincing, usually we need to add error bars on the bar plot results. In this Poster, I will show how to use ggplot2 to make a bar plot with error bar.
Solution Prepare Data The data we are using in this practice is ToothGrowth, we can get the data in datasets library.</description></item></channel></rss>
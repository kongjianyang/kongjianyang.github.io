---
title: "Meachine learning in R"
author: "KJY"
date: '2022-01-01'
slug: mechine_learning_in_R
categories: R
tags: []
lastmod: '2022-01-01T10:29:22-05:00'
keywords: []
description: ''
comment: no
toc: no
autoCollapseToc: no
postMetaInFooter: no
hiddenFromHomePage: no
contentCopyright: no
reward: no
mathjax: yes
mathjaxEnableSingleDollar: yes
mathjaxEnableAutoNumber: yes
hideHeaderAndFooter: no
flowchartDiagrams:
  enable: no
  options: ''
sequenceDiagrams:
  enable: no
  options: ''
---

```{r}
library(tidyverse)
```

## k-means clustering

The k-means clustering algorithms aims at partitioning n observations into a fixed number of k clusters. The algorithm will find homogeneous clusters.


```{r eval=FALSE, include=FALSE}
stats::kmeans(x, centers = 3, nstart = 10)
```


where

x is a numeric data matrix
centers is the pre-defined number of clusters
the k-means algorithm has a random component and can be repeated nstart times to improve the returned model

```{r}
i <- grep("Length", names(iris))
x <- iris[, i]
cl <- kmeans(x, 3, nstart = 10)
plot(x, col = cl$cluster)
```

```{r}
sample_n(x, 5)
```

```{r}
cl$cluster
```


```{r}
cl
```


### How does k-means work

Initialisation: randomly assign class membership

```{r}
set.seed(12)
init <- sample(3, nrow(x), replace = TRUE)

init
plot(x, col = init)
```

Iteration:

Calculate the centre of each subgroup as the average position of all observations is that subgroup.
Each observation is then assigned to the group of its nearest centre.
Itâ€™s also possible to stop the algorithm after a certain number of iterations, or once the centres move less than a certain distance.

```{r}

centres <- sapply(1:3, function(i) colMeans(x[init == i, ], ))

centres

centres <- t(centres)

points(centres[, 1], centres[, 2], pch = 19, col = 1:3)

centres

rbind(centres, x)

tmp <- dist(rbind(centres, x))

ki <- apply(tmp, 1, which.min)
ki <- ki[-(1:3)]
```



```{r}
par(mfrow = c(1, 2))
plot(x, col = init)

# calculate mean value of each cluster now
centres <- sapply(1:3, function(i) colMeans(x[init == i, ], ))
centres <- t(centres)
points(centres[, 1], centres[, 2], pch = 19, col = 1:3)

#calculate Euclidean distance between each row in matrix
tmp <- dist(rbind(centres, x))
tmp <- as.matrix(tmp)[, 1:3]

ki <- apply(tmp, 1, which.min)
ki <- ki[-(1:3)]

plot(x, col = ki)
points(centres[, 1], centres[, 2], pch = 19, col = 1:3)
```


Termination: Repeat iteration until no point changes its cluster membership.

```{r}
cl$tot.withinss
```


```{r}
ks <- 1:5
tot_within_ss <- sapply(ks, function(k) {
    cl <- kmeans(x, k, nstart = 10)
    cl$tot.withinss
})
plot(ks, tot_within_ss, type = "b")
```







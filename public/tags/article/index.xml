<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>article on KJY</title>
    <link>https://kongjianyang.github.io/tags/article/</link>
    <description>Recent content in article on KJY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 03 Sep 2023 13:26:03 -0700</lastBuildDate><atom:link href="https://kongjianyang.github.io/tags/article/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python批量下载被引文章</title>
      <link>https://kongjianyang.github.io/cn/2023/09/03/python-google-scholar/</link>
      <pubDate>Sun, 03 Sep 2023 13:26:03 -0700</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2023/09/03/python-google-scholar/</guid>
      <description>问题 希望能批量下载自己的一篇文章被哪些文章所应用，需要知道被引文章的基本信息，包括发表日期，发表期刊等等。
方法 使用python和R方案进行解决
首先是python脚本抓取信息
#!/usr/bin/env python import scholarly from scholarly import ProxyGenerator from scholarly import scholarly # pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上 # python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化 import pickle # Set up a ProxyGenerator object to use free proxies # This needs to be done only once per session # need to register and got the API pg = ProxyGenerator() success = pg.ScraperAPI(&amp;#34;YOUR API&amp;#34;) # Now search Google Scholar from behind a proxy scholarly.use_proxy(pg) search_query = scholarly.</description>
    </item>
    
    <item>
      <title>Switch函数妙用</title>
      <link>https://kongjianyang.github.io/cn/2023/08/19/switch/</link>
      <pubDate>Sat, 19 Aug 2023 21:14:13 -0700</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2023/08/19/switch/</guid>
      <description>R 中的 switch 函数是一种控制流程的函数，它允许您根据变量的值执行不同的操作。switch 函数的语法如下：
switch(value, case1 = statement1, case2 = statement2, ..., default = statement_default) 其中，value 是您要测试的变量，case1、case2 等是您要执行的操作，statement_default 是默认操作。
例如，以下代码使用 switch 函数根据变量 day 的值来打印不同的星期几：
day &amp;lt;- &amp;quot;Monday&amp;quot; switch(day, Monday = &amp;quot;今天是星期一&amp;quot;, Tuesday = &amp;quot;今天是星期二&amp;quot;, Wednesday = &amp;quot;今天是星期三&amp;quot;, Thursday = &amp;quot;今天是星期四&amp;quot;, Friday = &amp;quot;今天是星期五&amp;quot;, Saturday = &amp;quot;今天是星期六&amp;quot;, Sunday = &amp;quot;今天是星期天&amp;quot;) 这段代码将打印以下输出：
今天是星期一 与常用处理TRUE和FALSE条件的if相比，switch语句主要用于处理数字或者字符串，并根据输入返回某个分支。
switch 函数有许多好处，包括：
它易于使用。 它可以简化代码。 它可以提高代码的可读性和可维护性。 它可以提高代码的性能。 switch 函数可以用来替换 if-else 语句，从而简化代码。
除此之外，switch函数还能和function连用，实现复杂功能
FUN &amp;lt;- function(df, do.this){ switch(do.this, T1={X &amp;lt;- t(df) P &amp;lt;- nrow(df) }, T2={X &amp;lt;- colMeans(df) P &amp;lt;- ncol(df) }, stop(&amp;quot;Enter something that switches me!</description>
    </item>
    
    <item>
      <title>R语言中的非标准计算</title>
      <link>https://kongjianyang.github.io/cn/2023/08/15/nse/</link>
      <pubDate>Tue, 15 Aug 2023 11:49:19 -0700</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2023/08/15/nse/</guid>
      <description>首先R语言中的非标准计算现在很混乱，在发展过程中也不是很好理清，但是需要掌握，可以给日常工作带来便捷。
R语言中有原生的非标准计算，主要是base包的函数，也有tidyeval，rlang包提供的非标准计算。
 rlang是一个包，作者还是Hadley Wickham，提供了R语言的核心语言功能。它不是base R的一部分，但它是许多R包的基础。rlang提供了强大的工具来处理R语言的语法，这使得它非常适合编写高效和可扩展的R代码。
 R base R base包中的实现非标准计算的函数有：
 语法解析：substitute(), parse(), deparse() 表达式构造：quote() 表达式求值：eval(), source() 表达式：expression()  # parse主要负责把字符解析为R语言表达式。 # 表达式是可以被求值的代码。 parse(text = &amp;quot;1+2&amp;quot;) # deparse是相反的，是把R表达式逆解析为字符。 deparse(expression(1+2)) # quote则是捕捉未计算的表达式，不进行计算（求值） quote(1+2) # eval来完成对表达式进行计算（求值） eval(quote(1+2)) 一个综合性例子
rm(list = ls()) # quote是捕捉未计算的表达式 a1 &amp;lt;- quote(mean(mtcars$wt)) # expression是表达式 a2 &amp;lt;- expression(mean(mtcars$wt)) # 不加text会报错 a3 &amp;lt;- parse(text = &amp;quot;mean(mtcars$wt)&amp;quot;) # 都能计算出 3.21725 eval(a1) eval(a2) eval(a3) # 逆解析的结果不同 deparse(a1) deparse(a2) deparse(a3) tidyeval 在tidyverse工具链中，tidyeval提供比较一致的非标准计算服务。tidyeval的函数主要在rlang包中。</description>
    </item>
    
    <item>
      <title>生存分析入门</title>
      <link>https://kongjianyang.github.io/cn/2023/08/08/%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 08 Aug 2023 15:58:44 -0700</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2023/08/08/%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90/</guid>
      <description>作为临床分析中的重要一环，今天入门生存分析。
生存分析（survival analysis）是生物医学研究中常用的分析方法。在队列随访研究中，我们会事先定义一些观察终点，比如肿瘤复发、患者死亡、血压达标等，这些终点称为事件（event）。从研究开始到发生事件的时间间隔称为生存时间（survival time）。
由于生存时间数据具有以下两个特点，所以提出生存分析这一特殊的分析方法：
（1）偏态分布：生存时间通常具有明显的偏态分布，有正态分布假设的统计方法不能适用。 （2）删失（censoring）：研究对象在观察时间内没有发生事件称为删失。一种情况是研究对象在中途失访或退出，导致没有观察到事件；另一种情况是超过了最长的随访时间事件仍未发生。删失数据是一种不完整数据，是生成分析独有的重要组成部分。
生存分析使用的方法：
 Kaplan-Meier plots to visualize survival curves（根据生存时间分布，估计生存率以及中位生存时间，以生存曲线方式展示，从而分析生存特征，一般用Kaplan-Meier法，还有寿命法） Log-rank test to compare the survival curves of two or more groups（通过比较两组或者多组之间的的生存曲线，一般是生存率及其标准误，从而研究之间的差异，一般用log rank检验） Cox proportional hazards regression to describe the effect of variables on survival（用Cox风险比例模型来分析变量对生存的影响，可以两个及两个以上的因素，很常用）  所以一般做生存分析，可以用KM（Kaplan-Meier）方法估计生存率，做生存曲线，然后可以根据分组检验一下多组间生存曲线是否有显著的差异，最后用Cox风险比例模型来研究下某个因素对生存的影响
Kaplan-Meier生存曲线估计 在t检验或回归分析中，我们估计的是研究对象的一些参数，比如均值、标准差、回归系数等。而在生存分析中，我们得到的不是单个特定的数值，而是一条曲线，称为生存曲线（survival curve）。曲线对应的函数称为生存函数（survival function），用S(t)表示，其定义为：
S(t)是个体生存超过时间t的概率
以时间t为横坐标，S(t)为纵坐标，绘制出来的曲线就是生存曲线。生存曲线具有两个特点：
（1）显然，在观察开始的时候，所有个体都是存活的，所以S(t=0)=1； （2）时间越长，生存的概率越小，所以S(t)是递减的。
表1展示了KM法的计算过程。
表1一共包含5列，最后两列可以通过前三列计算出来。第一列是生存时间t，注意不包含删失的时间，但包含时间0。第二列是t时刻事件发生个体数，可以看到大部分数据为1。第三列是t时刻仍然存活的个体数。
前三行准备好后，第四行就是一个简单的数学计算。除了第一行外，其余各行的第五列等于上一行的第五列乘以本行的第四列。
假设检验Log-rank 在很多情况下，我们需要比较两组生存曲线之间有无差别，比如某种新药组的患者生存率是否比常规药物组要高。一种容易想到的方法是指定一个时间点，比如2年，分别计算出两组生存时间超过2年的个案数，然后进行2×2列联表的χ2检验。这个方法有两个明显的缺点：一是由于删失的存在，难以准确计算生存率；二是时间长度可以随意指定，带来分析结果的偏差。
Log-rank检验的零假设是两组生存曲线一样的。如果零假设成立，那么两组内的事件发生个体数之比应该等于两组样本数之比，由此计算出事件发生的期望数。Log-rank方法就是分别将两组所有时间点的期望数加起来，与所有观察数进行比较。
Cox比例风险回归模型 在临床研究中，有许多情况，其中几个已知量（称为 协变量covariates）可能会影响患者的预后。
例如，假设比较了两组患者：有和没有特定基因型的患者。如果其中一组还包含较年长的个体，则生存率的任何差异都可能归因于基因型或年龄，或两者都有。因此，在调查与任何一个因素相关的生存率时，通常需要针对其他因素的影响进行调整。
Cox模型的目的是同时评估几个因素对生存的影响。换句话说，它允许我们检查特定因素如何影响特定时间点特定事件（例如，感染，死亡）的发生率。该比率通常称为风险比率。
Cox模型与Kaplan-Meier法：
Kaplan-Meier法是非参数法，而Cox模型是半参数法，一般来说在符合一定条件下，后者的检验效应要大于前者 Kaplan-Meier法一般处理单因素对研究生存结局的影响，而Cox模型可以同时处理多个因素对生存结局的影响
当预测变量为分类变量时（例如：治疗A与治疗B；男性与女性），Kaplan-Meier曲线和对数秩检验才有用。对于定量预测指标（例如基因表达，体重或年龄），它们并不容易工作。
一种替代方法是Cox比例风险回归分析，它既适用于定量预测变量也适用于类别变量。此外，Cox回归模型扩展了生存分析方法，可以同时评估几种风险因素对生存时间的影响。
R语言分析 # 确保在导入前安装好 library(survival) library(dplyr) library(survminer) library(tidyverse) 我们将使用的核心函数包括：</description>
    </item>
    
    <item>
      <title>R语言编程补充</title>
      <link>https://kongjianyang.github.io/cn/2023/02/07/advanced_r/</link>
      <pubDate>Tue, 07 Feb 2023 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2023/02/07/advanced_r/</guid>
      <description>R编程补充 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>Python机器学习</title>
      <link>https://kongjianyang.github.io/cn/2022/12/23/python-ml/</link>
      <pubDate>Fri, 23 Dec 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/12/23/python-ml/</guid>
      <description>参考教程：
系列教程 (showmeai.tech) argparse模块在jupyter notebook中传参 在python代码文件中，通常需要传参，传参就需要经常使用argparse。使用argparse模块在py文件中是正常的，但是jupyter notebook就会报错。</description>
    </item>
    
    <item>
      <title>MySQL简单学习</title>
      <link>https://kongjianyang.github.io/cn/2022/12/13/mysql/</link>
      <pubDate>Tue, 13 Dec 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/12/13/mysql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>R整洁代码</title>
      <link>https://kongjianyang.github.io/cn/2022/12/05/rtidy/</link>
      <pubDate>Mon, 05 Dec 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/12/05/rtidy/</guid>
      <description>R整洁代码 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>利用Python进行文件重命名</title>
      <link>https://kongjianyang.github.io/cn/2022/09/24/python/</link>
      <pubDate>Sat, 24 Sep 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/09/24/python/</guid>
      <description># !#/usr/bin/python3 import os import re import datetime dir = os.getcwd() files = os.listdir(&amp;#34;./&amp;#34;) # 判断字符串 oldStr = r&amp;#34;(\d{4}-\d{1,2}-\d{1,2}-)&amp;#34; newStr = &amp;#34;&amp;#34; #判断生成时间 now = datetime.datetime.now() deltaH = datetime.timedelta(days=360) d = os.walk(dir) for path,dirList,fileList in d: for fileName in fileList: oldFile = os.path.join(path, fileName) if re.findall(oldStr, fileName): f = datetime.datetime.fromtimestamp(os.path.getmtime(oldFile)) if f &amp;gt; (now-deltaH): print(oldFile) newName = re.sub(oldStr, newStr, fileName) newFile = os.path.join(path, newName) if os.path.isfile(oldFile): os.rename(os.path.join(path, fileName),newFile) print(newFile) pass else: pass </description>
    </item>
    
    <item>
      <title>GSEA和GSVA分析</title>
      <link>https://kongjianyang.github.io/cn/2022/06/28/gsea/</link>
      <pubDate>Tue, 28 Jun 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/06/28/gsea/</guid>
      <description>GSEA全称Gene Set Enrichment Analysis，GSVA全称Gene Set Variation Analysis，它们都是基于基因集开展的分析，因此我们先要了解基因集的定义。基因集顾名思义就是一些基因的集合，任何一些基因放在一起都可以叫做基因集，但是我们用来分析的基因集要求有一定的生物学意义。
MSigDB（Molecular Signatures Database）数据库中定义了已知的基因集合：http://software.broadinstitute.org/gsea/msigdb 包括H和C1-C7八个系列（Collection），每个系列分别是：
H:hallmark gene sets （癌症）特征基因集合，共50组，最常用； C1: positional gene sets 位置基因集合，根据染色体位置，共326个，用的很少； C2: curated gene sets：（专家）校验基因集合，基于通路、文献等： C3: motif gene sets：模式基因集合，主要包括microRNA和转录因子靶基因两部分 C4: computational gene sets：计算基因集合，通过挖掘癌症相关芯片数据定义的基因集合； C5: GO gene sets：Gene Ontology 基因本体论，包括BP（生物学过程biological process，细胞原件cellular component和分子功能molecular function三部分） C6: oncogenic signatures：癌症特征基因集合，大部分来源于NCBI GEO 发表芯片数据 C7: immunologic signatures: 免疫相关基因集合。
常规GO/KEGG富集分析需要设定阈值过滤差异基因，阈值太宽富集的结果太多，阈值太严又可能会遗漏一些关键结果。GO/KEGG富集的结果通常还很宽泛，并不能很好地解释生物学现象。有鉴于此，Broad研究所开发了基因集富集分析(GSEA)方法。GSEA使用无监督算法，不用过滤任何基因，配合MSigDB数据库使用，更容易找到解释生物学现象的基因集.
GSEA分析要先将样本做组间对比分析, 对比分析之后要按结果将基因排序，以差异倍数方法为例，把所有基因按差异倍数(FC)的值降序排列以供后续分析。
上图小人脚下的小方块代表排序好的差异基因列表，蓝色之外的其他色块代表属于某个基因集的基因，如黄色属于基因集A，绿色属于基因集B。最下面高低不等的竖条代表与基因列表对应的FC值，红色上调、蓝色下调、黄色没有变化。基因集的富集分析需要经历三步：
基因集A富集分析时，小人从基因列表的左端走到右端，每经过一个蓝色基因扣分，每遇到一个黄色基因加分，扣分时与FC无关，加分时考虑FC的权重。基因集A最终的富集分数(ES)是小人曾经得过的最高/低分，实际公式比这复杂，但基本理念如此。
采用置换检验(Permutation testing)计算基因集A的显著性，即p值。
基因集A富集分析完成后，按上述同样的方法完成基因集B、C直至所有输入基因集的分析。所有需要富集分析的基因集都计算ES和p值之后，将ES转换为标准富集分数(NES)，并计算校正后p值。
(1)背景基因排序：将全部基因按照某种指标（差异分析p值，表型相关性，表达量等）进行排序，比如log2FC排序。
(2)目标基因富集：将某个特定类型的基因在排序表中标出，目标基因可以是某个通路或GO terms的基因等。
(3)计算富集分数：使用加权法，计算ES值变化。对位于中部（与性状相关性低）的部分采用较小的权值，所以越集中在两端，与表型的相关性越高。ES曲线最大值为富集分数（Enrichment Score）。
(4)Permutation test：对基因集的ES值进行显著性检验及多重假设检验，从而计算出显著富集的基因集。
enrichmentScore：富集得分。ES 反映基因集中的基因（S）在排序列表基因（L）的两端富集的程度。计算方式是，从基因集 L 的第一个基因开始，计算一个累计统计值。当遇到一个落在 D 里面的基因，则增加统计值。遇到一个不在 S 里面的基因，则降低统计值。每一步统计值增加或减少的幅度与基因的表达变化程度（更严格的是与基因和表型的关联度，可能是 fold-change，也可能是 pearson corelation 值）是相关的（可以是线性相关，也可以是指数相关）。富集得分 ES 最后定义为最大的峰值。正值 ES 表示基因集在列表的顶部富集，负值 ES 表示基因集在列表的底部富集。</description>
    </item>
    
    <item>
      <title>single cell RNA-seq分析入门</title>
      <link>https://kongjianyang.github.io/cn/2022/06/03/single-cell-rna-seq%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 03 Jun 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/06/03/single-cell-rna-seq%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</guid>
      <description>scRNA toturial// Pandoc 2.9 adds attributes on both header and div. We remove the former (to// be compatible with the behavior of Pandoc :first-child&#34;);var i, h, a;for (i = 0; i 0) h.removeAttribute(a[0].name);}});/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */!function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;</description>
    </item>
    
    <item>
      <title>One sample proportion test (单比率检验)</title>
      <link>https://kongjianyang.github.io/cn/2022/05/28/one_sample_proportion/</link>
      <pubDate>Sat, 28 May 2022 16:03:40 -0600</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/28/one_sample_proportion/</guid>
      <description>One sample proportion test (单比率检验) // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;</description>
    </item>
    
    <item>
      <title>Single_cell_sequencing入门</title>
      <link>https://kongjianyang.github.io/cn/2022/05/23/scrna/</link>
      <pubDate>Mon, 23 May 2022 16:03:40 -0600</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/23/scrna/</guid>
      <description>Reference:
https://broadinstitute.github.io/KrumlovSingleCellWorkshop2020/index.html https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#finding-differentially-expressed-features-cluster-biomarkers- https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html Background 单细胞RNA-seq能够独立地提供每个细胞的RNA表达谱，并鉴定异质细胞群中的稀有细胞。尽管肿瘤异质性可归因于累积突变，但即使是遗传上相同的细胞在相同环境下也可能表现出基因和蛋白表达水平的差异，从而导致耐药性的产生。单细胞RNA-seq就能够发现这些稀有个体。
单细胞RNA-seq的流程
当然，单细胞RNA-seq的开展绝非易事，需要用到一系列尖端技术。大家首先要高效分离单细胞，然后进行RNA提取、逆转录、文库制备和测序，最后再通过生物信息学软件进行数据分析。其中，第一步 – 单细胞分离就相当棘手。
单细胞分离 从异质性的细胞群体中分离单细胞，目前的选择有不少，新方法也在不断面世。选择分离方法时，您可能需要考虑它是高通量还是低通量，以及是盲选还是有偏向的选择（基于某个参数）。
一些高通量的技术，比如最常用的荧光激活细胞分选（FACS）和磁性激活细胞分选（MACS），可根据细胞的大小/形状或细胞表面标志物的表达进行有偏向的选择，而基于微流体和液滴的技术可实现细胞的无偏向分离。不过，需要注意的是，组织/细胞的解离过程可能会改变RNA的表达谱。
RNA-Seq方案 标准的文库制备方案适用于10-100 ng的DNA起始材料。然而，单个细胞平均只含有10 pg的总RNA。因此，RNA提取和文库制备的流程必须经过调整和优化，才能用于单细胞材料。
首先，需要裂解分离出的单细胞，以获得RNA。这个步骤可通过自动化设备完成。当然，细胞裂解和RNA纯化的操作可同时进行。
然后，大多数方案是通过polyA选择来富集mRNA，并利用经过修饰的oligo dT引物来进行逆转录。在逆转录的过程中，有些方案利用独特分子标识符（UMI）对单分子进行标记，这些是随机的六核苷酸，可以更精确地定量单细胞中mRNA分子的初始量。之后，通过体外转录或PCR扩增cDNA，然后将扩增好的cDNA文库用于文库制备和高通量测序。
PCR方法的优点在于能够产生全长cDNA。不过，对于不同片段（如GC含量较高），PCR的效率可能不同，导致文库的覆盖度不均匀。另一方面，体外转录产生的文库能够避免PCR的序列偏向，但有些序列的转录效率低，导致序列drop-out或不完整。
数据分析 由于每个单细胞都是独特的，不可能开展重复实验并评估噪音。因此，必须采取一些质量控制手段，以确保数据的可靠性。专家建议，向每个细胞裂解液中加入已知序列和数量的合成mRNA，如外源RNA对照联盟（ERCC）开发的加标RNA。这些RNA的读数将提供样本间差异的信息。
总的来说，单细胞水平的转录组分析可以揭示细胞群体中的细胞异质性，强调了个别细胞的与众不同。此外，同时分析多种分子（如DNA、RNA和蛋白质）的方法也不断被开发出来。这种更全面的单细胞组图有望进一步加深我们对生物学过程的了解，对未来的科研及临床研究大有裨益。
Data analysis In contrast to bulk RNA-seq, scRNA-seq provides quantitative measurements of the expression of every gene in a single cell.</description>
    </item>
    
    <item>
      <title>Single_cell_sequencing入门</title>
      <link>https://kongjianyang.github.io/cn/2022/05/23/scrna/</link>
      <pubDate>Mon, 23 May 2022 16:03:40 -0600</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/23/scrna/</guid>
      <description>Single_cell_sequencing入门 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>Linux下删除特定前缀名文件的快捷方式</title>
      <link>https://kongjianyang.github.io/cn/2022/05/22/find_remove/</link>
      <pubDate>Sun, 22 May 2022 10:43:55 -0600</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/22/find_remove/</guid>
      <description>有时候folder下会有奇怪前缀名的文件，如下
./~$Varian_Intern3.pptx ./~$Varian_Interview_With_Director.pptx ./~$Varian_Intern2.pptx 通过正常rm是没有办法删除的，这时候可以使用find的功能进行删除
find . -name ~$\* -delete 这样就可以找到并且删除文件了</description>
    </item>
    
    <item>
      <title>Python绘制地图热图</title>
      <link>https://kongjianyang.github.io/cn/2022/05/21/map_heatmap/</link>
      <pubDate>Sat, 21 May 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/21/map_heatmap/</guid>
      <description>2022-05-21-Python绘制地图热图 pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight .hll { background-color: var(--jp-cell-editor-active-background) } .highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) } .highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */ .</description>
    </item>
    
    <item>
      <title>为Mac系统添加QuickLook插件</title>
      <link>https://kongjianyang.github.io/cn/2022/05/18/html/</link>
      <pubDate>Wed, 18 May 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/18/html/</guid>
      <description>安装命令：brew cask install  卸载命令：brew cask uninstall  软件包被安装的路径： /Users/用户名称/Library/QuickLook
QuickLook（快速预览）是 Mac OS X 中一项很好的功能。用户选择文件后，按下空格键即可快速预览。因为不用点击打开，还能使用方向键切换，从而节省了大量的时间。但对于开发者来说，系统内置的功能还不能完全满足需求。
需要拓展安装一些插件
最方便的方式是通过brew进行
查找所有插件
brew search quicklook ==&amp;gt; Formulae quickjs ==&amp;gt; Casks caskroom/cask/epubquicklook ipynb-quicklook caskroom/cask/gltfquicklook osirix-quicklook caskroom/cask/ipynb-quicklook quicklook-csv caskroom/cask/osirix-quicklook quicklook-json ✔ caskroom/cask/quicklook-csv quicklook-pat caskroom/cask/quicklook-json ✔ quicklook-pfm caskroom/cask/quicklook-pat quicklookapk caskroom/cask/quicklook-pfm quicklookase ✔ caskroom/cask/quicklookapk receiptquicklook caskroom/cask/quicklookase ✔ ttscoff-mmd-quicklook caskroom/cask/receiptquicklook webpquicklook ✔ caskroom/cask/ttscoff-mmd-quicklook quickbooks caskroom/cask/webpquicklook ✔ quickboot epubquicklook quickjson gltfquicklook quicknfo 安装一些插件
brew install --cask qlimagesize qlvideo qlmarkdown brew install --cask qlcolorcode quicklook-json qlstephen suspicious-package provisionql quicklook-csv brew install highlight luarocks # 相关的依赖包 </description>
    </item>
    
    <item>
      <title>Linux上的定时任务</title>
      <link>https://kongjianyang.github.io/cn/2022/05/17/crontab/</link>
      <pubDate>Tue, 17 May 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/17/crontab/</guid>
      <description>介绍 我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表
我们常用的命令如下：
crontab [-u username]　//省略用户表表示操作当前用户的crontab -e (编辑工作表) -l (列出工作表里的命令) -r (删除工作作) 我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。
Each line of a crontab file represents a job, and looks like this:
# ┌───────────── minute (0 - 59) # │ ┌───────────── hour (0 - 23) # │ │ ┌───────────── day of the month (1 - 31) # │ │ │ ┌───────────── month (1 - 12) # │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday; # │ │ │ │ │ 7 is also Sunday on some systems) # │ │ │ │ │ # │ │ │ │ │ # * * * * * The syntax of each line expects a cron expression made of five fields which represent the time to execute the command, followed by a shell command to execute.</description>
    </item>
    
    <item>
      <title>macOS上的神器</title>
      <link>https://kongjianyang.github.io/cn/2022/05/17/good_tools/</link>
      <pubDate>Tue, 17 May 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/17/good_tools/</guid>
      <description>Alfred 有时候对于某一特定的App，你想要查看最近利用这个App打开的文档，比如想查看上一次用Preview浏览的文件，用QuickTime最近观看的视频等等。在Alfred中可以很方便的查询App最近的浏览文件。在Alfred输入框中输入某个App的名字，然后按下Right键打开关于这个App的操作列表，排在列表的第一个选项就是关于这个App最近的浏览记录“Recent Documents”，按下Enter键选择这个选项，就会在Alfred中呈现这个App最近打开的文件记录列表，你可以在其中选择想要的文件再次利用这个App打开。举个例子，比如我想要查看利用Preview最近的浏览记录，就可以在Alfred中输入“Preview”，然后按下Right键就能打开Preview的操作列表，选择排在第一位的Recent Documents选项，按下Enter键就能打开Preview最近的历史列表，可以选择需要的文档在Preview中打开，非常方便。
Right其实是control键
alfred搜索到文件后打开所在目录
按住 |Command| 键，再按回车 |Return| ，打开的就不是文件，而是其所在文件夹。</description>
    </item>
    
    <item>
      <title>R语言purrr包详细介绍</title>
      <link>https://kongjianyang.github.io/cn/2022/05/17/purrr/</link>
      <pubDate>Tue, 17 May 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/17/purrr/</guid>
      <description>R语言purrr包详细介绍 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>R语言ggblanket美化ggplot的图</title>
      <link>https://kongjianyang.github.io/cn/2022/05/15/ggblanket/</link>
      <pubDate>Sun, 15 May 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/15/ggblanket/</guid>
      <description>R语言ggblanket美化ggplot图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>其他源产生的html文件兼容hug</title>
      <link>https://kongjianyang.github.io/cn/2022/05/07/html/</link>
      <pubDate>Sat, 07 May 2022 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/07/html/</guid>
      <description>迁移博客系统之后之前一些产生的html文件不能在hugo系统中显示了，例如从rmd或者jupyter生产的html文件，尝试之后发现问题是生产的html文件没有frontmatter，加上之后就能解决问题。
参考：[SOLVED] Using HTML for content pages instead of Markdown - support - HUGO (gohugo.io) 所以在html文件上加下如下内容就能使之显示。
+++ title = &amp;quot;R语言元编程&amp;quot; date = &amp;quot;2020-04-17T12:15:02-00:00&amp;quot; categories = &amp;quot;R&amp;quot; tags = &amp;quot;R&amp;quot; +++ &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：
--- title: Hello World date: 2013/7/13 20:46:25 --- 补充知识 仅仅使用 markdown 格式写完文章是不够的，还需要在 .md 文档前面声明文档的信息，告诉 Hugo 这篇文章的标题、写作时间，这个时候就需要用到 Hugo Front Matter Formats 元数据格式。
Front Matter一般放在文章的最顶部，Hugo支持三种书写格式，
 TOML使用+++来包裹内容 YAML使用---来包裹内容 JSON使用{和}来包裹内容  可配置的内容见Hugo官方文档: front-matter 。
在使用hugo new来创建文章时，会查找archetypes下的内容并填充到文章内容，查找archetypes原型内容的顺序如下:</description>
    </item>
    
    <item>
      <title>R语言stringr学习</title>
      <link>https://kongjianyang.github.io/cn/2022/05/05/strigr/</link>
      <pubDate>Thu, 05 May 2022 23:57:39 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/05/strigr/</guid>
      <description>stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。
对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。
R语言中处理字符串主要有stringi和stringr两种，更加推荐使用stringr,因为stringi命令太多太复杂了&amp;hellip;
来自Hadley Wickham的评价
 stringi provides tools to do anything we could ever want to do with strings, where stringr provides tools to do the most common 95% of operations. This allows stringr to be much simpler, and the cost of some flexibility. Additionally stringi is implemented in C using the ICU string library, so it&amp;rsquo;s very fast and very correct (it deals with unicode better than base R).</description>
    </item>
    
    <item>
      <title>R语言必须掌握的包</title>
      <link>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</link>
      <pubDate>Wed, 04 May 2022 22:21:53 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</guid>
      <description>这是网络上收集的内容，具有一些参考价值
qinwf/awesome-R: A curated list of awesome R packages, frameworks and software. (github.com) 但是对于我的日常来讲，会有以下一些包进行日常使用，可以常用常新
1. 数据导入 【精】readr：实现表格数据的快速导入。https://readr.tidyverse.org readxl：读取Microsoft Excel电子表格数据
dplyr：提供了一个访问常见数据库的接口
data.table：data.table包的fread()函数可以快速读取大数据集
rio：一站式导入/导出几乎所有格式数据（使用import()/export()函数）
2. 数据整理 【精】tidyr：用于整理表格数据的布局
【精】dplyr：用于将多个数据表连接成一个整齐的数据集
purrr：函数式编程工具，在做数据整理时非常有用。
3. 数据可视化 【精】ggplot2及其扩展：ggplot2包提供了一个强大的绘图系统，并实现了以下扩展
ggthemes：提供扩展的图形风格主题
【精】ggpubr: 生成杂志期刊等出版物的图形的包，是ggplot的一个补充。
ggrepel：用于避免图形标签重叠,美化ggplot；
cowplot：ggplot2拓展工具箱（多图合并、图层叠加、添加标签等）
【精】see：ggplot2拓展工具箱（更丰富更美观的主题配色方案）Model Visualisation Toolbox for easystats and ggplot2 • see 4. 数据转换 【精】dplyr：一个用于高效数据清理的R包。视频学习课程
magrittr：一个高效的管道操作工具包。
【精】pipeR: 比magrittr更好用的管道操作工具包 Introduction | pipeR Tutorial (renkun-ken.github.io) tibble：高效的显示表格数据的结构
【精】stringr：一个字符串处理工具集
data.table：用于快速处理大数据集
stringi：一个快速字符串处理工具</description>
    </item>
    
    <item>
      <title>R语言必须掌握的包</title>
      <link>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</link>
      <pubDate>Wed, 04 May 2022 22:21:53 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/04/r_packages/</guid>
      <description>这是网络上收集的内容，具有一些参考价值
qinwf/awesome-R: A curated list of awesome R packages, frameworks and software. (github.com) 但是对于我的日常来讲，会有以下一些包进行日常使用，可以常用常新
1. 数据导入 【精】readr：实现表格数据的快速导入。https://readr.tidyverse.org readxl：读取Microsoft Excel电子表格数据
dplyr：提供了一个访问常见数据库的接口
data.table：data.table包的fread()函数可以快速读取大数据集
rio：一站式导入/导出几乎所有格式数据（使用import()/export()函数）
2. 数据整理 【精】tidyr：用于整理表格数据的布局
【精】dplyr：用于将多个数据表连接成一个整齐的数据集
purrr：函数式编程工具，在做数据整理时非常有用。
3. 数据可视化 【精】ggplot2及其扩展：ggplot2包提供了一个强大的绘图系统，并实现了以下扩展
ggthemes：提供扩展的图形风格主题
【精】ggpubr: 生成杂志期刊等出版物的图形的包，是ggplot的一个补充。
ggrepel：用于避免图形标签重叠,美化ggplot；
cowplot：ggplot2拓展工具箱（多图合并、图层叠加、添加标签等）
【精】see：ggplot2拓展工具箱（更丰富更美观的主题配色方案）Model Visualisation Toolbox for easystats and ggplot2 • see 4. 数据转换 【精】dplyr：一个用于高效数据清理的R包。视频学习课程
magrittr：一个高效的管道操作工具包。
【精】pipeR: 比magrittr更好用的管道操作工具包 Introduction | pipeR Tutorial (renkun-ken.github.io) tibble：高效的显示表格数据的结构
【精】stringr：一个字符串处理工具集
data.table：用于快速处理大数据集
stringi：一个快速字符串处理工具</description>
    </item>
    
    <item>
      <title>R语言查看函数源码并修改</title>
      <link>https://kongjianyang.github.io/cn/2022/05/04/r_raw_code/</link>
      <pubDate>Wed, 04 May 2022 21:25:49 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/05/04/r_raw_code/</guid>
      <description>在R语言中可以检查各种包内的函数，如果有必要的话可以进行修改已满足自己的需要，接下来介绍几个方法查看函数源码。
  直接键入函数(不加括号)，大部分函数源代码就可以直接显现出来。
  用函数page()，不过，结果在另一个窗口显示,选择电脑上的程序打开
  用函数edit(), 这个函数允许我们来修改函数，修改的函数可以直接用。函数edit()不仅可以修改包中的函数作为急用，也可以用来修改自己正在写的函数。并且这个命令查看的源码会有高亮显示，比较方便
  对于计算方法不同的函数，要用methods()来定义具体的查看对象
  methods()得出的类函数中带星号标注的源代码，用函数getAnywhere()
  直接上CRAN 下载源代码包
  </description>
    </item>
    
    <item>
      <title>Linux下打印带有空格的目录</title>
      <link>https://kongjianyang.github.io/cn/2022/04/25/dirt_space/</link>
      <pubDate>Mon, 25 Apr 2022 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/04/25/dirt_space/</guid>
      <description>有时候在macos下会有很多空格的目录文件需要处理，很麻烦，可以使用下面的命令自动处理带有空格的文件
alias cwd=&#39;printf &amp;quot;%q\n&amp;quot; &amp;quot;$(pwd)&amp;quot; | tee &amp;gt;(pbcopy)&#39; printf命令 printf 命令模仿 C 程序库（library）里的 printf() 程序。
printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。
printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。
printf 命令的语法：
printf format-string [arguments...] 参数说明：
 format-string: 为格式控制字符串 arguments: 为参数列表。  #!/bin/bash # author:菜鸟教程 # url:www.runoob.com printf &amp;quot;%-10s %-8s %-4s\n&amp;quot; 姓名 性别 体重kg printf &amp;quot;%-10s %-8s %-4.2f\n&amp;quot; 郭靖 男 66.1234 printf &amp;quot;%-10s %-8s %-4.2f\n&amp;quot; 杨过 男 48.6543 printf &amp;quot;%-10s %-8s %-4.</description>
    </item>
    
    <item>
      <title>YAML语言介绍</title>
      <link>https://kongjianyang.github.io/cn/2022/04/25/yaml/</link>
      <pubDate>Mon, 25 Apr 2022 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/04/25/yaml/</guid>
      <description>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。
YAML 是一种数据序列化语言，通常用于编写配置文件。业界对 YAML 有不同的看法，有人会说 YAML 不过代表了另一种标记语言，另外一些人认为*&amp;ldquo;YAML ain’t markup language&amp;rdquo;（ &amp;ldquo;YAML 不是标记语言&amp;rdquo;）*，&amp;ldquo;YAML&amp;rdquo; 正是这句话的递归缩写，强调了 YAML 是用于数据而不是文档。
YAML 是一种流行的编程语言，因为它是人类可读的语言，易于理解。它还可以与其他编程语言结合使用。
YAML支持3种数据结构：
 键值表，键值对的集合，包括映射，哈希，字典。 序列，为一组排列的值，包括数组，列表。 常量，为单个的不可再分隔的值，包括字符串，布尔值，整数，浮点数，Null，时间，日期  由于YAML是JSON的自然超集，所以我们每个YAML语法段，都可以用JSON进行表示。
YAML的基本语法规则如下。
  大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可   # 表示注释，从这个字符一直到行尾，都会被解析器忽略。
YAML 支持的数据结构有三种。
  对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值   以下分别介绍这三种数据结构。
对象的一组键值对，使用冒号结构表示。
 animal: pets  转为 JavaScript 如下。
 { animal: &amp;#39;pets&amp;#39; }  Yaml 也允许另一种写法，将所有键值对写成一个行内对象。
 hash: { name: Steve, foo: bar }  转为 JavaScript 如下。</description>
    </item>
    
    <item>
      <title>R语言基于S4的面向对象编程</title>
      <link>https://kongjianyang.github.io/cn/2022/03/31/s4/</link>
      <pubDate>Thu, 31 Mar 2022 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/31/s4/</guid>
      <description>参考资料：
R 学习笔记: S4 编程基础 - 知乎 (zhihu.com) 不同的语言进行面向对象编程中, 有许多东西是共同的. 就像浩巍说的, 编程就是一通百通. 如果了解 Python 的面向对象编程, 里面的很多思想也能使用在 R 语言面向对象编程中.
 类 (class) 是面向对象编程的基础. 类就像是一个包装的盒子, 把对象的所有的属性都包含在其中. 可以形象地说, 类有点像一个有多种口味可供选择的冰激凌机器. 变量 (variable) 是描述对象的具体特征的数据, 是类的属性, 可以是数字或者字符等各种类型, 在 R 语言的 S4 类中被称为存储槽 (slot). 不同的变量, 就是冰激凌机器中的不同口味的冰激凌. 方法 (method) 是作用于类对象的各种操作, 也是类的属性, 具体实现就是各种方程. 方法也对应于冰激凌机器上产出不同口味冰激凌的不同的按钮. 对于不同的类可以有相似的方法, 例如对不同的类都可以有 print 函数来输出类的内容. 需要注意的是, 在 R 语言的 S4 类中, 类的方法本身不属于类本身, 而是独立的方程, 这点和 Python 等语言面向对象编程有差别. 但是, 在 R 语言的 RC 类 (Reference Class) 中方法本身则属于类.  面向对象编程有三个重要特点: 封装, 继承和多态性.</description>
    </item>
    
    <item>
      <title>R语言数据导入rio包</title>
      <link>https://kongjianyang.github.io/cn/2022/03/30/rio/</link>
      <pubDate>Wed, 30 Mar 2022 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/30/rio/</guid>
      <description>rio: A Swiss-Army Knife for Data I/O
CRAN - Package rio (r-project.org) 笔记说明 在读《Modern R with the tidyverse》 一书时发现了这个非常好用的R包，做此笔记记录。本笔记记录rio包的数据导入功能。导出功能说明见：用rio包进行数据导出 数据导入 Hadley Wickham在《R for Data Science》中总结的探索性数据分析的分析流程
数据导入是数据分析的第一步。实际工作中数据的来源和原始数据文件的格式多种多样。对应不同的原始文件来源或格式就有很多不同的读取数据的R包。学习、使用起来非常麻烦。在rio包之前，为了满足数据导入需要，大概需要学习的R包和其对应的数据文件类型如下：
 readr包 - text files（如csv, tsv, fwf文件） haven包 - SPSS, Stata, and SAS files readxl包 - excel files DBI包 - databases jsonlite包 - json xml2包 - XML httr包 - Web APIs rvest包 - HTML (Web Scraping)  rio包及其数据导入功能 rio包封装了很多数据导入和导出的包，并将不同包的数据导入导出操作统一到两个函数上：import()和export()，通过文件的后缀名来判断文件类型。这使得在R中进行数据的导入导出操作变得非常简单。有关rio包的更多信息可以参见：https://cran.r-project.org/web/packages/rio/vignettes/rio.html 下面对rio包的一些数据导入功能进行展示（基本参照《Modern R with the tidyverse》中对应的内容，所使用的数据可以在https://github.com/b-rodrigues/modern_R/tree/master/datasets 下载）：</description>
    </item>
    
    <item>
      <title>R语言基于S3的面向对象编程</title>
      <link>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</link>
      <pubDate>Tue, 29 Mar 2022 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/29/r_s3/</guid>
      <description>参考这篇文章：
R语言面向对象编程 (dataxujing.github.io) S3对象的介绍 在R语言中，基于S3对象的面向对象编程，是一种基于泛型函数的实现方式。泛型函数是一种特殊的函数，根据传入对象的类型决定调用那个具体的方法。基于S3对象实现面向对象编程，不同其他语言的面型对象编程，是一种动态函数调用的模拟实现。S3对象被广泛应用于R的早期的开发包中。
R的S3系统有三个组成部分:属性(attribute)(尤其是class属性)、泛型函数(genericfunction)和方法(method)
创建S3对象 注意：本文会用到pryr,为了方便我们检查对象的类型，引入pryr包作为辅助工具。
library(pryr) #通过变量创建S3对象 x &amp;lt;- 1 attr(x,&#39;class&#39;) &amp;lt;- &#39;foo&#39; x ## [1] 1 ## attr(,&amp;quot;class&amp;quot;) ## [1] &amp;quot;foo&amp;quot; ## [1] &amp;quot;foo&amp;quot; ## [1] &amp;quot;foo&amp;quot; #用pryr包的otype函数,检查x的类型 otype(x) ## [1] &amp;quot;S3&amp;quot; 通过structure()函数创建S3对象
y &amp;lt;- structure(2,class=&amp;quot;foo&amp;quot;) y ## [1] 2 ## attr(,&amp;quot;class&amp;quot;) ## [1] &amp;quot;foo&amp;quot; ## [1] &amp;quot;foo&amp;quot; ## [1] &amp;quot;foo&amp;quot; ## [1] &amp;quot;S3&amp;quot; 创建一个多类型的S3对象，S3独享没有明确结构关系，一个S3对象可以有多个类型，S3对象的class属性可以是一个向量，包括多种类型
x &amp;lt;- 1 attr(x,&amp;quot;class&amp;quot;) &amp;lt;- c(&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;) # 给了x对象两个class属性 class(x) ## [1] &amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; ## [1] &amp;quot;S3&amp;quot; 如果分配至少一个class属性，就是S3对象，如果没有class属性，就是base对象。</description>
    </item>
    
    <item>
      <title>ChIPseeker使用介绍</title>
      <link>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</link>
      <pubDate>Sat, 26 Mar 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/26/chipseeker/</guid>
      <description>主要参考这篇文章：
190-学习一遍ChIPseeker使用 | BIOINFOPLANET (jieandze1314.com) 1 ChIP-seq简介 ChIP是指染色质免疫沉淀，它通特异结合抗体将DNA结合蛋白免疫沉淀，可以用于捕获蛋白质（如转录因子，组蛋白修饰）的DNA靶点。之前结合芯片就有ChIP-on-chip，后来二代测序加持诞生了ChIP-seq。优点是：不再需要设计探针（探针往往存在着一定的偏向性）
2007年来自三个不同的实验室，几乎是同时间出来（最长差不了3个月），分别发CNS，一起定义了这个ChIPseq技术
 Johnson DS, Mortazavi A et al. (2007) Genome-wide mapping of in vivo protein–DNA interactions. Science 316: 1497–1502 Robertson G et al.(2007) Genome-wide profiles of STAT1 DNA association using chromatin immunoprecipitation and massively parallel sequencing. Nature Methods 4: 651–657 Schmid et al. (2007) ChIP-Seq Data reveal nucleosome architecture of human promoters. Cell 131: 831–832  主要有4步：Cross-linking、Sonication、IP、Sequencing
简而言之是：DNA和蛋白质交联(cross-linking)、超声(sonication)将染色体随机切割、利用抗原抗体的特异性识别(IP)、把目标蛋白相结合的DNA片段沉淀下来，反交联释放DNA片段，最后是测序(sequencing)
分析流程示例图1： 分析流程示例图2： 原始数据=》质控=》比对=》拿到DNA片段在染色体上的位置信息=》peak calling （去除背景噪音）=》拿到peaks（protein binding site）=》下游分析（可视化、找相关基因、motif分析等等）</description>
    </item>
    
    <item>
      <title>tmux多窗口管理</title>
      <link>https://kongjianyang.github.io/cn/2022/03/25/tmux/</link>
      <pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/25/tmux/</guid>
      <description>[TOC]
主要参考这篇文章：还在为 iTerm 多窗口操作烦恼？tmux 这款神器轻松帮你解决_Java极客技术-程序员信息网 - 程序员信息网 (i4k.xyz) Tmux 使用教程 - 阮一峰的网络日志 (ruanyifeng.com) 安装tmux
brew install tmux 会话管理 新建 session
使用 tmux 之前我们首先需要新建一个 Session，命令如下：
# 新建 session，使用 -s 自定义 session 名字 tmux new -s &amp;lt;session-name&amp;gt; 保存会话
进入会话之后，进行相关操作，比如使用 SSH 连上远端服务器。这时如果想退出去的时候，可以保存当前会话信息。下次可以直接重新进入这个会话，不用重新再次使用 SSH 连接了。
# 保存当前会话 tmux detach 接入会话
tmux attach 可以接入上次保存的会话。
# 可以使用 -t 指定会话名字。 tmux attach -t &amp;lt;session-name&amp;gt; 查看会话
如果之前同时保存了多个会话，我们可以使用 tmux ls 查看当前所有会话。
# 查看会话 tmux ls 杀死会话
使用 tmux kill-session 我们可以杀死某个会话。</description>
    </item>
    
    <item>
      <title>个人周刊第一期</title>
      <link>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</link>
      <pubDate>Fri, 25 Mar 2022 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/25/xxxx/</guid>
      <description>R语言面向对象编程 (dataxujing.github.io)  S4对象系统具有明显的结构化特征，更适合面向对象的程序设计。Bioconductor社区以S4对象作为基础框架，只接受S4定义的R包。
 Modern R with the tidyverse (b-rodrigues.github.io)  This book is the result of years of using and teaching R at university and then at my jobs. During my university time, I wrote some notes to help me teach R and which I shared with my students. These are still the basis of Chapter 2. Then, once I had left university, and continued using R at my first “real” job, I wrote another book that dealt mostly with package development and functional programming.</description>
    </item>
    
    <item>
      <title>MACS2使用</title>
      <link>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</link>
      <pubDate>Fri, 25 Mar 2022 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/25/bioinfo/</guid>
      <description>参考资料：
这可能是最棒的MACS2使用说明 (360doc.com) 使用MACS2进行差异peak分析_生信修炼手册的博客-CSDN博客 MACS2：Model-based analysis of ChiP-Seq. 最初的设计是用来鉴定转录因子的结合位点，但是它也可以用于其他类型的富集方式测序。
MACS2作为使用最广泛的peak calling软件，在v2版本中添加了差异peak分析的功能，所有的子命令功能描述如下
通过bdgdiff子命令来进行差异peak分析， 该命令不需要基于已有的peak calling结果，只需要输入每个样本对应的bedGraph格式的文件。需要注意的是，该命令只针对两个样本间的差异peak进行设计，适用于没有生物学重复的情况。
对于使用macs2来进行差异peak的完整流程，官方给出了详细的说明文档，链接如下
 https://github.com/taoliu/MACS/wiki/Call-differential-binding-events  可以分为以下3步
1. 预测插入片段长度 通过predictd子命令可以预测样本的fragment size，命令如下
macs2 predictd -i input.bam #!/bin/bash module load bioinfo module load biocontainers/default module load macs2/2.2.7.1-py39 for i in `ls [A-H][1-9][A-H][1-9][A-H][1-9].bam`; do msg=&amp;quot;macs2 predictd -i $i&amp;quot;; echo $msg; macs2 predictd -i $i; 2. peak calling 在peak calling时，需要添加-B参数，这样才可以输出样本对应的bedgraph文件，同时需要保证peak calling时采用一致的--extsize的值，就是第一步预测出来的数值，取多个样本的均值即可。官方也给出了推荐值，对于大多数的转录因子chip_seq数据，推荐值为200， 对于大部分组蛋白修饰的chip_seq数据，推荐值为147，命令如下
# condition1 macs2 callpeak -B -t cond1_ChIP.bam -c cond1_Control.bam -n cond1 --nomodel --extsize 147 # condition2 # broad peak calling: macs2 callpeak -B -t cond1_ChIP.</description>
    </item>
    
    <item>
      <title>创建自己的newsletter信息</title>
      <link>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</link>
      <pubDate>Wed, 23 Mar 2022 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/23/newsletter/</guid>
      <description>记录使用GitHub创建自己的newsletter信息：
结构参考这篇仓库：ShixiangWang/weekly: 生信爱好者周刊（每周日发布） (github.com) [TOC]
1. 克隆并更新到自己的仓库 克隆别人的仓库到本地 git clone git@github.com:ShixiangWang/weekly.git 并在自己的github创建自己的仓库
删除原来git版本控制 进入project的根目录 中，右击鼠标打开Git Bash 输入 find . -name &amp;quot;.git&amp;quot; | xargs rm -Rf
初始化自己的仓库 $ touch README.md $ git init $ git add * $ git commit -m &amp;#34;此处可添加提交代码相关的注释&amp;#34; $ git remote add origin https://github.com/yourUserName/repositoryName.git $ git push -u origin master 123456 origin 是代码仓库地址的别称 git详细教程 .gitignore文件编写
该文件内容是不想提交到仓库的文件或文件夹。 忽略某个文件夹下面所有内容要带星号* pyqt5/build/* pyqt5/dist/* time_format/build/* time_format/dist/* time_format/img/*</description>
    </item>
    
    <item>
      <title>使用GitHub page建立站点</title>
      <link>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</link>
      <pubDate>Sun, 20 Mar 2022 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2022/03/20/second-post-cn/</guid>
      <description>记录第一次使用GitHub page建立站点的步骤:
主要参考这篇文章：郝鸿涛：Hongtao Hao [TOC]
1. 安装Hugo 在 Terminal 中输入
brew install hugo 完成后，在 Terminal 中输入 hugo version, 如果显示 Hugo Static Site Generator... 证明安装成功。
2. 新建一个 Hugo 网站 Hugo 博客就是一个文件夹。首先你要确定把这个文件夹放在哪里。到达自己需要的地址之后使用以下命令
hugo new site liang.github.io **# quickstart 可以换成任何你想用的名称** cd quickstart/themes git clone https://github.com/hongtaoh/hugo-ht mkdir hugo-ht-new cp -r hugo-ht/* hugo-ht-new rm -rf hugo-ht mv hugo-ht-new hugo-ht cd .. cp -r themes/hugo-ht/exampleSite/* . 这是使用一个Hugo-ht为主题的网站，之后可以折腾其他主题。但是这样会你目前 Hugo 网站中的 Content 文件夹和 config.toml 替换为 Hugo-ht 自带的内容。如果你当前 Hugo 网站中的 Content 文件夹及config.</description>
    </item>
    
    <item>
      <title>GSEA富集分析</title>
      <link>https://kongjianyang.github.io/cn/2021/08/13/gsea/</link>
      <pubDate>Fri, 13 Aug 2021 16:03:40 -0600</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/08/13/gsea/</guid>
      <description>GSEA富集分析 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>R语言中的多元方差分析【MANOVA】</title>
      <link>https://kongjianyang.github.io/cn/2021/06/17/manova/</link>
      <pubDate>Thu, 17 Jun 2021 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/06/17/manova/</guid>
      <description>R语言中的多元方差分析【MANOVA】 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>R语言anova进阶</title>
      <link>https://kongjianyang.github.io/cn/2021/05/17/anova_advance/</link>
      <pubDate>Mon, 17 May 2021 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/05/17/anova_advance/</guid>
      <description>R语言anova进阶 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>R语言glue包介绍</title>
      <link>https://kongjianyang.github.io/cn/2021/04/22/glue/</link>
      <pubDate>Thu, 22 Apr 2021 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/04/22/glue/</guid>
      <description>glue 提供了轻巧、快速和无依赖的可解释字符串，glue 通过将 R 表达式嵌入到花括号中，然后对其求值并将其插入字符串中。
glue包可用于自定义变量，然后通过传参的方式，对字符串部分内容进行自适应修改。
例如：可将日期赋值为：date = as.Date(&amp;ldquo;2019-12-05&amp;rdquo;)，然后通过字符串拼接的形式，实现文件名称自动更新，glue(&amp;ldquo;The day is {date}.&amp;quot;。
安装 install.packages(&amp;quot;glue&amp;quot;) # or install.packages(&amp;quot;glue&amp;quot;) # install.packages(&amp;quot;devtools&amp;quot;) devtools::install_github(&amp;quot;tidyverse/glue&amp;quot;) 使用 1. 导入 2. 简单使用 将变量直接传递到字符串中
&amp;gt; name &amp;lt;- &amp;quot;Fred&amp;quot; &amp;gt; glue(&#39;My name is {name}.&#39;) My name is Fred. 通过将变量名放置在一对花括号之间，glue 会将变量名替换为相应的值
字符串可以写成多行的形式，最后会自动将这些行连接起来
&amp;gt; name &amp;lt;- &amp;quot;Fred&amp;quot; &amp;gt; age &amp;lt;- 50 &amp;gt; anniversary &amp;lt;- as.Date(&amp;quot;1991-10-12&amp;quot;) &amp;gt; glue(&#39;My name is {name},&#39;, + &#39; my age next year is {age + 1},&#39;, + &#39; my anniversary is {format(anniversary, &amp;quot;%A, %B %d, %Y&amp;quot;)}.</description>
    </item>
    
    <item>
      <title>R语言str_replace多匹配</title>
      <link>https://kongjianyang.github.io/cn/2021/03/26/str_replace/</link>
      <pubDate>Fri, 26 Mar 2021 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/03/26/str_replace/</guid>
      <description>主要参考这个回答：r - stringr str_replace on multiple patterns and replacements? - Stack Overflow library(stringr) library(purrr) reduce2(c(&amp;#39;b&amp;#39;, &amp;#39;d&amp;#39;), c(&amp;#39;B&amp;#39;, &amp;#39;D&amp;#39;), .init = &amp;#39;abcdef&amp;#39;, str_replace) #[1] &amp;#34;aBcDef&amp;#34; 这种方法在大批量替换rowname的时候很有用，所以解析一下。
在purrr包中
map表示映射，可以在一个或多个列表/向量的每个位置上应用相同函数进行计算。map函数的映射对象只有一个。
 map(.x, .f, …) .x: 列表或向量； .f: 映射函数； ...: 映射函数的其他参数
 map2函数是map函数的变形，映射对象有两个，需要注意两个列表/向量的长度必须相同。
 map2(.x,.y, .f, …) .x: 列表或向量； .y: 列表或向量,与.x等长； .f: 映射函数； ...: 映射函数的其他参数
 pmap函数是map函数的变形，映射对象为多个，需要注意多个列表/向量的长度必须相同。
 pmap(.l, .f, …) .l: 列表向量/列表； .f: 映射函数； ...: 映射函数的其他参数
 reduce函数表示规约，计算向量中相邻的两个元素，结果再与第三个元素计算，…，最后计算出一个值。  reduce(.x, .f, …) .x: 列表向量/列表； .</description>
    </item>
    
    <item>
      <title>Markdown 试水</title>
      <link>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</link>
      <pubDate>Thu, 07 Jan 2021 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</guid>
      <description>第一级标题 第二级标题 第三级标题 第四级标题 第五级标题 第六级标题 列表  Water Water Water  Water Water Water   Water  Water Water Water  Water Water      表格    Water Water Water     Water Water Water   Water Water[^1] Water   Water Water Water    引语  知之为知之，不知为不知，是知也[^2]。 — 孔子
 数学公式 最简单的如，$1 + 1 = 3$
你可以加入索引:</description>
    </item>
    
    <item>
      <title>Markdown 试水</title>
      <link>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</link>
      <pubDate>Thu, 07 Jan 2021 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2021/01/07/first-post-cn/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Markdown Testing</title>
      <link>https://kongjianyang.github.io/en/2021/01/07/second-post/</link>
      <pubDate>Thu, 07 Jan 2021 13:37:57 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/en/2021/01/07/second-post/</guid>
      <description>See the source code of this page if you are interested.
 H1 H2 H3 H4 H5 H6 List  Water Water Water  Water Water Water   Water  Water Water Water  Water Water      Table    Water Water Water     Water Water Water   Water Water1 Water   Water Water Water    Quotes  What I cannot create, I do not understand2.</description>
    </item>
    
    <item>
      <title>R语言使用dplyr编程【练习】</title>
      <link>https://kongjianyang.github.io/cn/2020/12/14/dplyr/</link>
      <pubDate>Mon, 14 Dec 2020 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/12/14/dplyr/</guid>
      <description>R语言使用dplyr编程【练习】 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>Python给包含数字的字符串排序</title>
      <link>https://kongjianyang.github.io/cn/2020/09/12/python%E7%BB%99%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 12 Sep 2020 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/09/12/python%E7%BB%99%E5%8C%85%E5%90%AB%E6%95%B0%E5%AD%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/</guid>
      <description>2020-09-12-Python给包含数字的字符串排序 pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight .hll { background-color: var(--jp-cell-editor-active-background) } .highlight { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) } .highlight .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */ .</description>
    </item>
    
    <item>
      <title>R语言data.table学习</title>
      <link>https://kongjianyang.github.io/cn/2020/05/05/data.table/</link>
      <pubDate>Tue, 05 May 2020 23:57:39 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/05/05/data.table/</guid>
      <description>关于data.table和pandas之间的比较：A data.table and pandas small stroll · Home (atrebas.github.io) 关于data.table和dplyr之间的比较：A data.table and dplyr tour · Home (atrebas.github.io) 介绍 data.frame是R内置的、默认的数据框类型（即一个具有行和列的数据表）。从外部导入的数据一般都以data.frame数据框格式在R里面进行处理和分析。
data.table作为一种高级数据类型，首先继承了data.frame基础数据类型，其官方文档 已经明确说明“data.table是data.frame的扩展（extension）”。
data.table具备很多独特而出色的性质，与其他数据类型（如data.frame、tibble/tbl_df）相比具有很多优势。
 高效：轻松、快速处理GB级别的大数据，并且融合了SQL数据库的语法风格 极简：只需很短的代码就能完成数据的行、列、分组、合并、重塑等相关操作 丰富：数据类型自带筛选、计算、分组、合并等多种方法，无需借助其他函数  此外，一部分R用户需要在数据框里面“嵌套表”，由于data.frame无法实现而十分推崇tibble（tbl_df）。其实，这一点不仅tibble能实现，data.table也完全能实现。
Jan Gorecki 曾对比过不同开源软件及程序包在数据处理方面的性能，结果发现，data.table在数据处理效率上秒杀一大批工具包，甚至轻松超越Python的pandas包和R语言的dplyr包（结果如下图，测试数据规模为5 GB）。而当数据规模达到50 GB，pandas和dplyr都已经hold不住了（报错或内存溢出），但data.table依然稳居榜首（详见：数据处理工具性能大比拼 ）。
使用data.table包并不意味着排斥或弃用其他R包——相反，data.table包是能够和tidyverse、dplyr等著名R包兼容并存、相辅相成的。
这里需要明确几个事实：
 tidyverse本身只是一系列常用包的集合（包括dplyr、ggplot2、lubridate、stringr、tibble、tidyr等），并且载入时会为用户默认载入某些常用包，但它本身并没有什么实质性的函数（不信可以查看它的帮助文档）。 管道操作符（%&amp;gt;%）非常好用，也与data.table完全兼容，但它本身既不是tidyverse包里的，也不是dplyr包里的，而是magrittr包里的。 dplyr包的各种数据操作或处理函数，完全适用于data.frame、tibble/tbl_df、data.table等数据类型，因此data.table与dplyr并不冲突（比如，我个人也喜欢用dplyr::left_join()函数对data.table数据进行匹配拼接处理）。  总之：
 tidyverse是建议安装的一个综合性R包（并不必然与tibble相联系） dplyr是建议掌握的一个数据处理R包（并不必然与tibble相联系） data.table是强烈建议掌握的一个兼具数据类型和数据处理功能的R包 这三者是可以兼容并包、组合使用的  data.table包提供了一个非常简洁的通用格式：DT[i,j,by]，一句话概括：用 i 选择行，用 j 操作列，根据 by 分组。
其中，j 表达式非常强大和灵活，可以选择、修改、汇总、计算新列，甚至可以接受任意表达式。需要记住的最关键一点是：只要返回等长元素或长度为 1 元素的 list，每个 list 元素将转化为结果 data.table 的一列。
注意:
data.table之后，一些常规的data.frame的操作就失效了，譬如：
data[,-1]、data[,1]这样的操作就不是这么用的了。
使用data.table包操作数据 data.table包提供了一个加强版的data.frame，它运行效率极高，而且能够处理适合内存的大数据集，它使用[]实现了一种自然地数据操作语法。使用下面命令进行安装：
install.packages(&amp;quot;data.table&amp;quot;) 载入包：</description>
    </item>
    
    <item>
      <title>R语言data.table实战</title>
      <link>https://kongjianyang.github.io/cn/2020/05/05/data.table/</link>
      <pubDate>Tue, 05 May 2020 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/05/05/data.table/</guid>
      <description>R语言data.table实战 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>R语言tidyverse风格简介</title>
      <link>https://kongjianyang.github.io/cn/2020/02/13/tidy-verse_style/</link>
      <pubDate>Thu, 13 Feb 2020 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/02/13/tidy-verse_style/</guid>
      <description>tidyverse有两层基本含义：（1）基于Google 社区的R 代码风格（Google’s R style guide）衍生的一种使代码清晰可读的编程风格；（2）一系列基于前述风格而编写的数据处理R 包。tidyverse一词中的tidy意为整洁，verse意为诗篇、诗行，合起来意指代码或数据如诗行般整洁易读，即成为“整洁代码”（tidy code）或“整洁数据”（tidy data）。熟悉这一风格和相关R 包，可使数据处理和代码编写过程更为便捷高效，且易于与其他数据分析者交流沟通。
建立较为统一的代码书写风格，可方便不同用户之间的沟通与协作。这里基于tidyverse模式择要介绍目前R 编程中的主流风格，并根据中文用户的习惯做部分调整和说明。某些内容可能初学者并不一定很快遇到，但仍宜先行阅读，以建立良好的书写规范。详细的tidyverse风格说明参见如下链接：
http://style.tidyverse.org 三、命名规范
1.文件名
文件名应能体现文件的实质内容，只使用数字、英文字母、中划线-和下划线_。尽量避免文件名中的英文字母大小写混用，宜只使用小写，并建议使用_或-连接文件名中的不同英文，如nankai_psy_2017。
若多个文件存在特定顺序，应以数字作为前缀。如果有超过10个文件，对于个位数的前缀要在前面添补一个0。例如：
其中，.后的xx表示适当的文件后缀名，可能是csv、xlsx、pdf、png等。
超过100个文件则在最开始补充00，依此类推。
2.变量与函数名
变量和函数名应只使用小写字母、数字和下划线_。下划线（_）用于分隔较长命名中的不同单词，避免用.分隔。例如，变量名写成bmi_women，而不是bmi.women；函数名写成trim_gini，而不是trim.gini。变量名应是名词，而函数名应是动词，且应尽量简洁。
这里和base R可能有些区别
    在标识符中不要使用下划线 ( _ ) 或连字符 ( - ). 标识符应根据如下惯例命名. 变量名应使用点 (.) 分隔所有的小写字母或单词; 函数名首字母大写, 不用点分隔 (所含单词首字母大写); 常数命名规则同函数, 但需使用一个 k 开头.
   variable.name 正例: avg.clicks 反例: avg_Clicks , avgClicks FunctionName 正例: CalculateAvgClicks 反例: calculate_avg_clicks , calculateAvgClicks 函数命名应为动词或动词性短语. 例外: 当创建一个含类 (class) 属性的对象时, 函数名 (也是constructor) 和类名 (class) 应当匹配 (例如, lm).</description>
    </item>
    
    <item>
      <title>R语言多重数据交集</title>
      <link>https://kongjianyang.github.io/cn/2020/01/12/multiple_intersects/</link>
      <pubDate>Sun, 12 Jan 2020 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2020/01/12/multiple_intersects/</guid>
      <description>一个简单的例子讲解怎么做多重数据的交集
首先创造一个嵌套的list
l &amp;lt;- list(A=c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;), B=c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;), C=c(&amp;quot;two&amp;quot;, &amp;quot;four&amp;quot;, &amp;quot;five&amp;quot;, &amp;quot;six&amp;quot;), D=c(&amp;quot;six&amp;quot;, &amp;quot;seven&amp;quot;)) crossprod(table(stack(l))) l $A [1] &amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; $B [1] &amp;quot;one&amp;quot; &amp;quot;two&amp;quot; $C [1] &amp;quot;two&amp;quot; &amp;quot;four&amp;quot; &amp;quot;five&amp;quot; &amp;quot;six&amp;quot; $D [1] &amp;quot;six&amp;quot; &amp;quot;seven&amp;quot; crossprod(table(stack(l))) #的到结果 ind ind A B C D A 4 2 2 0 B 2 2 1 0 C 2 1 4 1 D 0 0 1 2 开始解释这些命令
首先是stack命令，将潜逃列表变平
&amp;gt; stack(l) values ind 1 one A 2 two A 3 three A 4 four A 5 one B 6 two B 7 two C 8 four C 9 five C 10 six C 11 six D 12 seven D Stacking vectors concatenates multiple vectors into a single vector along with a factor indicating where each observation originated.</description>
    </item>
    
    <item>
      <title>Snippet工具使用介绍</title>
      <link>https://kongjianyang.github.io/cn/2019/11/23/dash/</link>
      <pubDate>Sat, 23 Nov 2019 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/11/23/dash/</guid>
      <description>Dash 1. 功能简介 官方用一句话就概括了它的用途：Dash是一个API文档浏览器（ API Documentation Browser），以及代码片段管理工具（Code Snippet Manager）。你没看错，它就只有这两个功能，但确实是程序员（至少对于我来说）最为关心的特性，自己之前也用过了不少类似的工具，可以毫不夸张地说，Dash是它们之中做的最好的一个！
目前dash已经收费了
2. 下载 关于下载我还是推介官网下载吧(https://kapeli.com/dash )
3. 强悍的API文档浏览、搜索功能 想必这个功能是大家最常用的了吧，每天要反复查看、搜索那么多的API细节，没有一个好工具，单靠自己的双手如何应付得来？窗口不停的切来切去，很烦啊！Dash采用集成单一窗口的方式，很好的解决了这个问题。看下面的截图：
点击查看原始大小图片
上图便是Dash的API浏览器主界面：左侧边栏是各种编程语言以及框架（取决于你下载安装了多少文档集合）的导航大纲，点击某个节点，右边的内容区域就是文档的详细信息啦，非常直观。也可以在左上方的搜索框内通过输入关键字，查找相关的API文档，非常类似全文检索的实现方式，Dash的响应速度非常快！关键是可以同时查询不同的语言、框架内容，实在是太方便了。看到这里你也许要问了，这跟我们平常切换到特定的文档窗口（比如一个PDF或者一个CHM文件），再ctrl + f查找有什么区别，不是多此一举吗？其实你错了，Dash可以通过快捷键来显示、隐藏文档窗口，它提供了配置界面以便用户自行设置（我比较习惯alt+space，因为其他软件很少用到这个组合键）：
Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，全列出来很吓人的：
而且它的文档库采用了docset格式，高级用户基于网站提供的教程，很容易就能自行添加其他的扩充文档，其实Dash在最初发布的时候，只支持很少的几个文档浏览，好像只有Java、HTML、CSS这些，是后来通过用户不断贡献，以及作者及时的反馈（Rails API就是我通过Email与作者联系，请求添加的，作者非常nice），逐步壮大，才具备了如此广泛的语言、框架支持。要添加API文档，打开软件配置界面，切换到Docset选项卡即可看到所有内置的文档列表，按需要自行下载即可（如果是自己制作的docset，双击即可导入Dash）：
4. 牛逼、好用的代码片段管理功能 这也是我最喜欢的一个功能
不得不说这个简直就是程序员的神器,大大的提高的程序的开发效率。
前面说完了Dash的文档查询功能，下面再来看一看它带给我们的另一个惊喜：代码片段管理。说到这里，之前的版本其实有个很不好的地方，就是如果不仔细琢磨一下，或者去看官方的帮助文档的话，用户是很难一眼就知道怎么用这个功能，新手引导做得确实不怎么样，不过最新版已经改善了这个问题，在主界面的导航边栏明确地给出了分类提示，创建或者修改代码片段都方便了许多。来看下面这个例子：
利用Dash的代码片段管理功能，我们可以把日常使用频繁（也就是你经常需要复制粘贴）的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来帮你搞定啦。比如上面截图中的例子，就是ExtJS中发起Ajax请求的代码片段，哪怕是copy &amp;amp; paste，时间长了也会很烦的，我给它设置了一个缩写（ajax），以后在需要编写这段代码的时候，就只需要敲击这几个字母，它就会魔法般的出现在光标所在位置啦！很神奇吧？嘿嘿，其实这种扩展缩写的功能，还有很多软件都能做到，比如TextExpander（这个我也买了，半价14刀的时候，但是现在已经打入冷宫了，比较后悔），不过就用户体验和各种细节，诸如界面UI，特别是扩展占位符的处理上，目前还没有哪一个能比得过Dash的（Dash is the best!）。来看看使用代码片段的截图吧：
点击查看原始大小图片
Dash的缩写扩展功能很强大，比方说上面那个例子，在保存代码片段的时候，你可以使用双下划线标明占位符，在执行扩展的时候就可以通过tab键来在各个占位符之间切换，根据需要输入实际的值，最后回车即可把片段粘贴到光标所在之处。除了占位符，它还支持下面这些变量符号：
@clipboard 自动插入当前剪贴板中的内容
@cursor 代码片段粘贴完毕之后，自动将光标定位到此处
@date 自动插入当前日期
@time 自动插入当前时间</description>
    </item>
    
    <item>
      <title>Snippet工具使用介绍</title>
      <link>https://kongjianyang.github.io/cn/2019/11/23/dash/</link>
      <pubDate>Sat, 23 Nov 2019 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/11/23/dash/</guid>
      <description>片段（Snippet）是一個編程用語，指的是原始碼、機器碼、文本中可重複使用的小區塊。通常它們是有正式定義的執行單位，以納入更大的編程模塊。也就是只需要输入少数的几个特定字符，编辑器便能帮我们自动补全为模板代码。目前几乎所有主流编辑器和 IDE 都支持这项功能，如 Eclipse, Sublime Text, Visual Studio Code 和 Atom。
市面上有很多的Snippet管理工具。
Alfred 参考这个文章：真正提升你的输入效率，从用好 Alfred 的这个功能开始：Alfred Snippets - 少数派 (sspai.com) 注：Snippets 为 Alfred 的付费功能，需购买 Powerpack 后才能使用。）
打开 Alfred 的设置菜单，找到 Features 里面的 Snippets，你可以看到下图这个设置面板：
设置
想要创建 Snippets，首先要建立一个 Collection（集合）。点击左侧 Collection 底部的 「+」号，输入集合的名字。
在设置中，你可以选择是否为这个 Collection 设置一个前缀或者后缀，这个功能的主要目的是为了方便区分，当你在使用时，通过输入前缀或者后缀可以快速显示某一个集合内的所有 Snippets。我们在这里给这个名为「Personal」的 Collection 添加一个「!」作为前缀。
添加 Collection 后，就可以来创建你的第一个 Snippets 了。点击右侧底部的「+」，输入 Snippets 的名字和关键词，然后在下方输入你希望拓展的内容。在这里以添加个人邮箱为例，在上面的 Keyword 里填入「GM」作为关键词，然后下方输入 myemail@gmail.com ，点击 Save 来保存，这样我们就创建了一条 Snippets。
如何使用 Snippets 接下来我们来看看如何使用刚刚创建的 Snippets。回到 Snippets 设置菜单，在右上角你可以找到 Automatically expand snippets by keyword，打开这个选项后你才能在 macOS 中直接输入关键词来进行拓展（第一次打开时需要在「系统设置 - 隐私 - 辅助功能」中开启服务），否则就需要每次手动进行粘贴。</description>
    </item>
    
    <item>
      <title>R中的fuzzyjoin包介绍</title>
      <link>https://kongjianyang.github.io/cn/2019/11/12/r_fuzzyjoin/</link>
      <pubDate>Tue, 12 Nov 2019 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/11/12/r_fuzzyjoin/</guid>
      <description>假设字符串x最少需要插入a次、删除b次、替换c次才能与字符串y相同，则x、y之间的 距离 即a、b、c的加权总和。比如将”kitten”转化为”sitting”，需要把“k”替换为“s”，把“e”替换为“i”，并在尾部插入“g”，所以共需1次插入、0次删除、2次替换，按照默认权重两者之间 距离 英该为3。
在R语言中，我们可以使用adist(x, y = NULL, costs = NULL, counts = FALSE, …)的形式，计算字符串之间的距离。其中：
 costs即插入（insertions）、删除（deletions）、替换（substitutions）次数的权重 counts表示是否输出插入、删除、替换次数 partial表示是否只进行局部匹配  library(tidyverse) ## ── Attaching packages ─────────────────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.1 ✓ dplyr 1.0.5 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() drop(attr(adist(&amp;quot;kitten&amp;quot;, &amp;quot;sitting&amp;quot;, counts = TRUE), &amp;quot;counts&amp;quot;)) ## ins del sub ## 1 0 2 adist(&amp;quot;kitten&amp;quot;, &amp;quot;sitting&amp;quot;, counts = TRUE) %&amp;gt;% attr(.</description>
    </item>
    
    <item>
      <title>snakemake教学</title>
      <link>https://kongjianyang.github.io/cn/2019/10/17/snakemake/</link>
      <pubDate>Thu, 17 Oct 2019 19:10:27 -0400</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/10/17/snakemake/</guid>
      <description>参考： https://qinqianshan.com/python/py_module/snakemake/ https://xizhihui.github.io/2018/10/28/%E6%B5%81%E7%A8%8B%E6%9E%84%E5%BB%BA-Snakemake%E4%BD%BF%E7%94%A8%E5%88%9D%E6%AD%A5/ 如果你编译过软件，那你应该见过和用过make, 但是你估计也没有仔细想过make是干嘛用的。Make是最常用的软件构建工具，诞生于1977年，主要用于C语言的项目，是为了处理编译时存在各种依赖关系，尤其是部分文件更新后，Make能够重新生成需要更新的文件以及其对应的文件。
Snakemake和Make功能一致，只不过用Python实现，增加了许多Python的特性，并且和Python一样非常容易阅读。
Snakemake是一个工作流程管理系统。它是基于Python的、用于创建可重现和可扩展的数据分析的工具（当然现在也可以直接将它当做Python的一个模块）。Snakemake所创建的流程还可以无缝扩展到服务器、集群和云环境等不同环境，当然前提是你需要提前将所需的软件和依赖配置好，一起打包封装在conda环境中。
安装软件
pip3 install snakemake 虽然snakemake广泛的应用于生物信息方面的流程编写，但是snakemake的应用并不局限于编写生物信息学的流程，这里以一个简单的合并文件的例子开始介绍snakemake的简单使用。
#首先我们建立两个文件 echo &amp;quot;Here is hello.&amp;quot; &amp;gt; hello.txt echo &amp;quot;Here is world.&amp;quot; &amp;gt; world.txt #接下来开始编写我们的Snakefile rule concat: # 这里的rule可视为snakemake定义的关键字，concat是我们自定义的这一步任务的名称 input: # input同样是snakemake的关键字，定义了在这个任务中的输入文件 expand(&amp;quot;{file}.txt&amp;quot;, file=[&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;]) #expand是一个snakemake定义的替换命令 output: # output也是snakemake的关键字，定义输出结果的保存文件 &amp;quot;merged.txt&amp;quot; shell: # 这里表示我们下面的命令将在命令行中执行 &amp;quot;cat {input} &amp;gt; {output}&amp;quot; #最后就可以在Snakefile的路径执行snakemake命令即可 snakemake cat merge.txt # Here is hello. # Here is world. 在上面的Snakefile脚本中，rule、input、output、shell、expand均为snakemake中的关键字或者命令。同时Snakefile中的每一个rule其实都可以看作是一个简单的shell脚本，通过Snakefile将多个rule组织在一起并按照我们定义的顺序来执行。另外，在output中的结果文件可以是未存在目录中的文件,这时会自动创建不存在的目录。
snakemake中的规则 rule是Snakefile中最主要的部分。如上面的例子所说，每一个rule定义了一系列pipe中的一步，每一个rule都可以当作一个shell脚本来处理，一般主要包括input、output、shell3个部分。同时还有许多上面没有列出来的用法：
 wildcards。用来获取通配符匹配到的部分，例如对于通配符&amp;quot;{dataset}/file.{group}.txt&amp;quot;匹配到文件101/file.A.txt，则{wildcards.dataset}就是101，{wildcards.group}就是A。 threads。通过在rule里面指定threads参数来指定分配给程序的线程数，egthreads: 8。 resources。可用来指定程序运行的内存，eg. resources: mem_mb=800。 message。使用message参数可以指定每运行到一个rule时，在终端中给出提示信息，eg.</description>
    </item>
    
    <item>
      <title>R语言绘制桑吉图</title>
      <link>https://kongjianyang.github.io/cn/2019/10/11/sankey/</link>
      <pubDate>Fri, 11 Oct 2019 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/10/11/sankey/</guid>
      <description>R语言绘制桑吉图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>html基本入门</title>
      <link>https://kongjianyang.github.io/cn/2019/08/27/html_intro/</link>
      <pubDate>Tue, 27 Aug 2019 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/08/27/html_intro/</guid>
      <description>HTML 不是一门编程语言，而是一种用于定义内容结构的_标记语言_。HTML 由一系列的**元素（elements）**组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 例如，键入下面一行内容：
键入下面一行内容：
我的猫咪脾气非常暴躁 可以将这行文字封装成一个段落（paragraph）元素来使其在单独一行呈现：
&amp;lt;p&amp;gt;我的猫咪脾气非常暴躁&amp;lt;/p&amp;gt;  HTML元素的剖析 让我们进一步探讨该段落元素。
元素的主要部分如下：
 开头标记：它由元素的名称（在本例中为p）组成，并包装在开始和关闭尖括号中。这说明了元素开始或开始生效的位置-在这种情况下，段落开始了。 **结束标记：**与开始标记相同，不同之处在于它在元素名称之前包含一个_正斜杠_。这说明了元素的结尾，在这种情况下，段落的结尾。未能添加结束标记是标准的初学者错误之一，并且可能导致奇怪的结果。 **内容：**这是元素的内容，在这种情况下，只是文本。 **元素：**开始标签，结束标签和内容共同组成元素。  元素也可以具有如下所示的属性：
属性包含有关您不想出现在实际内容中的元素的额外信息。在这里，class是属性_名称_ ，editor-note是属性_值_。通过该class属性，您可以为元素提供一个非唯一的标识符，该标识符可用于class样式信息和其他信息。
属性应始终具有以下内容：
 它与元素名称（如果元素已经具有一个或多个属性，则为上一个属性）之间的空格。 属性名称后跟等号。 用引号引起来的属性值。  注意：不包含ASCII空格（或任何字符&amp;quot; &#39; ` = &amp;lt; &amp;gt;）的简单属性值可以不加引号，但是建议您对所有属性值加引号，因为这会使代码更一致和更易理解。
 嵌套元素 您也可以将元素放入其他元素中-这称为嵌套。如果要说明“我们的猫脾气非常暴躁”，可以将“非常”一词包裹在一个&amp;lt;strong&amp;gt; 元素中，这意味着特别强调该词：
&amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常&amp;lt;/strong&amp;gt;暴躁:)&amp;lt;/p&amp;gt; 但是，要确保元素正确嵌套。在上面的示例中，我们&amp;lt;p&amp;gt; 首先打开了元素，然后打开了&amp;lt;strong&amp;gt;元素；因此，我们必须先关闭&amp;lt;strong&amp;gt;元素，然后再关闭&amp;lt;p&amp;gt;元素。以下是不正确的：
# right &amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常暴躁&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; # wong &amp;lt;p&amp;gt;我的猫咪脾气&amp;lt;strong&amp;gt;非常&amp;lt;/p&amp;gt;暴躁&amp;lt;/strong&amp;gt; 这些元素必须正确地打开和关闭，以使它们清楚地位于彼此内部或外部。如果它们如上所示重叠，则您的Web浏览器将尝试对您要说的内容做出最佳猜测，这可能会导致意外结果。
 空元素 一些元素没有内容，被称为空元素。采取&amp;lt;img&amp;gt; 我们在HTML页面中已经拥有的元素：
&amp;lt;img src=&amp;quot;/img/earth.jpg&amp;quot; alt=&amp;quot;地球&amp;quot;&amp;gt; 它包含两个属性，但是没有结束&amp;lt;/img&amp;gt;标记，也没有内部内容。其目的是将图像嵌入HTML页面中。
 HTML文档剖析 总结了各个HTML元素的基础知识。现在，我们将研究如何将单个元素组合以形成整个HTML页面。让我们重新看一下index.html示例中放入的代码：
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;测试页面&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;quot;/img/earth.</description>
    </item>
    
    <item>
      <title>R中处理错误</title>
      <link>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</link>
      <pubDate>Fri, 07 Jun 2019 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/06/07/r_errors/</guid>
      <description>方案一：使用try语句  使用方法
在R语言中，try语句的用法如下所示:  try(expr, silent = FALSE, outFile = getOption(&amp;quot;try.outFile&amp;quot;, default = stderr())) 可以看到，try语句共有三个参数，常用的是前两个参数。第一个参数expr为我们所要使用的表达式，第二个参数silent表示当错误出现时是否需要报告错误信息，其输入值应为逻辑变量，默认为FALSE，即选择不保持“沉默”，当错误出现时会立即报告错误信息。
如果参数expr所代表的表达式可以正确运行，则try语句的输出即为该表达式的运行结果，如果表达式无法正确运行，则try语句会输出一个“try-error”类的不可见对象，因此可以通过if语句对try语句的输出结果进行判断从而进行下一步的处理。
如果大段代码中有错误，想忽略错误，可以采用try()，但大段代码需放在**{ }**中：
你可以捕获**try()的输出，如果程序运行成功，返回计算结果；如果程序运行不成功，则可以通过class()**函数返回，错误类型 &amp;lsquo;try-error&amp;rsquo;。
使用示例  A = list(a=1,b=&amp;#39;abc&amp;#39;,c=-2,d=3) # 运行log(&amp;#39;abc&amp;#39;)会报错，运行log(-2)会出现警告 B = list() for (nm in names(A)) { x &amp;lt;- A[[nm]] temp &amp;lt;- try(log(x),silent=FALSE) if(&amp;#39;try-error&amp;#39; %in% class(temp)) # 判断当前循环的try语句中的表达式是否运行正确 { temp &amp;lt;- NA # 此处可以对运行错误的情况进行处理应对 } B[[nm]] &amp;lt;- temp } 方案二：使用tryCatch语句  使用方法
相较于try语句，tryCatch语句更为全面，能够处理和应对更为复杂的问题。其不仅能够处理表达式出现错误error的情形，还能够处理出现警告warning的情况。主要用法如下所示：  tryCatch( { expr }, warning = function(w) { warning-handler-code }, error = function(e) { error-handler-code }, finally = { cleanup-code } ) 可以看到，tryCatch语句的内部可以被划分为四个不同的部分。</description>
    </item>
    
    <item>
      <title>R语言管道操作Magritte</title>
      <link>https://kongjianyang.github.io/cn/2019/04/27/magritte/</link>
      <pubDate>Sat, 27 Apr 2019 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/04/27/magritte/</guid>
      <description>主要参考文章：
R语言中管道操作符 %&amp;gt;%, %T&amp;gt;%, %$% 和 %&amp;lt;&amp;gt;% - 知乎 (zhihu.com) The Four Pipes of magrittr | R-bloggers magrittr包有两个主要目标:
  第一是减少代码开发时间，提高代码的可读性和维护性
  第二是让你的代码更短
  lhs %&amp;gt;% rhs # pipe syntax for rhs(lhs)
  lhs %&amp;gt;% rhs(a = 1) # pipe syntax for rhs(lhs, a = 1)
  lhs %&amp;gt;% rhs(a = 1, b = .) # pipe syntax for rhs(a = 1, b = lhs)
  lhs %&amp;lt;&amp;gt;% rhs # pipe syntax for lhs &amp;lt;- rhs(lhs)</description>
    </item>
    
    <item>
      <title>vscode使用技巧</title>
      <link>https://kongjianyang.github.io/cn/2019/03/14/vscode/</link>
      <pubDate>Thu, 14 Mar 2019 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2019/03/14/vscode/</guid>
      <description>VS code 的层级树太浅怎么解决，子目录的缩进不够深
通过修改workbench&amp;gt;Tree: indent的结构
一些详细介绍：
一、User Guide（用户指南）🔗  参考官方文档：Basic Editing in Visual Studio Code  更改显示语言🔗 通过安装插件 Chinese (Simplified) Language Pack for Visual Studio Code 来启用中文（需要重启）
默认情况下，Visual Studio Code 附带英语作为显示语言，而其他语言则依赖于 Marketplace 提供的语言包扩展。
VS Code 检测到操作系统的 UI 语言，并会提示您安装适当的语言包（如果在 Marketplace 上可用）。
保存/自动保存🔗 默认情况下，VS 代码需要一个明确的行动，将更改保存到磁盘，按Ctrl + S。
您也可以使用文件 &amp;gt; 自动保存从顶级菜单切换自动保存。
要进一步控制自动保存，请打开配置文件settings.json，然后找到相关的设置（如果没有则直接添加）：
它可以具有以下值：
  off -禁用自动保存。
  afterDelay - 在配置的延迟（默认 1000 毫秒）后保存文件。
  onFocusChange - 当焦点移出脏文件的编辑器时保存文件。
  onWindowChange - 当焦点移出 VS Code 窗口时保存文件。</description>
    </item>
    
    <item>
      <title>NMF包绘制热图</title>
      <link>https://kongjianyang.github.io/cn/2018/12/30/heatmap/</link>
      <pubDate>Sun, 30 Dec 2018 14:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2018/12/30/heatmap/</guid>
      <description>NMF包绘制热图 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc :first-child&#34;); var i, h, a; for (i = 0; i 0) h.removeAttribute(a[0].name); } });  /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){&#34;use strict&#34;;&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return t(e)}:t(e)}(&#34;undefined&#34;!=typeof window?window:this,function(C,e){&#34;use strict&#34;;var t=[],r=Object.</description>
    </item>
    
    <item>
      <title>使用Rmd写博客的一些流程</title>
      <link>https://kongjianyang.github.io/cn/2018/12/25/rmd/</link>
      <pubDate>Tue, 25 Dec 2018 14:32:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2018/12/25/rmd/</guid>
      <description>首先将Rmd文件转换为md文件
library(rmarkdown) a &amp;lt;- list.files(&amp;quot;./&amp;quot;, pattern = &amp;quot;.Rmd&amp;quot;) map(a, render, md_document()) #会将当前文件下所有的Rmd文件转化为md文件  on the Mac you could use the following commands to open RStudio (respectively) in the &amp;lsquo;~/projects/foo&amp;rsquo; directory or the current working directory:
 $ open -a RStudio ~/projects/foo $ open -a RStudio . 这里的open命令很有用
MacOS用户如果有用命令行的话，大多数人应该知道open .会打开Finder。事实上它能打开所有的目录，比如:
$ open ~/Library/Preferences $ open /etc $ open ../.. 你还能同时打开多个目录：
$ open ~/Documents ~/Desktop ~/Downloads $ open ~/D* 然后它还能打开各种文件，比如：
$ open document.</description>
    </item>
    
    <item>
      <title>R中进行文件以及文件系统管理</title>
      <link>https://kongjianyang.github.io/cn/2018/11/25/r_files/</link>
      <pubDate>Sun, 25 Nov 2018 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2018/11/25/r_files/</guid>
      <description>本文中提到的文件系统管理主要是指文件和目录（即文件夹）的创建、查看、重命名、复制、删除和文件权限处理。
1. 文件操作 创建文件
# 创建一个空文件 A.txt file.create(&amp;quot;A.txt&amp;quot;) # 查看当前目录下的子目录和文件 list.files() # 创建多个空文件 A1.txt，A2.txt，A3.txt file.create(&amp;quot;A1.txt&amp;quot;, &amp;quot;A2.txt&amp;quot;, &amp;quot;A3.txt&amp;quot;) # 查看当前目录下的子目录和文件 list.files() # 创建一个有内容的文件 B.txt cat(&amp;quot;文件测试\n&amp;quot;, file = &amp;quot;B.txt&amp;quot;) list.files()  查看文件
# 显示当前目录中的目录和文件 ## 下面两句结果相同 list.files() # 建议使用该命令，方便记忆 dir() #python中这个意味着查看文件属性 ## 参数full.names = TRUE，确定文件显示全名 ## 参数recursive = TRUE，递归显示，即把目录下的目录和文件都以文件的形式显示 list.files(, full.names = TRUE, recursive = TRUE) # 检查文件是否存在 ## 存在的文件 file.exists(&amp;quot;A.txt&amp;quot;) ## 不存在的文件 file.exists(&amp;quot;readme.txt&amp;quot;) # 判断是否是文件 file_test(&amp;quot;-f&amp;quot;, &amp;quot;A.txt&amp;quot;)  读取文件
# 文件A.txt读取 readLines(&amp;quot;A.</description>
    </item>
    
    <item>
      <title>R向文本文件插入内容</title>
      <link>https://kongjianyang.github.io/cn/2018/11/25/r_inscert_content/</link>
      <pubDate>Sun, 25 Nov 2018 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2018/11/25/r_inscert_content/</guid>
      <description>1. 创造文件并写入 fileConn&amp;lt;-file(&amp;quot;./output.txt&amp;quot;) #创造一个文件 writeLines(c(&amp;quot;Hello&amp;quot;,&amp;quot;World&amp;quot;), fileConn) #写入内容到文件内 close(fileConn)  2. 替代方法 可以使用sink和cat命令写入文件
sink函数将输出结果重定向到文件。
使用方式：sink(file = NULL, append = FALSE, type = c(“output”, “message”),split = FALSE)
append参数：布尔值。TRUE时，输出内容追加到文件尾部。FALSE，覆盖文件原始内容。
cat函数即能输出到屏幕，也能输出到文件.
使用方式：cat(… , file = ““, sep =” “, fill = FALSE, labels = NULL,append = FALSE)
有file时，输出到file。无file时，输出到屏幕。
append参数：布尔值。TRUE时，输出内容追加到文件尾部。FALSE，覆盖文件原始内容。
sink(&amp;quot;./outfile2.txt&amp;quot;) cat(&amp;quot;hello\nworld&amp;quot;) ## hello ## world sink()  3. 替代方法2 R中还有一个write函数，可以直接写入内容到文件内
line=&amp;quot;hello\nworld&amp;quot; write(line,file=&amp;quot;./outfile3.txt&amp;quot;)  4. 插入文件到文本指定位置 创造文件
line=&amp;quot;hello\nworld&amp;quot; write(line,file=&amp;quot;./outfile3.txt&amp;quot;)  读取文件
txt_cont &amp;lt;- readLines(&amp;quot;./outfile3.txt&amp;quot;, warn=FALSE) length(txt_cont) ## [1] 2  在文件的第二行插入内容重新写入</description>
    </item>
    
    <item>
      <title>Pearson-spearman相关性计算的异同</title>
      <link>https://kongjianyang.github.io/cn/2018/11/08/pearson_spearman/</link>
      <pubDate>Thu, 08 Nov 2018 13:42:27 -0500</pubDate>
      
      <guid>https://kongjianyang.github.io/cn/2018/11/08/pearson_spearman/</guid>
      <description>&lt;p&gt;三个相关性系数（pearson, spearman,
kendall）反应的都是两个变量之间变化趋势的方向以及程度，其值范围为-1到+1，0表示两个变量不相关，正值表示正相关，负值表示负相关，值越大表示相关性越强。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
